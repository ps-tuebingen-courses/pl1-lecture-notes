<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Type Inference - Programming Languages I</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Lecture notes for the Programming Languages I lecture at the University of TÃ¼bingen">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded affix "><li class="part-title">Introduction</li><li class="chapter-item expanded "><a href="../01-intro/intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../02-scala-basics/scala-basics.html"><strong aria-hidden="true">2.</strong> Scala Basics</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic Language Features</li><li class="chapter-item expanded "><a href="../03-arithmetic-expressions/arithmetic-expressions.html"><strong aria-hidden="true">3.</strong> Arithmetic Expressions</a></li><li class="chapter-item expanded "><a href="../04-desugaring/desugaring.html"><strong aria-hidden="true">4.</strong> Desugaring</a></li><li class="chapter-item expanded "><a href="../05-name-binding/name-binding.html"><strong aria-hidden="true">5.</strong> Name Binding</a></li><li class="chapter-item expanded "><a href="../06-first-order-functions/first-order-functions.html"><strong aria-hidden="true">6.</strong> First-Order Functions</a></li><li class="chapter-item expanded "><a href="../07-higher-order-functions/higher-order-functions.html"><strong aria-hidden="true">7.</strong> Higher-Order Functions</a></li><li class="chapter-item expanded "><a href="../08-lazy-evaluation/lazy-evaluation.html"><strong aria-hidden="true">8.</strong> Lazy Evaluation</a></li><li class="chapter-item expanded "><a href="../09-recursive-functions/recursive-functions.html"><strong aria-hidden="true">9.</strong> Recursive Functions</a></li><li class="chapter-item expanded "><a href="../10-mutation/mutation.html"><strong aria-hidden="true">10.</strong> Mutation</a></li><li class="chapter-item expanded affix "><li class="part-title">Miscellaneous</li><li class="chapter-item expanded "><a href="../11-garbage-collection/garbage-collection.html"><strong aria-hidden="true">11.</strong> Garbage Collection</a></li><li class="chapter-item expanded "><a href="../12-meta-interpretation/meta-interpretation.html"><strong aria-hidden="true">12.</strong> Syntactic and Meta-Interpretation</a></li><li class="chapter-item expanded "><a href="../13-church-encoding/church-encoding.html"><strong aria-hidden="true">13.</strong> Church Encodings</a></li><li class="chapter-item expanded "><a href="../14-object-algebras/object-algebras.html"><strong aria-hidden="true">14.</strong> Object Algebras</a></li><li class="chapter-item expanded affix "><li class="part-title">Continuations</li><li class="chapter-item expanded "><a href="../15-continuations-1/continuations-1.html"><strong aria-hidden="true">15.</strong> Continuations: Motivation</a></li><li class="chapter-item expanded "><a href="../16-continuations-2/continuations-2.html"><strong aria-hidden="true">16.</strong> Continuations: Definition</a></li><li class="chapter-item expanded "><a href="../17-first-class-continuations/first-class-continuations.html"><strong aria-hidden="true">17.</strong> First-Class Continuations</a></li><li class="chapter-item expanded "><a href="../18-letcc/letcc.html"><strong aria-hidden="true">18.</strong> Call-with-current-continuation</a></li><li class="chapter-item expanded "><a href="../19-shift-reset/shift-reset.html"><strong aria-hidden="true">19.</strong> Delimited Continuations</a></li><li class="chapter-item expanded affix "><li class="part-title">Monads</li><li class="chapter-item expanded "><a href="../20-monads-intro/monads-intro.html"><strong aria-hidden="true">20.</strong> Monads Intro</a></li><li class="chapter-item expanded "><a href="../21-io-monad/io-monad.html"><strong aria-hidden="true">21.</strong> The IO Monad</a></li><li class="chapter-item expanded "><a href="../22-modular-interpreters/modular-interpreters.html"><strong aria-hidden="true">22.</strong> Modular Interpreters</a></li><li class="chapter-item expanded "><a href="../23-monadic-reflection/monadic-reflection.html"><strong aria-hidden="true">23.</strong> Monadic Reflection</a></li><li class="chapter-item expanded affix "><li class="part-title">Program Transformations</li><li class="chapter-item expanded "><a href="../24-defunctionalization/defunctionalization.html"><strong aria-hidden="true">24.</strong> Defunctionalization, Refunctionalization</a></li><li class="chapter-item expanded affix "><li class="part-title">Type Systems</li><li class="chapter-item expanded "><a href="../25-type-systems/type-systems.html"><strong aria-hidden="true">25.</strong> Type Systems</a></li><li class="chapter-item expanded "><a href="../26-stlc/stlc.html"><strong aria-hidden="true">26.</strong> Simply Typed Lambda Calculus (STLC)</a></li><li class="chapter-item expanded "><a href="../27-type-inference/type-inference.html" class="active"><strong aria-hidden="true">27.</strong> Type Inference</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programming Languages I</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes/blob/master/src/27-type-inference/type-inference.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h1>
<p>The content of this chapter is available as a Scala file <a href="./type-inference.scala">here.</a></p>
<p>Type inference (sometimes called type reconstruction) is the idea to avoid type annotations
in the program and instead infer all typing-related information from the program.
For instance, if <code>+</code> is an operator on numbers, then we can infer that <code>x</code> must have
the number type in an expression <code>x + 1</code>.</p>
<p>The best-known type inference algorithm is Hindley-Milner type inference with so-called &quot;let-polymorphism&quot;.
The basic idea of this algorithm is that the type checker synthesizes fresh type variables
whenever a type that is not yet known is needed as an input to a recursive call of the type
checking algorithm. For instance, in a function definition, a fresh type variable is created for the type of
the function argument. In addition to producing a type as output, the type checker will also produce
a set of equality constraints between types (containing type variables). Type checking succeeds only if these
equality constraints have a solution. &quot;Having a solution&quot; means that there is a <em>substitution</em>
(a mapping from type variables to types) that makes all equations trivial. For instance, the substitution that
substitutes <code>X</code> by <code>Num</code> and <code>Y</code> by <code>Bool</code> is a solution for the constraints <code>FunType(X, Bool) == FunType(Num, Y)</code>.</p>
<p>In the code below we choose a slightly different representation of substitution, namely as a function
that performs the substitution (with regard to our discussion of refunctionalization we could say
that we refunctionalize the substitution type).</p>
<pre><code class="language-scala">enum Type:
  case FunType(from: Type, to: Type)
  case NumType()
  case TypeVar(x: String)
import Type._

def freeTypeVars(t: Type): Set[String] = t match {
  case FunType(f, t) =&gt; freeTypeVars(f) ++ freeTypeVars(t)
  case NumType() =&gt; Set.empty
  case TypeVar(x) =&gt; Set(x)
}

def substitution(x: String, s: Type) = new Function[Type, Type] {
  def apply(t: Type) = t match {
    case FunType(from, to) =&gt; FunType(this(from), this(to))
    case NumType() =&gt; NumType()
    case TypeVar(y) =&gt; if (x == y) s else TypeVar(y)
  }
}
</code></pre>
<p>Note that in the <code>FunType</code>-case <code>this</code> is the substitution itself which is simply applied to the input and output type.</p>
<p>A substitution can be found (if it exists) by an algorithm called the
&quot;Robinson unification algorithm&quot;:</p>
<pre><code class="language-scala">def unify(eq: List[(Type, Type)]): Type =&gt; Type = eq match {
  case Nil =&gt; identity _
  case (NumType(), NumType()) :: rest =&gt; unify(rest)
  case (FunType(f1, t1), FunType(f2, t2)) :: rest =&gt; unify((f1, f2) :: (t1, t2) :: rest)
  case (TypeVar(x), TypeVar(y)) :: rest if x == y =&gt; unify(rest)
  case (TypeVar(x), t) :: rest =&gt; {
    if (freeTypeVars(t)(x)) sys.error(s&quot;Occurs check: $x occurs in $t&quot;)
    val s = substitution(x, t)
    // andThen is just function composition with the first function (here s) applied first
    s.andThen(unify(rest.map(p =&gt; (s(p._1), s(p._2)))))
  }
  case (t, TypeVar(x)) :: rest =&gt; unify((TypeVar(x), t) :: rest)
  case (t1, t2) :: rest =&gt; sys.error(s&quot;Cannot unify $t1 and $t2&quot;)
}
</code></pre>
<p>It is not easy to see that this algorithm terminates in all cases, but it does (ask yourself: why?).
It is both sound and complete. It returns the so-called &quot;most general unifier&quot;.</p>
<p>Let us now apply this to a concrete language. Here is its definition:</p>
<pre><code class="language-scala">enum Exp:
  case Num(n: Int)
  case Id(name: String)
  case Add(lhs: Exp, rhs: Exp)
  case Fun(param: String, body: Exp) // No type annotation!
  case Ap(funExpr: Exp, argExpr: Exp)
  case Let(x: String, xdef: Exp, body: Exp)

object Exp:
  implicit def num2exp(n: Int): Exp = Num(n)
  implicit def id2exp(s: String): Exp = Id(s)

import Exp._

def freshName(names: Set[String], default: String): String = {
  var last: Int = 0
  var freshName = default
  while (names contains freshName) { freshName = default + last.toString; last += 1; }
  freshName
}

def freeVars(e: Exp): Set[String] =  e match {
   case Id(x) =&gt; Set(x)
   case Add(l, r) =&gt; freeVars(l) ++ freeVars(r)
   case Fun(x, body) =&gt; freeVars(body) - x
   case Ap(f, a) =&gt; freeVars(f) ++ freeVars(a)
   case Num(n) =&gt; Set.empty
   case Let(x, xdef, body) =&gt; freeVars(xdef) ++ (freeVars(body) - x)
}

def subst(e1: Exp, x: String, e2: Exp): Exp = e1 match {
  case Num(n) =&gt; e1
  case Add(l, r) =&gt; Add(subst(l, x, e2), subst(r, x, e2))
  case Id(y) =&gt; if (x == y) e2 else Id(y)
  case Ap(f, a) =&gt; Ap(subst(f, x, e2), subst(a, x, e2))
  case Fun(param, body) =&gt;
    if (param == x) e1 else {
      val fvs = freeVars(body) ++ freeVars(e2)
      val newvar = freshName(fvs, param)
      Fun(newvar, subst(subst(body, param, Id(newvar)), x, e2))
    }
  case Let(y, ydef, body) =&gt;
    if (x == y) Let(y, subst(ydef, x, e2), body) else {
      val fvs = freeVars(body) ++ freeVars(e2)
      val newvar = freshName(fvs, y)
      Let(newvar, subst(ydef, x, e2), subst(subst(body, y, Id(newvar)), x, e2))
    }
}

def eval(e: Exp): Exp = e match {
  case Id(v) =&gt; sys.error(&quot;unbound identifier: &quot; + v)
  case Add(l, r) =&gt; (eval(l), eval(r)) match {
    case (Num(x), Num(y)) =&gt; Num(x + y)
    case _ =&gt; sys.error(&quot;can only add numbers&quot;)
  }
  case Ap(f, a) =&gt; eval(f) match {
    case Fun(x, body) =&gt; eval(subst(body, x, eval(a))) // call-by-value
    case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  }
  case Let(x, xdef, body) =&gt; eval(subst(body, x, eval(xdef)))
  case _ =&gt; e // numbers and functions evaluate to themselves
}
</code></pre>
<p>The type checker returns both a type (possibly containing type variables) and a list
of equality constraints. Note that the only way type checking can actually fail is
when encountering a free variable.</p>
<pre><code class="language-scala">var tyvCount: Int = 0
def freshTypeVar: TypeVar = {
  tyvCount += 1
  TypeVar(&quot;X&quot; + tyvCount.toString)
}

def typeCheck(e: Exp, gamma: Map[String, Type]): (List[(Type, Type)], Type) = e match {
  case Num(n) =&gt; (List.empty, NumType())
  case Id(x) =&gt; gamma.get(x) match {
    case Some(t) =&gt; (List.empty, t)
    case _ =&gt; sys.error(&quot;free variable: &quot; ++ x.toString)
  }
  case Add(l, r) =&gt; (typeCheck(l, gamma), typeCheck(r, gamma)) match {
    case ((eq1, t1), (eq2, t2)) =&gt;
      ((t1, NumType()) :: (t2, NumType()) :: (eq1 ++ eq2), NumType())
  }
  case Fun(x, body) =&gt; {
    val xtype = freshTypeVar
    val resbody = typeCheck(body, gamma + (x -&gt; xtype))
    (resbody._1, FunType(xtype, resbody._2))
  }
  case Ap(f, a) =&gt; {
    val toType = freshTypeVar
    (typeCheck(f, gamma), typeCheck(a, gamma)) match {
      case ((eqs1, ft), (eqs2, at)) =&gt;
        ((ft, FunType(at, toType)) :: (eqs1 ++ eqs2), toType)
    }
  }
  case Let(x, xdef, body) =&gt; {
    // important if x is not used in body
    val (constraints1, _) = typeCheck(xdef, gamma)
    // Let-Polymorphism! type check after substitution
    val (constraints2, typ) = typeCheck(subst(body, x, xdef), gamma)
    (constraints1 ++ constraints2, typ)
  }

}
</code></pre>
<p>The <code>Let</code>-case of the type checker implements a special extension of the type checking algorithm, which
allows one to use the same definition type-polymorphically at multiple types. This is achieved by first
substituting the binding into the body and only then type check the latter. This way, any occurrence of
the binding in the body can have a different type. Note further, that we still type check the definition
of the binding explicitly, in order to gather the generated constraints also in the case that the binding
is not used in the body.</p>
<p>Full type checking is completed only when the constraints have a solution.
The resulting substitution is then applied to the returned type to give the overall inferred type.
This is captured by the following definition.</p>
<pre><code class="language-scala">def doTypeCheck(e: Exp, gamma: Map[String, Type]) = {
  val (constraints, resType) = typeCheck(e, gamma)
  unify(constraints)(resType)
}

assert(doTypeCheck(42, Map.empty) == NumType())
assert(doTypeCheck(Fun(&quot;x&quot;, Add(&quot;x&quot;, 1)), Map.empty) == FunType(NumType(), NumType()))
</code></pre>
<h3 id="properties-of-type-inference"><a class="header" href="#properties-of-type-inference">Properties of type inference</a></h3>
<p>As an instance of let-polymorphism, consider the following example where the identity function
is once applied to a function and once to a number:</p>
<pre><code class="language-scala">val exId =
  doTypeCheck(
    Let(&quot;id&quot;, Fun(&quot;x&quot;, &quot;x&quot;), Ap(Ap(&quot;id&quot;, Fun(&quot;x&quot;, Add(&quot;x&quot;, 1))), Ap(&quot;id&quot;, 42))),
    Map.empty)
// exId: Type = NumType()
</code></pre>
<p>This function could not be type checked in STLC.</p>
<p>This example, on the other hand, should trigger an occurs check error:</p>
<pre><code class="language-scala">val exOmega = doTypeCheck(Fun(&quot;x&quot;, Ap(&quot;x&quot;, &quot;x&quot;)), Map.empty)
// java.lang.RuntimeException: Occurs check: X9 occurs in FunType(TypeVar(X9),TypeVar(X10))
// 	at scala.sys.package$.error(package.scala:27)
// 	at repl.MdocSession$MdocApp.unify(type-inference.md:45)
// 	at repl.MdocSession$MdocApp.doTypeCheck(type-inference.md:176)
// 	at repl.MdocSession$MdocApp.$init$$$anonfun$1(type-inference.md:202)
// 	at repl.MdocSession$MdocApp.$init$$$anonfun$adapted$1(type-inference.md:203)
</code></pre>
<p>Hence <code>omega</code> cannot be type checked in STLC (and not even with let-polymorphism).
STLC has the remarkable property that all well-typed programs terminate.</p>
<p>Type inference satisfies the following completeness property:</p>
<blockquote>
<p>If there exist type annotations that make a program type check in the STLC type checker,
then the type inference will also be able to type check the non-annotated version of the program.</p>
</blockquote>
<p>Further, due to let-polymorphism, with type inference we can also type check some programs that would be ill-formed in STLC.</p>
<p>Moreover, the type system is still sound:</p>
<blockquote>
<p>If <code>doTypeCheck(e, Map.empty) == t</code>, then <code>eval(e) == v</code> and <code>doTypeCheck(v) == t</code> (modulo \( \alpha \)-renaming of type variables).</p>
</blockquote>
<!-- prevent questionnaire from showing up if there is no javascript enabled-->
<p><noscript><style>questionnaire { display: none; }</style></noscript></p>
<!-- warning for user - feel free to leave out or customize -->
<p><noscript><div>Enable JavaScript to see the quiz</div></noscript></p>
<questionnaire language="en">
  <question type="multiplechoice">
    Which of the following pairs of types can be unified?
    <solution>
      <code class="language-scala">
      FunType(NumType(), NumType())
      </code>
      &nbsp; and
      <code class="language-scala">
      FunType(TypeVar("X"), TypeVar("X"))
      </code>
    </solution>
    <distractor>
      <code class="language-scala">
      FunType(TypeVar("X"), TypeVar("Y"))
      </code>
      &nbsp; and
      <code class="language-scala">
      NumType()
      </code>
      <explanation>A function type can never be unified with <code class="language-scala">NumType()</code>.</explanation>
    </distractor>
    <solution>
      <code class="language-scala">
      FunType(NumType(), TypeVar("X"))
      </code>
      &nbsp; and
      <code class="language-scala">
      FunType(NumType(), TypeVar("Y"))
      </code>
    </solution>
    <solution>
      <code class="language-scala">
      FunType(NumType(), TypeVar("Y"))
      </code>
      &nbsp; and
      <code class="language-scala">
      TypeVar("X")
      </code>
    </solution>
  </question>
</questionnaire>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../26-stlc/stlc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../26-stlc/stlc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../questionnaire.js"></script>
    </body>
</html>
