<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lazy Evaluation - Programming Languages I</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Lecture notes for the Programming Languages I lecture at the University of TÃ¼bingen">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded affix "><li class="part-title">Introduction</li><li class="chapter-item expanded "><a href="../01-intro/intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../02-scala-basics/scala-basics.html"><strong aria-hidden="true">2.</strong> Scala Basics</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic Language Features</li><li class="chapter-item expanded "><a href="../03-arithmetic-expressions/arithmetic-expressions.html"><strong aria-hidden="true">3.</strong> Arithmetic Expressions</a></li><li class="chapter-item expanded "><a href="../04-desugaring/desugaring.html"><strong aria-hidden="true">4.</strong> Desugaring</a></li><li class="chapter-item expanded "><a href="../05-name-binding/name-binding.html"><strong aria-hidden="true">5.</strong> Name Binding</a></li><li class="chapter-item expanded "><a href="../06-first-order-functions/first-order-functions.html"><strong aria-hidden="true">6.</strong> First-Order Functions</a></li><li class="chapter-item expanded "><a href="../07-higher-order-functions/higher-order-functions.html"><strong aria-hidden="true">7.</strong> Higher-Order Functions</a></li><li class="chapter-item expanded "><a href="../08-lazy-evaluation/lazy-evaluation.html" class="active"><strong aria-hidden="true">8.</strong> Lazy Evaluation</a></li><li class="chapter-item expanded "><a href="../09-recursive-functions/recursive-functions.html"><strong aria-hidden="true">9.</strong> Recursive Functions</a></li><li class="chapter-item expanded "><a href="../10-mutation/mutation.html"><strong aria-hidden="true">10.</strong> Mutation</a></li><li class="chapter-item expanded affix "><li class="part-title">Miscellaneous</li><li class="chapter-item expanded "><a href="../11-garbage-collection/garbage-collection.html"><strong aria-hidden="true">11.</strong> Garbage Collection</a></li><li class="chapter-item expanded "><a href="../12-meta-interpretation/meta-interpretation.html"><strong aria-hidden="true">12.</strong> Syntactic and Meta Interpretation</a></li><li class="chapter-item expanded "><a href="../13-church-encoding/church-encoding.html"><strong aria-hidden="true">13.</strong> Church Encodings</a></li><li class="chapter-item expanded "><a href="../14-object-algebras/object-algebras.html"><strong aria-hidden="true">14.</strong> Object Algebras</a></li><li class="chapter-item expanded affix "><li class="part-title">Continuations</li><li class="chapter-item expanded "><a href="../15-continuations-1/continuations-1.html"><strong aria-hidden="true">15.</strong> Continuations: Motivation</a></li><li class="chapter-item expanded "><a href="../16-continuations-2/continuations-2.html"><strong aria-hidden="true">16.</strong> Continuations: Definition</a></li><li class="chapter-item expanded "><a href="../17-first-class-continuations/first-class-continuations.html"><strong aria-hidden="true">17.</strong> First-Class Continuations</a></li><li class="chapter-item expanded "><a href="../18-letcc/letcc.html"><strong aria-hidden="true">18.</strong> Call-with-current-continuation</a></li><li class="chapter-item expanded "><a href="../19-shift-reset/shift-reset.html"><strong aria-hidden="true">19.</strong> Delimited Continuations</a></li><li class="chapter-item expanded affix "><li class="part-title">Monads</li><li class="chapter-item expanded "><a href="../20-monads-intro/monads-intro.html"><strong aria-hidden="true">20.</strong> Monads Intro</a></li><li class="chapter-item expanded "><a href="../21-io-monad/io-monad.html"><strong aria-hidden="true">21.</strong> The IO Monad</a></li><li class="chapter-item expanded "><a href="../22-modular-interpreters/modular-interpreters.html"><strong aria-hidden="true">22.</strong> Modular Interpreters</a></li><li class="chapter-item expanded "><a href="../23-monadic-reflection/monadic-reflection.html"><strong aria-hidden="true">23.</strong> Monadic Reflection</a></li><li class="chapter-item expanded affix "><li class="part-title">Program Transformations</li><li class="chapter-item expanded "><a href="../24-defunctionalization/defunctionalization.html"><strong aria-hidden="true">24.</strong> Defunctionalization, Refunctionalization</a></li><li class="chapter-item expanded affix "><li class="part-title">Type Systems</li><li class="chapter-item expanded "><a href="../25-type-systems/type-systems.html"><strong aria-hidden="true">25.</strong> Type Systems</a></li><li class="chapter-item expanded "><a href="../26-stlc/stlc.html"><strong aria-hidden="true">26.</strong> Simply Typed Lambda Calculus (STLC)</a></li><li class="chapter-item expanded "><a href="../27-type-inference/type-inference.html"><strong aria-hidden="true">27.</strong> Type Inference</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programming Languages I</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes/blob/master/src/08-lazy-evaluation/lazy-evaluation.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lazy-evaluation"><a class="header" href="#lazy-evaluation">Lazy Evaluation</a></h1>
<p>The content of this chapter is available as a Scala file <a href="./lazy-evaluation.scala">here.</a></p>
<h2 id="motivation-for-lazy-evaluation"><a class="header" href="#motivation-for-lazy-evaluation">Motivation for Lazy Evaluation</a></h2>
<p>Read &quot;Why Functional Programming Matters&quot; by John Hughes available at <a href="https://www.cse.chalmers.se/%7Erjmh/Papers/whyfp.html">https://www.cse.chalmers.se/~rjmh/Papers/whyfp.html</a>.</p>
<p>What lazy evaluation means:</p>
<p>The choice of evaluation strategy is a purely semantic change that requires no change of the syntax.
For this reason we reuse the syntactic definitions of FAE, hence load
<a href="../07-higher-order-functions/higher-order-functions.scala">higher-order-functions.scala</a>
before executing this script.
Before we discuss lazy evaluation, we will first discuss a related evaluation strategy, <em>call-by-name</em>.</p>
<p><em>Call-by-name</em> can be explained very succintly in the substitution-based interpreter: Instead of evaluating the argument <code>a</code> in the
<code>Ap</code> case before substitution, we substitute the unevaluated argument into the body. The rest remains exactly the same.</p>
<pre><code class="language-scala">def evalcbn(e: Exp): Exp = e match {
  case Id(v) =&gt; sys.error(&quot;unbound identifier: &quot; + v)
  case Add(l, r) =&gt; (evalcbn(l), evalcbn(r)) match {
                     case (Num(x), Num(y)) =&gt; Num(x + y)
                     case _ =&gt; sys.error(&quot;can only add numbers&quot;)
                    }
  case Ap(f, a) =&gt; evalcbn(f) match {
     case Fun(x, body) =&gt; evalcbn(subst(body, x, a)) // no evaluation of a!
     case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  }
  case _ =&gt; e
}
</code></pre>
<p>Does this change the semantics, or is it just an implementation detail? In other words, is <code>eval(e) == evalcbn(e)</code> for all <code>e</code> ?
Let's try two former test cases.</p>
<pre><code class="language-scala">assert(evalcbn(test) == eval(test))
assert(evalcbn(test2) == eval(test2))
</code></pre>
<p>One can formally prove that if <code>eval</code> and <code>evalcbn</code> both produce a number then the numbers are equal. Do they also agree if they produce
a function?
Not necessarily. Consider:</p>
<pre><code class="language-scala">val test3 = Ap(Fun(&quot;a&quot;, Fun(&quot;x&quot;, Add(&quot;a&quot;, &quot;x&quot;))), Add(1, 2))

assert(eval(test3) == Fun(&quot;x&quot;, Add(3, &quot;x&quot;)))
assert(evalcbn(test3) == Fun(&quot;x&quot;, Add(Add(1, 2), &quot;x&quot;)))
</code></pre>
<p>However, if both produce a function, then the functions &quot;behave&quot; the same. More specifically, the function bodies produced by <code>eval</code>
may be &quot;more evaluated&quot; than those produced by <code>evalcbn</code> since for the latter the evaluation of the arguments substituted for the parameters
in the body is deferred. If we evaluated within function bodies (also called evaluation &quot;under a
lambda&quot;) - which our interpreters do not do - we could produce the expression returned from <code>eval</code> from the expression returned by <code>evalcbn</code>.
This kind of equivalence is also called &quot;beta-equivalence&quot;.</p>
<p>Most importantly, however, <code>eval</code> and <code>evalcbn</code> differ with regard to their termination behavior. We have seen that <code>omega</code> is a diverging
expression. In <code>eval</code>, the term</p>
<pre><code class="language-scala"> val test4 = Ap(Fun(&quot;x&quot;, 5), omega)
</code></pre>
<p>is hence also diverging. In contrast:</p>
<pre><code class="language-scala">assert(evalcbn(test4) == Num(5))
</code></pre>
<h2 id="extra-material-infinite-lists-in-fae-not-relevant-for-exam"><a class="header" href="#extra-material-infinite-lists-in-fae-not-relevant-for-exam">Extra material: Infinite lists in FAE (not relevant for exam)</a></h2>
<p>Using our call-by-name interpreter, we can express the same kinds of programming patterns that we have tried in Haskell, such as
infinite lists.</p>
<p>We do not have direct support for lists, but we can encode lists. This kind of encoding is called <em>Church encoding</em>.</p>
<pre><code class="language-scala">val nil = Fun(&quot;c&quot;, Fun(&quot;e&quot;, &quot;e&quot;))
val cons  = Fun(&quot;x&quot;, Fun(&quot;xs&quot;, Fun(&quot;c&quot;, Fun(&quot;e&quot;, Ap(Ap(&quot;c&quot;, &quot;x&quot;), Ap(Ap(&quot;xs&quot;, &quot;c&quot;), &quot;e&quot;))))))
</code></pre>
<p>For instance, the list 1, 2, 3 is encoded as:</p>
<pre><code class="language-scala">val list123 = Ap(Ap(&quot;cons&quot;, 1), Ap(Ap(&quot;cons&quot;, 2), Ap(Ap(&quot;cons&quot;, 3), &quot;nil&quot;)))
</code></pre>
<p>The map function on lists becomes:</p>
<pre><code class="language-scala">val maplist = Fun(&quot;f&quot;, Fun(&quot;l&quot;, Ap(Ap(&quot;l&quot;, Fun(&quot;x&quot;, Fun(&quot;xs&quot;, Ap(Ap(&quot;cons&quot;, Ap(&quot;f&quot;, &quot;x&quot;)), &quot;xs&quot;)))), &quot;nil&quot;)))
</code></pre>
<p>For instance, we can map the successor function over the 1, 2, 3 list.</p>
<pre><code class="language-scala">val test5 = wth(&quot;cons&quot;, cons,
            wth(&quot;nil&quot;, nil,
            wth(&quot;maplist&quot;, maplist,
            Ap(Ap(&quot;maplist&quot;, Fun(&quot;x&quot;, Add(&quot;x&quot;, 1))), list123))))
</code></pre>
<p>Since it is somewhat difficult to print out the resulting list in our primitive language we construct the result we expect explicitly.</p>
<pre><code class="language-scala">val test5res = wth(&quot;cons&quot;, cons,
               wth(&quot;nil&quot;, nil,
                 Ap(Ap(&quot;cons&quot;, 2), Ap(Ap(&quot;cons&quot;, 3), Ap(Ap(&quot;cons&quot;, 4), &quot;nil&quot;)))))
assert(eval(test5) == eval(test5res))
</code></pre>
<p>Using <code>evalcbn</code> instead of <code>eval</code> the assertion does not hold (why?), but the results are beta-equivalent.
We can also construct infinite lists. To this end, we need some form of recursion. We choose the standard fixed-point operator Y.
This operator only works under call-by-name or other so-called &quot;non-strict&quot; evaluation strategies.</p>
<pre><code class="language-scala">val y = Fun(&quot;f&quot;, Ap(Fun(&quot;x&quot;, Ap(&quot;f&quot;, Ap(&quot;x&quot;, &quot;x&quot;))), Fun(&quot;x&quot;, Ap(&quot;f&quot;, Ap(&quot;x&quot;, &quot;x&quot;)))))
</code></pre>
<p>Using Y, we can construct infinite lists, such as the list of all natural numbers.</p>
<pre><code class="language-scala">val allnats = Ap(Ap(&quot;y&quot;, Fun(&quot;nats&quot;, Fun(&quot;n&quot;, Ap(Ap(&quot;cons&quot;, &quot;n&quot;), Ap(&quot;nats&quot;, Add(&quot;n&quot;, 1)))))), 1)
</code></pre>
<p>We can also perform standard computations on infinite lists, such as mapping the successor function over it.</p>
<pre><code class="language-scala">val list2toinfty = wth(&quot;cons&quot;, cons,
                   wth(&quot;nil&quot;, nil,
                   wth(&quot;y&quot;, y,
                   wth(&quot;maplist&quot;, maplist,
                      Ap(Ap(&quot;maplist&quot;, Fun(&quot;x&quot;, Add(&quot;x&quot;, 1))), allnats)))))
</code></pre>
<p>Of course, <code>list2toinfty</code> diverges when we use <code>eval</code>, but it works fine with <code>evalcbn</code>. It is hard to verify the result due to
an almost unreadable output. Hence we propose the following</p>
<p>Exercise: Extend the language such that you can implement the &quot;take&quot; function as known from Haskell within the language
(if0-expressions or something like it are needed for that). Now add a &quot;print&quot; function that prints a number on the console.
Use it to display that the first 3 list elements of <code>list2toinfty</code> are 2, 3, 4.</p>
<p><em>end of extra material</em></p>
<h2 id="environment-based-lazy-evaluation"><a class="header" href="#environment-based-lazy-evaluation">Environment-based lazy evaluation</a></h2>
<p>Let us now consider the question how we can implement call-by-name in the environment-based interpreter. Translating the idea of not
evaluating the function argument to the environment-based version seems to  suggest that the environment should map identifiers to
expressions instead of values.</p>
<p>However, we run into the same problems that we had with first-class functions before we introduced closures: What happens to the
deferred substitutions that still have to be applied in the function argument? If we discard the environment in which the function
argument was defined we again introduce a variant of dynamic scoping.</p>
<p>Hence, like for closures, we need to store the environment together with the expression. We call such a  pair a <em>thunk</em>. An environment
thus becomes a mapping from symbols to thunks. Note that this makes environments and thunks mutually recursive. In Scala, we can therefore
not use type definitions of the form</p>
<pre><code>   type Thunk = (Exp, Env)
   type Env = Map[String, Thunk]
</code></pre>
<p>Instead, we use a Scala class <code>Env</code> to express this recursion.
Since we want to experiment with different variants of how to generate and evaluate thunks we first create a parameterizable variant
of the evaluator that leaves open how to</p>
<ol>
<li>represent thunks (type <code>Thunk</code>)</li>
<li>create thunks (method <code>delay</code>)</li>
<li>evaluate thunks (method <code>force</code>).</li>
</ol>
<p><strong>Hint</strong>: Research on the internet what abstract type members in Scala are. For instance, <a href="http://www.scala-lang.org/node/105">here</a>.</p>
<pre><code class="language-scala">trait CBN {
  type Thunk

  def delay(e: Exp, env: EnvThunk): Thunk
  def force(t: Thunk): ValueCBN

  case class EnvThunk(map: Map[String, Thunk]) {
    def apply(key: String): Thunk = map.apply(key)
    def +(other: (String, Thunk)): EnvThunk = EnvThunk(map + other)
  }

  // since values also depend on EnvThunk and hence on Thunk they need to
  // be defined within this trait
  sealed abstract class ValueCBN
  case class NumV(n: Int) extends ValueCBN
  case class ClosureV(f: Fun, env: EnvThunk) extends ValueCBN
  def evalCBN(e: Exp, env: EnvThunk): ValueCBN = e match {
    case Id(x) =&gt; force(env(x)) // force evaluation of thunk if identifier is evaluated
    case Add(l, r) =&gt; {
      (evalCBN(l, env), evalCBN(r, env)) match {
        case (NumV(v1), NumV(v2)) =&gt; NumV(v1 + v2)
        case _ =&gt; sys.error(&quot;can only add numbers&quot;)
      }
    }
    case Ap(f, a) =&gt; evalCBN(f, env) match {
      // delay argument expression and add it to environment of the closure
      case ClosureV(f, cenv) =&gt; evalCBN(f.body, cenv + (f.param -&gt; delay(a, env)))
      case _ =&gt; sys.error(&quot;can only apply functions&quot;)
    }
    case Num(n) =&gt; NumV(n)
    case f@Fun(x, body) =&gt; ClosureV(f, env)
  }
}
</code></pre>
<p>Let's now create an instance of CBN that corresponds to the substitution-based call-by-name interpreter. A thunk is just a pair
of expression and environment. Forcing a thunk just evaluates it in the stored environment.
To understand what is going on during evaluation of tests we trace argument evaluation by a  printout to the console.</p>
<pre><code class="language-scala">object CallByName extends CBN {
  type Thunk = (Exp, EnvThunk)
  def delay(e: Exp, env: EnvThunk) = (e, env)
  def force(t: Thunk) = {
    println(&quot;Forcing evaluation of expression: &quot; + t._1)
    evalCBN(t._1, t._2)
  }
}

assert(CallByName.evalCBN(test, CallByName.EnvThunk(Map.empty)) == CallByName.NumV(12))
// Forcing evaluation of expression: Num(7)
</code></pre>
<h2 id="call-by-need"><a class="header" href="#call-by-need">Call-by-need</a></h2>
<p>Call-by-name is rather wasteful: If an argument is used <em>n</em> times in the body, the argument expression is re-evaluated <em>n</em> times.
For instance, in</p>
<pre><code class="language-scala">val cbntest = wth(&quot;double&quot;, Fun(&quot;x&quot;, Add(&quot;x&quot;, &quot;x&quot;)),
              Ap(&quot;double&quot;, Add(2, 3)))
</code></pre>
<p>the sum of 2 and 3 is computed twice.  If the argument is passed again to another function, this may lead to an exponential blowup.</p>
<p>Example:</p>
<pre><code class="language-scala">val blowup = wth(&quot;a&quot;, Fun(&quot;x&quot;, Add(&quot;x&quot;, &quot;x&quot;)),
             wth(&quot;b&quot;, Fun(&quot;x&quot;, Add(Ap(&quot;a&quot;, &quot;x&quot;), Ap(&quot;a&quot;, &quot;x&quot;))),
             wth(&quot;c&quot;, Fun(&quot;x&quot;, Add(Ap(&quot;b&quot;, &quot;x&quot;), Ap(&quot;b&quot;, &quot;x&quot;))),
             wth(&quot;d&quot;, Fun(&quot;x&quot;, Add(Ap(&quot;c&quot;, &quot;x&quot;), Ap(&quot;c&quot;, &quot;x&quot;))),
             wth(&quot;e&quot;, Fun(&quot;x&quot;, Add(Ap(&quot;d&quot;, &quot;x&quot;), Ap(&quot;d&quot;, &quot;x&quot;))),
             wth(&quot;f&quot;, Fun(&quot;x&quot;, Add(Ap(&quot;e&quot;, &quot;x&quot;), Ap(&quot;e&quot;, &quot;x&quot;))),
             Ap(&quot;f&quot;, Add(2, 3))))))))
</code></pre>
<p>Can we do better? Yes, by caching the value when the argument expression is evaluated for the first time. This evaluation strategy is
called <em>call-by-need</em>.</p>
<p>Caching is easy to implement in Scala:</p>
<pre><code class="language-scala">object CallByNeed extends CBN {
  case class MemoThunk(e: Exp, env: EnvThunk) {
    var cache: ValueCBN = null
  }
  type Thunk = MemoThunk
  def delay(e: Exp, env: EnvThunk) = MemoThunk(e, env)
  def force(t: Thunk) = {
    if (t.cache == null) {
      println(&quot;Forcing evaluation of expression: &quot; + t.e)
      t.cache = evalCBN(t.e, t.env)
    } else {
      println (&quot;Reusing cached value &quot; + t.cache + &quot; for expression &quot; + t.e)
    }
    t.cache
  }
}
</code></pre>
<p>For instance, compare call-by-need and call-by-name in <code>cbntest</code> or <code>blowup</code>.
However, the meta-language (i.e., the subset of Scala features) used in the interpreter has become more complicated:</p>
<p>Since we are using mutation, the order of evaluation and aliasing of object references becomes important.
Luckily, call-by-need agrees with call-by-name with regard to produced values and termination behavior, hence it is usually not
necessary to reason about programs with the call-by-need semantics. If, however, one wants to reason about the performance of a
program in a call-by-need setting, one has to take these additional complications into account.
In practice, it is even worse, since languages like Haskell perform additional optimizations that, for instance, switch to call-by-value if an analysis can
determine that an argument will definitely be used (look up &quot;strictness analysis&quot;).</p>
<p>Topics for class discussion:</p>
<ul>
<li>Is it a good idea to mix a language with implicit mutation (such as Java, Scala, C++, Python, ...) with lazy evaluation?</li>
<li>How can one simulate lazy evaluation in an eager language? Basic idea: 'Lambda' as evaluation firewall.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../07-higher-order-functions/higher-order-functions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../09-recursive-functions/recursive-functions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../07-higher-order-functions/higher-order-functions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../09-recursive-functions/recursive-functions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../questionnaire.js"></script>
    </body>
</html>
