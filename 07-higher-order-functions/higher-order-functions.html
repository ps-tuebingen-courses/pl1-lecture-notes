<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Higher-Order Functions - Programming Languages I</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Lecture notes for the Programming Languages I lecture at the University of TÃ¼bingen">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded affix "><li class="part-title">Introduction</li><li class="chapter-item expanded "><a href="../01-intro/intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../02-scala-basics/scala-basics.html"><strong aria-hidden="true">2.</strong> Scala Basics</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic Language Features</li><li class="chapter-item expanded "><a href="../03-arithmetic-expressions/arithmetic-expressions.html"><strong aria-hidden="true">3.</strong> Arithmetic Expressions</a></li><li class="chapter-item expanded "><a href="../04-desugaring/desugaring.html"><strong aria-hidden="true">4.</strong> Desugaring</a></li><li class="chapter-item expanded "><a href="../05-name-binding/name-binding.html"><strong aria-hidden="true">5.</strong> Name Binding</a></li><li class="chapter-item expanded "><a href="../06-first-order-functions/first-order-functions.html"><strong aria-hidden="true">6.</strong> First-Order Functions</a></li><li class="chapter-item expanded "><a href="../07-higher-order-functions/higher-order-functions.html" class="active"><strong aria-hidden="true">7.</strong> Higher-Order Functions</a></li><li class="chapter-item expanded "><a href="../08-lazy-evaluation/lazy-evaluation.html"><strong aria-hidden="true">8.</strong> Lazy Evaluation</a></li><li class="chapter-item expanded "><a href="../09-recursive-functions/recursive-functions.html"><strong aria-hidden="true">9.</strong> Recursive Functions</a></li><li class="chapter-item expanded "><a href="../10-mutation/mutation.html"><strong aria-hidden="true">10.</strong> Mutation</a></li><li class="chapter-item expanded affix "><li class="part-title">Miscellaneous</li><li class="chapter-item expanded "><a href="../11-garbage-collection/garbage-collection.html"><strong aria-hidden="true">11.</strong> Garbage Collection</a></li><li class="chapter-item expanded "><a href="../12-meta-interpretation/meta-interpretation.html"><strong aria-hidden="true">12.</strong> Syntactic and Meta Interpretation</a></li><li class="chapter-item expanded "><a href="../13-church-encoding/church-encoding.html"><strong aria-hidden="true">13.</strong> Church Encodings</a></li><li class="chapter-item expanded "><a href="../14-object-algebras/object-algebras.html"><strong aria-hidden="true">14.</strong> Object Algebras</a></li><li class="chapter-item expanded affix "><li class="part-title">Continuations</li><li class="chapter-item expanded "><a href="../15-continuations-1/continuations-1.html"><strong aria-hidden="true">15.</strong> Continuations: Motivation</a></li><li class="chapter-item expanded "><a href="../16-continuations-2/continuations-2.html"><strong aria-hidden="true">16.</strong> Continuations: Definition</a></li><li class="chapter-item expanded "><a href="../17-first-class-continuations/first-class-continuations.html"><strong aria-hidden="true">17.</strong> First-Class Continuations</a></li><li class="chapter-item expanded "><a href="../18-letcc/letcc.html"><strong aria-hidden="true">18.</strong> Call-with-current-continuation</a></li><li class="chapter-item expanded "><a href="../19-shift-reset/shift-reset.html"><strong aria-hidden="true">19.</strong> Delimited Continuations</a></li><li class="chapter-item expanded affix "><li class="part-title">Monads</li><li class="chapter-item expanded "><a href="../20-monads-intro/monads-intro.html"><strong aria-hidden="true">20.</strong> Monads Intro</a></li><li class="chapter-item expanded "><a href="../21-io-monad/io-monad.html"><strong aria-hidden="true">21.</strong> The IO Monad</a></li><li class="chapter-item expanded "><a href="../22-modular-interpreters/modular-interpreters.html"><strong aria-hidden="true">22.</strong> Modular Interpreters</a></li><li class="chapter-item expanded "><a href="../23-monadic-reflection/monadic-reflection.html"><strong aria-hidden="true">23.</strong> Monadic Reflection</a></li><li class="chapter-item expanded affix "><li class="part-title">Program Transformations</li><li class="chapter-item expanded "><a href="../24-defunctionalization/defunctionalization.html"><strong aria-hidden="true">24.</strong> Defunctionalization, Refunctionalization</a></li><li class="chapter-item expanded affix "><li class="part-title">Type Systems</li><li class="chapter-item expanded "><a href="../25-type-systems/type-systems.html"><strong aria-hidden="true">25.</strong> Type Systems</a></li><li class="chapter-item expanded "><a href="../26-stlc/stlc.html"><strong aria-hidden="true">26.</strong> Simply Typed Lambda Calculus (STLC)</a></li><li class="chapter-item expanded "><a href="../27-type-inference/type-inference.html"><strong aria-hidden="true">27.</strong> Type Inference</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programming Languages I</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes/blob/master/src/07-higher-order-functions/higher-order-functions.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher-Order Functions</a></h1>
<p>The content of this chapter is available as a Scala file <a href="./higher-order-functions.scala">here.</a></p>
<h1 id="higher-order-functions-1"><a class="header" href="#higher-order-functions-1">Higher-Order Functions</a></h1>
<p>F1WAE, the language with first-order functions, lets us abstract over patterns that involve numbers. But what if we want to abstract
over patterns that involve functions, such as the &quot;list-fold&quot; pattern, whose instantiations include summing or multiplying a list of
integers?</p>
<p>To enable this kind of abstraction, we need to make functions &quot;first-class&quot;, which means that they become values that can be passed to
or returned from functions or stored in data structures. Languages with first-class functions enable so-called &quot;higher-order functions&quot;,
which are functions that accept or return a (possibly again higher-order) function.</p>
<p>We will see that this extension will make our language both simpler and much more powerful. This seeming contradiction is famously
addressed by the first sentence of the Scheme language specification:</p>
<blockquote>
<p>&quot;Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that
make additional features appear necessary.&quot;</p>
</blockquote>
<p>The simplicity is due to the fact that this language is so expressive that many other language features can be &quot;encoded&quot;, i.e., they do
not need to be added to the language but can be expressed with the existing features.</p>
<p>This language, which we call &quot;FAE&quot;, is basically the so-called &quot;lambda calculus&quot;, a minimal but powerful programming language that has
been highly influential in the design and theory of programming languages.</p>
<p>FAE is the language of arithmetic expressions, AE, plus only two additional language constructs: Function abstraction and function application.</p>
<pre><code class="language-scala">object Syntax {
  enum Exp:
    case Num(n: Int)
    case Id(name: String)
    case Add(lhs: Exp, rhs: Exp)

    // Both function definitions and applications are expressions.
    case Fun(param: String, body: Exp)
    case Ap(funExpr: Exp, argExpr: Exp)

  object Exp:
    implicit def num2exp(n: Int): Exp = Num(n)
    implicit def id2exp(s: String): Exp = Id(s)
    // &quot;with&quot; would be a better name for this function, but it is reserved in Scala
    def wth(x: String, xdef: Exp, body: Exp): Exp = Ap(Fun(x, body), xdef)
}

import Syntax._
import Exp._
</code></pre>
<p>Due to the lambda calculus, the concrete syntax for function abstraction is often written
with a lambda, such as <code>lambda x. x + 3</code>, thus also called lambda abstraction. The Scala
syntax for lambda terms is <code>(x) =&gt; x + 3</code>, the Haskell syntax is <code>\x -&gt; x + 3</code>.</p>
<p>The concrete syntax for function application is often either juxtaposition <code>f a</code> or
using brackets <code>f(a)</code>. Haskell and the lambda calculus use the former, Scala uses the
latter.</p>
<p>The <code>with</code> construct is not needed anymore since it can be encoded using <code>Ap</code> and
<code>Fun</code>. For instance, <code>with x = 7 in x + 3</code> can be encoded (using Scala syntax) as
<code>((x) =&gt; x + 3)(7)</code>. We have made this idea explicit above by giving a constructive
translation. Remember that such translations are often called &quot;desugaring&quot;.</p>
<p>As for F1WAE, we will at first define the meaning of FAE in terms of substitution. Here is the substitution function for FAE.</p>
<pre><code class="language-scala">def subst0(e1: Exp, x: String, e2: Exp): Exp = e1 match {
  case Num(n) =&gt; e1
  case Add(l, r) =&gt; Add(subst0(l, x, e2), subst0(r, x, e2))
  case Id(y) =&gt; if (x == y) e2 else Id(y)
  case Ap(f, a) =&gt; Ap(subst0(f, x, e2), subst0(a, x, e2))
  case Fun(param, body) =&gt;
    if (param == x) e1  else Fun(param, subst0(body, x, e2))
}
</code></pre>
<p>Let's try whether <code>subst0</code> produces reasonable results.</p>
<pre><code class="language-scala">assert(subst0(Add(5, &quot;x&quot;), &quot;x&quot;, 7) == Add(5, 7))
assert(subst0(Add(5, &quot;x&quot;), &quot;y&quot;, 7) == Add(5, &quot;x&quot;))
assert(subst0(Fun(&quot;x&quot;, Add(&quot;x&quot;, &quot;y&quot;)), &quot;x&quot;, 7) == Fun(&quot;x&quot;, Add(&quot;x&quot;, &quot;y&quot;)))
</code></pre>
<p>Looks good. However, what happens if <code>e2</code> contains free variables? The danger here is that they may be accidentially &quot;captured&quot; by the substitution.
For instance, consider</p>
<pre><code class="language-scala">val subst0Test = subst0(Fun(&quot;x&quot;, Add(&quot;x&quot;, &quot;y&quot;)), &quot;y&quot;, Add(&quot;x&quot;, 5))
// subst0Test: Exp = Fun(
//   param = &quot;x&quot;,
//   body = Add(
//     lhs = Id(name = &quot;x&quot;),
//     rhs = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 5))
//   )
// )
</code></pre>
<p>The result is <code>Fun(&quot;x&quot;, Add(&quot;x&quot;, Add(&quot;x&quot;, 5)))</code>
This is not desirable, since it again violates static scoping.</p>
<p>Note that this problem did not show up in earlier languages, because there we only substituted variables by numbers, but not by
expressions that may contain free variables: The type of <code>e2</code> was <code>Num</code> and not <code>Exp</code>.</p>
<p>Hence we are still not done with defining substitution. But what is the desired result of the substitution above?
The answer is that we must avoid the name clash by renaming the variable bound by the &quot;lambda&quot; if the variable name occurs free in <code>e2</code>.
This new variable name should be &quot;fresh&quot;, i.e., not occur free in <code>e2</code>.</p>
<p>For instance, in the example above, we could first rename <code>&quot;x&quot;</code> to the fresh name <code>&quot;x0&quot;</code> and only then substitute, i.e.</p>
<p><code>subst(Fun(&quot;x&quot;, Add(&quot;x&quot;, &quot;y&quot;)), &quot;y&quot;, Add(&quot;x&quot;, 5)) == Fun(&quot;x0&quot;, Add(&quot;x0&quot;, Add(&quot;x&quot;, Num(5))))</code></p>
<p>Let's do this step by step.</p>
<pre><code class="language-scala">def freshName(names: Set[String], default: String): String = {
  var last: Int = 0
  var freshName = default
  while (names contains freshName) { freshName = default + last; last += 1; }
  freshName
}

val freshNameExa1 = freshName(Set(&quot;y&quot;, &quot;z&quot;), &quot;x&quot;)
// freshNameExa1: String = &quot;x&quot;
val freshNameExa2 = freshName(Set(&quot;x2&quot;, &quot;x0&quot;, &quot;x4&quot;, &quot;x&quot;, &quot;x1&quot;), &quot;x&quot;)
// freshNameExa2: String = &quot;x3&quot;
assert(freshNameExa1 == &quot;x&quot;)
assert(freshNameExa2 == &quot;x3&quot;)

def freeVars(e: Exp): Set[String] =  e match {
   case Id(x) =&gt; Set(x)
   case Add(l, r) =&gt; freeVars(l) ++ freeVars(r)
   case Fun(x, body) =&gt; freeVars(body) - x
   case Ap(f, a) =&gt; freeVars(f) ++ freeVars(a)
   case Num(n) =&gt; Set.empty
}

val freeVarsExa = freeVars(Fun(&quot;x&quot;, Add(&quot;x&quot;, &quot;y&quot;)))
// freeVarsExa: Set[String] = Set(&quot;y&quot;)
assert(freeVarsExa == Set(&quot;y&quot;))

def subst(e1: Exp, x: String, e2: Exp): Exp = e1 match {
  case Num(n) =&gt; e1
  case Add(l, r) =&gt; Add(subst(l, x, e2), subst(r, x, e2))
  case Id(y) =&gt; if (x == y) e2 else Id(y)
  case Ap(f, a) =&gt; Ap(subst(f, x, e2), subst(a, x, e2))
  case Fun(param, body) =&gt;
    if (param == x) e1 else {
      val fvs = freeVars(Fun(param, body)) ++ freeVars(e2) + x
      val newvar = freshName(fvs, param)
      Fun(newvar, subst(subst(body, param, Id(newvar)), x, e2))
    }
}

assert(subst(Add(5, &quot;x&quot;), &quot;x&quot;, 7) == Add(5, 7))
assert(subst(Add(5, &quot;x&quot;), &quot;y&quot;, 7) == Add(5, &quot;x&quot;))
assert(subst(Fun(&quot;x&quot;, Add(&quot;x&quot;, &quot;y&quot;)), &quot;x&quot;, 7) == Fun(&quot;x&quot;, Add(&quot;x&quot;, &quot;y&quot;)))
// test capture-avoiding substitution
assert(subst(Fun(&quot;x&quot;, Add(&quot;x&quot;, &quot;y&quot;)), &quot;y&quot;, Add(&quot;x&quot;, 5)) == Fun(&quot;x0&quot;, Add(&quot;x0&quot;, Add(&quot;x&quot;, Num(5)))))
assert(subst(Fun(&quot;x&quot;, Add(&quot;x0&quot;, &quot;y&quot;)), &quot;y&quot;, Add(&quot;x&quot;, 5)) == Fun(&quot;x1&quot;, Add(&quot;x0&quot;, Add(&quot;x&quot;, Num(5)))))
</code></pre>
<p>OK, equipped with this new version of substitution we can now define the interpreter for this language.
But how do we evaluate a function abstraction? Obviously we cannot return a number.</p>
<p>We realize that functions are also values! Hence we have to broaden the return type of our evaluator to also allow functions as values.
For simplicity, we use <code>Exp</code> as our return type since it allows us to return both numbers and functions. Later we will become more
sophisticated.</p>
<p>This means that a new class of errors can occur: A subexpression evaluates to a number where a function is expected, or vice versa.
Such errors are called <em>type errors</em>, and we will talk about them in much more detail later.</p>
<p>For now, it means that we need to analyze (typically by pattern matching) the result of recursive invocations of <code>eval</code> to check whether the result has the right type.</p>
<p>The remainder of the interpreter is unsurprising:</p>
<pre><code class="language-scala">def eval(e: Exp): Exp = e match {
  case Id(v) =&gt; sys.error(&quot;unbound identifier: &quot; + v)
  case Add(l, r) =&gt; (eval(l), eval(r)) match {
                      case (Num(x), Num(y)) =&gt; Num(x + y)
                      case _ =&gt; sys.error(&quot;can only add numbers&quot;)
                    }
  case Ap(f, a) =&gt; eval(f) match {
    case Fun(x, body) =&gt; eval(subst(body, x, eval(a)))  // call-by-value
    //case Fun(x, body) =&gt; eval(subst(body, x, a))        // call-by-name
    case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  }
  case _ =&gt; e // numbers and functions evaluate to themselves
}
</code></pre>
<p>We can also make the return type more precise to verify the invariant  that numbers and functions are the only values.</p>
<pre><code class="language-scala">def eval2(e: Exp): Either[Num, Fun] = e match {
  case Id(v) =&gt; sys.error(&quot;unbound identifier: &quot; + v)
  case Add(l, r) =&gt; (eval2(l), eval2(r)) match {
                      case (Left(Num(x)), Left(Num(y))) =&gt; Left(Num(x + y))
                      case _ =&gt; sys.error(&quot;can only add numbers&quot;)
                    }
  case Ap(f, a) =&gt; eval2(f) match {
    case Right(Fun(x, body)) =&gt; eval2(subst(body, x, eval(a)))
    case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  }
  case f@Fun(_, _) =&gt; Right(f)
  case n@Num(_) =&gt; Left(n)
}
</code></pre>
<p>Let's test:</p>
<pre><code class="language-scala">val test = Ap(Fun(&quot;x&quot;, Add(&quot;x&quot;, 5)), 7)
assert(eval(test) == Num(12))
</code></pre>
<p>FAE is a computationally (Turing-)complete language. For instance, we can define  a non-terminating program. This program is commonly
called Omega:</p>
<pre><code class="language-scala">val omega = Ap(Fun(&quot;x&quot;, Ap(&quot;x&quot;, &quot;x&quot;)), Fun(&quot;x&quot;, Ap(&quot;x&quot;, &quot;x&quot;)))
// try eval(omega) to crash the interpreter ;-)
</code></pre>
<p>Omega can be extended to yield a fixed-point combinator, which can be used to encode arbitrary recursive functions. We'll come back to
this topic later.</p>
<p>Let's now discuss what an environment-based version of this interpreter looks like.
Here is a first attempt:</p>
<pre><code class="language-scala">type Env0 = Map[String, Exp]

def evalWithEnv0(e: Exp, env: Env0): Exp = e match {
  case Id(x) =&gt; env(x)
  case Add(l, r) =&gt; {
    (evalWithEnv0(l, env), evalWithEnv0(r, env)) match {
      case (Num(v1), Num(v2)) =&gt; Num(v1 + v2)
      case _ =&gt; sys.error(&quot;can only add numbers&quot;)
    }
  }
  case Ap(f, a) =&gt; evalWithEnv0(f, env) match {
    case Fun(x, body) =&gt; evalWithEnv0(body, Map(x -&gt; evalWithEnv0(a, env)))
    case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  }
  case _ =&gt; e // numbers and functions evaluate to themselves
}

assert(evalWithEnv0(test, Map.empty) == Num(12))
</code></pre>
<p>However, consider the following example:</p>
<pre><code class="language-scala">val test2 = wth(&quot;x&quot;, 5, Ap(Fun(&quot;f&quot;, Ap(&quot;f&quot;, 3)), Fun(&quot;y&quot;, Add(&quot;x&quot;, &quot;y&quot;))))
</code></pre>
<p>It works fine in the substitution-based interpreter,</p>
<pre><code class="language-scala">val evalTest2 = eval(test2)
// evalTest2: Exp = Num(n = 8)
assert(evalTest2 == Num(8))
</code></pre>
<p>but</p>
<pre><code class="language-scala">val evalEnv0Test2 = evalWithEnv0(test2, Map.empty)
// java.util.NoSuchElementException: key not found: x
// 	at scala.collection.immutable.Map$Map1.apply(Map.scala:243)
// 	at repl.MdocSession$MdocApp.evalWithEnv0(higher-order-functions.md:208)
// 	at repl.MdocSession$MdocApp.evalWithEnv0(higher-order-functions.md:210)
// 	at repl.MdocSession$MdocApp.evalWithEnv0(higher-order-functions.md:216)
// 	at repl.MdocSession$MdocApp.evalWithEnv0(higher-order-functions.md:216)
// 	at repl.MdocSession$MdocApp.evalWithEnv0(higher-order-functions.md:216)
// 	at repl.MdocSession$MdocApp.$init$$$anonfun$1(higher-order-functions.md:248)
// 	at repl.MdocSession$MdocApp.$init$$$anonfun$adapted$1(higher-order-functions.md:249)
</code></pre>
<p>yields a <code>key not found: x</code> error.
The problem is that we have forgotten the deferred substitutions to be performed in the body of the function.</p>
<p>What can we do to fix this problem?
We could try to replace the second line in the <code>Ap</code> case by</p>
<pre><code>case Fun(x, body) =&gt; evalWithEnv0(body, env + (x -&gt; evalWithEnv0(a, env)))
</code></pre>
<p>but this would again introduce dynamic scoping.</p>
<p>Hence, when we evaluate a function, we do not only have to store the function, but also the environment active when the function was
created. This pair of function and environment is called a <em>closure</em>. The environment stored in the closure is used when the function
is eventually applied.</p>
<p>Hint: If you cannot answer what a closure is and how it is used in the  interpreter, you will be toast in the exam!</p>
<p>Since closures are not expressible in the language syntax, we now come to the point where we need a separate category of <em>values</em>.
The values in FAE can be either numbers or closures.</p>
<pre><code class="language-scala">sealed abstract class Value
type Env = Map[String, Value]
case class NumV(n: Int) extends Value
case class ClosureV(f: Fun, env: Env) extends Value
</code></pre>
<p>The evaluator becomes:</p>
<pre><code class="language-scala">def evalWithEnv(e: Exp, env: Env): Value = e match {
  case Num(n: Int) =&gt; NumV(n)
  case Id(x) =&gt; env(x)
  case Add(l, r) =&gt; {
    (evalWithEnv(l, env), evalWithEnv(r, env)) match {
      case (NumV(v1), NumV(v2)) =&gt; NumV(v1 + v2)
      case _ =&gt; sys.error(&quot;can only add numbers&quot;)
    }
  }
  case f@Fun(param, body) =&gt; ClosureV(f, env)
  case Ap(f, a) =&gt; evalWithEnv(f, env) match {
    // Use environment stored in closure to realize proper lexical scoping!
    case ClosureV(f, closureEnv) =&gt; evalWithEnv(f.body, closureEnv + (f.param -&gt; evalWithEnv(a, env)))
    case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  }
}
assert(evalWithEnv(test, Map.empty) == NumV(12))
assert(evalWithEnv(test2, Map.empty) == NumV(8))
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../06-first-order-functions/first-order-functions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../08-lazy-evaluation/lazy-evaluation.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../06-first-order-functions/first-order-functions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../08-lazy-evaluation/lazy-evaluation.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../questionnaire.js"></script>
    </body>
</html>
