<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Name Binding (WAE) - Programming Languages I</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Lecture notes for the Programming Languages I lecture at the University of Tübingen">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded affix "><li class="part-title">Introduction</li><li class="chapter-item expanded "><a href="../01-intro/intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../02-scala-basics/scala-basics.html"><strong aria-hidden="true">2.</strong> Scala Basics</a></li><li class="chapter-item expanded affix "><li class="part-title">Arithmetic Expressions</li><li class="chapter-item expanded "><a href="../03-arithmetic-expressions/arithmetic-expressions.html"><strong aria-hidden="true">3.</strong> Arithmetic Expressions (AE)</a></li><li class="chapter-item expanded "><a href="../04-desugaring/desugaring.html"><strong aria-hidden="true">4.</strong> Desugaring</a></li><li class="chapter-item expanded "><a href="../05-name-binding/name-binding.html" class="active"><strong aria-hidden="true">5.</strong> Name Binding (WAE)</a></li><li class="chapter-item expanded "><a href="../06-first-order-functions/first-order-functions.html"><strong aria-hidden="true">6.</strong> First Order Functions (F1WAE)</a></li><li class="chapter-item expanded "><a href="../07-higher-order-functions/higher-order-functions.html"><strong aria-hidden="true">7.</strong> Higher Order Functions (FAE)</a></li><li class="chapter-item expanded "><a href="../08-lazy-evaluation/lazy-evaluation.html"><strong aria-hidden="true">8.</strong> Lazy Evaluation (LCFAE)</a></li><li class="chapter-item expanded "><a href="../09-recursive-functions/recursive-functions.html"><strong aria-hidden="true">9.</strong> Recursive Functions (RCFAE)</a></li><li class="chapter-item expanded "><a href="../10-mutation/mutation.html"><strong aria-hidden="true">10.</strong> Mutation (BCFAE)</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Topics 1</li><li class="chapter-item expanded "><a href="../11-garbage-collection/garbage-collection.html"><strong aria-hidden="true">11.</strong> Garbage Collection</a></li><li class="chapter-item expanded "><a href="../12-meta-interpretation/meta-interpretation.html"><strong aria-hidden="true">12.</strong> Syntactic and Meta Interpretation</a></li><li class="chapter-item expanded "><a href="../13-church-encoding/church-encoding.html"><strong aria-hidden="true">13.</strong> Church Encodings</a></li><li class="chapter-item expanded "><a href="../14-object-algebras/object-algebras.html"><strong aria-hidden="true">14.</strong> Object Algebras</a></li><li class="chapter-item expanded affix "><li class="part-title">Continuations</li><li class="chapter-item expanded "><a href="../15-continuations-1/continuations-1.html"><strong aria-hidden="true">15.</strong> Continuations 1</a></li><li class="chapter-item expanded "><a href="../16-continuations-2/continuations-2.html"><strong aria-hidden="true">16.</strong> Continuations 2</a></li><li class="chapter-item expanded "><a href="../17-first-class-continuations/first-class-continuations.html"><strong aria-hidden="true">17.</strong> First Class Continuations</a></li><li class="chapter-item expanded "><a href="../18-letcc/letcc.html"><strong aria-hidden="true">18.</strong> LetCC</a></li><li class="chapter-item expanded "><a href="../19-shift-reset/shift-reset.html"><strong aria-hidden="true">19.</strong> ShiftReset</a></li><li class="chapter-item expanded affix "><li class="part-title">Monads</li><li class="chapter-item expanded "><a href="../20-monads-intro/monads-intro.html"><strong aria-hidden="true">20.</strong> Monads Intro</a></li><li class="chapter-item expanded "><a href="../21-io-monad/io-monad.html"><strong aria-hidden="true">21.</strong> IO Monad</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Topics 2</li><li class="chapter-item expanded "><a href="../22-modular-interpreters/modular-interpreters.html"><strong aria-hidden="true">22.</strong> Modular Interpreters</a></li><li class="chapter-item expanded "><a href="../23-monadic-reflection/monadic-reflection.html"><strong aria-hidden="true">23.</strong> Monadic Reflection</a></li><li class="chapter-item expanded "><a href="../24-defunctionalization/defunctionalization.html"><strong aria-hidden="true">24.</strong> Defunctionalization</a></li><li class="chapter-item expanded affix "><li class="part-title">Type Systems</li><li class="chapter-item expanded "><a href="../25-type-systems/type-systems.html"><strong aria-hidden="true">25.</strong> Type Systems</a></li><li class="chapter-item expanded "><a href="../26-stlc/stlc.html"><strong aria-hidden="true">26.</strong> Simply Typed Lambda Calculus (STLC)</a></li><li class="chapter-item expanded "><a href="../27-type-inference/type-inference.html"><strong aria-hidden="true">27.</strong> Type Inference</a></li><li class="chapter-item expanded affix "><a href="../furtherreading.html">Further Reading</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programming Languages I</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes/blob/master/out/05-name-binding/name-binding.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="name-binding"><a class="header" href="#name-binding">Name Binding</a></h1>
<p>The content of this chapter is available as a Scala file <a href="./name-binding.scala">here.</a></p>
<pre><code class="language-scala">import scala.language.implicitConversions
</code></pre>
<h2 id="name-binding-1"><a class="header" href="#name-binding-1">Name Binding</a></h2>
<p>We want, step by step, to develop our primitive calculator language into a full-fledged PL.
One important milestone on this way is the ability to deal with names. While our previous language allowed expressions with identifiers
in them, it had no <em>binders</em>: Constructs that allow to give meaning to a new name.
In this variant of the language, called WAE, we introduce such a binder called &quot;with&quot; with which we can give an expression a name that
can be used in the body of the &quot;with&quot; expression. This intuition is captured in the  definition of the <code>With</code> case class below,
which extends our previous  language.
We study this WAE language to better understand what names mean in  programming languages, and how they can be implemented.</p>
<pre><code class="language-scala">object Syntax {
  sealed abstract class Exp
  case class Num(n: Int) extends Exp
  case class Add(lhs: Exp, rhs: Exp) extends Exp
  case class Mul(lhs: Exp, rhs: Exp) extends Exp
  case class Id(x: String) extends Exp
  case class With(x: String, xdef: Exp, body: Exp) extends Exp
}
import Syntax._
</code></pre>
<p>We use implicits again to make example programs less verbose.</p>
<pre><code class="language-scala">implicit def num2exp(n: Int): Exp = Num(n)
implicit def string2exp(x: String): Exp = Id(x)
</code></pre>
<p>A first example program in WAE.</p>
<pre><code class="language-scala">val test = With(&quot;x&quot;, 5, Add(&quot;x&quot;,&quot;x&quot;))
</code></pre>
<p>Note that we deal with <em>two</em> languages here:</p>
<ol>
<li>This Scala file with Scala code.</li>
<li>Most of the functions work on programs written in the WAE language.</li>
</ol>
<p>Most of the time, we concentrate on WAE, but sometimes, we also talk about Scala.
We have not defined a concrete syntax for WAE, but it is a real language nevertheless. We sometimes use some made-up syntax for examples
on the blackboard or in comments.</p>
<h2 id="substitution"><a class="header" href="#substitution">Substitution</a></h2>
<p>Instead of dealing with identifiers as external entities as in AE, identifiers can now be defined within the language. This justifies a
new treatment of identifiers. We will explain them in terms of <em>substitution</em>, a notion well-known informally from high school algebra.
The idea is the following: The interpreter transforms the term</p>
<pre><code>  with (x = 5) {
    x + x
  }
</code></pre>
<p>into</p>
<pre><code>  5 + 5
</code></pre>
<p>before proceeding. That is, all occurrences of <code>x</code> have been replaced by <code>5</code>.
Note that these two programs -- before and after the substitution -- are certainly not <em>equal</em>: They look quite different. However,
they are <em>equivalent</em> in the sense that when evaluated, they will produce the same number. Such transformations between different but
somehow equivalent programs are an important tool for the study of programs, and of programming languages. Often, if we know which
programs behave identically, we understand better how programs behave in general. We will see more examples of this in this lecture.
Hence, the implementation of the <code>With</code> case of our interpreter should be something like:</p>
<pre><code>case With(x, xdef, body) =&gt; eval(subst(body,x,Num(eval(xdef))))
</code></pre>
<p>for a function <code>subst</code> with signature</p>
<pre><code>subst: (Exp,String,Num) =&gt; Exp
</code></pre>
<p>The type of the third parameter is <code>Num</code> instead of <code>Exp</code> because it is more difficult to get substitution correct when arbitrary
expressions can be inserted (accidential name capture problem, more about that later).
Since we want to experiment with different versions of substitution, we write the interpreter in such a way that we can parameterize
it with a substitution function:</p>
<pre><code class="language-scala">def makeEval(subst: (Exp,String,Num)=&gt;Exp) : Exp=&gt;Int = {
  def eval(e: Exp) : Int = e match {
    case Num(n) =&gt; n
    case Id(x) =&gt; sys.error(&quot;unbound variable: &quot; + x)
    case Add(l,r) =&gt; eval(l) + eval(r)
    case Mul(l,r) =&gt; eval(l) * eval(r)
    case With(x, xdef, body) =&gt; eval(subst(body,x,Num(eval(xdef)))) // take the int and wrap it into a Num
  }
  eval
}
</code></pre>
<h3 id="substitution-take-1"><a class="header" href="#substitution-take-1">Substitution, take 1</a></h3>
<p>To substitute identifier <code>i</code> in <code>e</code> with expression <code>v</code>, replace all identifiers in <code>e</code> that have the name <code>i</code> with the expression <code>v</code>.
Let's try to formalize this definition:</p>
<pre><code class="language-scala">val subst1 : (Exp,String,Num) =&gt; Exp = (e,i,v) =&gt; e match {
  case Num(n) =&gt; e
  case Id(x) =&gt; if (x == i) v else e
  case Add(l,r) =&gt; Add( subst1(l,i,v), subst1(r,i,v))
  case Mul(l,r) =&gt; Mul( subst1(l,i,v), subst1(r,i,v))
  case With(x,xdef,body) =&gt; With( if (x == i) v else x,
                                    subst1(xdef,i,v),
                                    subst1(body,i,v))
  }
// error:
// Found:    (v : repl.MdocSession.App.Syntax.Num)
// Required: String
//     case Id(x) =&gt; if (x == i) v else e
//                               ^
</code></pre>
<p>Unfortunately this does not even type-check! And rightly so, because it might otherwise turn reasonable programs into programs that are
not even syntactically legal anymore.
Exercise for self-study: Find an expression that would be transformed into one that is not syntactically legal.
To see the reason for this, we need to define some terminology (the word &quot;instance&quot; here means &quot;occurence&quot;):</p>
<p><strong>Definition (Binding Instance)</strong>:
A binding instance of an identifier is the instance of the identifier that gives it its value. In WAE, the <code>x</code> position of a <code>With</code> is the only binding instance.</p>
<p><strong>Definition (Scope)</strong>:
The scope of a binding instance is the region of program text in which instances of the identifier refer to the value bound by the binding instance.</p>
<p><strong>Definition (Bound Instance)</strong>:
An identifier is bound if it is contained within the scope of a binding instance of its name.</p>
<p><strong>Definition (Free Instance)</strong>:
An identifier not contained in the scope of any binding instance of its name is said to be free.
Examples: In WAE, the String in <code>Id(&quot;x&quot;)</code> is a bound or free instance, and the String in <code>With(&quot;x&quot;, ..., ...)</code> is a binding instance.
The scope of this binding instance is the third sub-term of <code>With</code>.</p>
<p>Now the reason can be revealed.  Our first attempt failed because we substituted the identifier occurring in the binding position in the
with-expression.  This renders the expression illegal because after substitution the binding position where an identifier was expected
is now occupied by a Num.
To correct this mistake, we make another take at substitution:</p>
<h3 id="substitution-take-2"><a class="header" href="#substitution-take-2">Substitution, take 2</a></h3>
<p>To substitute identifier <code>i</code> in <code>e</code> with expression <code>v</code>, replace all identifiers in <code>e</code> which are not binding
instances that have the name <code>i</code> with the expression <code>v</code>.
Here is the formalization of this definition.</p>
<pre><code class="language-scala">val subst2 : (Exp,String,Num) =&gt; Exp = (e,i,v) =&gt; e match {
  case Num(n) =&gt; e

  // Bound or free instance =&gt; substitute if names match
  case Id(x) =&gt; if (x == i) v else e

  case Add(l,r) =&gt; Add( subst2(l,i,v), subst2(r,i,v))
  case Mul(l,r) =&gt; Mul( subst2(l,i,v), subst2(r,i,v))

  // binding instance =&gt; do not substitute
  case With(x,xdef,body) =&gt; With( x,
                                  subst2(xdef,i,v),
                                  subst2(body,i,v))
}
</code></pre>
<p>Let's create an interpreter that uses this substitution function.</p>
<pre><code class="language-scala">def eval2 = makeEval(subst2)

assert(eval2(test) == 10) // it works!

val test2 = With(&quot;x&quot;, 5, Add(&quot;x&quot;, With(&quot;x&quot;, 3, 10))) // another test

assert(eval2(test2) == 15) // works as expected

val test3 = With(&quot;x&quot;, 5, Add(&quot;x&quot;, With(&quot;x&quot;, 3, &quot;x&quot;))) // another test

// assert(eval2(test3) == 8) // Bang! Result is 10 instead!
</code></pre>
<p>What went wrong here? Our substitution algorithm respected binding instances, but not their scope. In the sample expression, the <code>With</code>
introduces a new scope for the inner <code>x</code>. The scope of the outer <code>x</code> is shadowed or masked by the inner binding. Because substitution
doesn’t recognize this possibility, it incorrectly substitutes the inner <code>x</code>.</p>
<h3 id="substitution-take-3"><a class="header" href="#substitution-take-3">Substitution, take 3</a></h3>
<p>To substitute identifier <code>i</code> in <code>e</code> with expression <code>v</code>, replace all non-binding identifiers in <code>e</code> having
the name <code>i</code> with the expression <code>v</code>, unless the identifier is in a scope different from that introduced by <code>i</code>.</p>
<pre><code class="language-scala">val subst3 : (Exp,String,Num) =&gt; Exp = (e,i,v) =&gt; e match {
    case Num(n) =&gt; e
    case Id(x) =&gt; if (x == i) v else e
    case Add(l,r) =&gt; Add( subst3(l,i,v), subst3(r,i,v))
    case Mul(l,r) =&gt; Mul( subst3(l,i,v), subst3(r,i,v))
    case With(x,xdef,body) =&gt; With( x,
                                    subst3(xdef,i,v),
                                    // what if we forget to substitute into the body?
                                    body)
}

def eval3 = makeEval(subst3)

assert(eval3(test) == 10)

assert(eval3(test2) == 15)

assert(eval3(test3) == 8) // Success!

val test4 = With(&quot;x&quot;, 5, Add(&quot;x&quot;, With(&quot;y&quot;, 3,&quot;x&quot;)))

// assert(eval3(test4) == 10) // Bang! unbound variable: &quot;x&quot;
</code></pre>
<p>The inner expression should result in an error, because <code>x</code> has no value. Once again, substitution has changed a correct program into
an incorrect one!
Let’s understand what went wrong. Why didn’t we substitute the inner <code>x</code>? Substitution halts at the <code>With</code> because, by definition, every
<code>With</code> introduces a new scope, which we said should delimit substitution. But this <code>With</code> contains an instance of <code>x</code>, which we very much
want substituted! So which is it - substitute within nested scopes or not? Actually, the two examples above should reveal that our
latest definition for substitution, which may have seemed sensible at first blush, is too draconian: it rules out substitution within
any nested scopes.</p>
<h3 id="substitution-take-4"><a class="header" href="#substitution-take-4">Substitution, take 4</a></h3>
<p>To substitute identifier <code>i</code> in <code>e</code> with expression <code>v</code>, replace all non-binding identifiers in <code>e</code> having
the name <code>i</code> with the expression <code>v</code>, except within nested scopes of <code>i</code>.
Finally, we have a version of substitution that works. A different, more succinct way of phrasing this definition is:
&quot;To substitute identifier <code>i</code> in <code>e</code> with expression <code>v</code>, replace all free instances of <code>i</code> in <code>e</code> with <code>v</code>.&quot;</p>
<pre><code class="language-scala">val subst4 : (Exp,String,Num) =&gt; Exp = (e,i,v) =&gt; e match {
    case Num(n) =&gt; e
    case Id(x) =&gt; if (x == i) v else e
    case Add(l,r) =&gt; Add( subst4(l,i,v), subst4(r,i,v))
    case Mul(l,r) =&gt; Mul( subst4(l,i,v), subst4(r,i,v))
    // do not substitute when shadowed
    case With(x,xdef,body) =&gt; if (x == i) e
                                 else With(x,
                                           subst4(xdef,i,v),
                                           subst4(body,i,v))
}

def eval4 = makeEval(subst4)

assert(eval4(test) == 10)

assert(eval4(test2) == 15)

assert(eval4(test3) == 8)

assert(eval4(test4) == 10) // Success!

val test5 = With(&quot;x&quot;, 5, With(&quot;x&quot;, &quot;x&quot;, &quot;x&quot;))

// assert(eval4(test5) == 5) // Bang! unbound variable &quot;x&quot;
</code></pre>
<p>This program should evaluate to <code>5</code>, but it too halts with an error. This is because we prematurely stopped substituting for <code>x</code> occuring in
a bound position. We should substitute in the named expression of a <code>With</code> even if the with in question defines a new scope for the identifier
being substituted, because its named expression is still in the scope of the enclosing binding of the identifier.</p>
<h3 id="substitution-take-5"><a class="header" href="#substitution-take-5">Substitution, take 5</a></h3>
<p>We finally get a valid
programmatic definition of substitution (relative to the language we have so far):</p>
<pre><code class="language-scala">val subst5 : (Exp,String,Num) =&gt; Exp = (e,i,v) =&gt; e match {
    case Num(n) =&gt; e
    case Id(x) =&gt; if (x == i) v else e
    case Add(l,r) =&gt; Add( subst5(l,i,v), subst5(r,i,v))
    case Mul(l,r) =&gt; Mul( subst5(l,i,v), subst5(r,i,v))
    // handle shadowing correctly
    case With(x,xdef,body) =&gt; With(x,
                                   subst5(xdef,i,v),
                                   if (x == i) body else subst5(body,i,v))
}

def eval5 = makeEval(subst5)

assert(eval5(test) == 10)

assert(eval5(test2) == 15)

assert(eval5(test3) == 8)

assert(eval5(test4) == 10)

assert(eval5(test5) == 5) // Success!
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ol>
<li>Substitution can be used to understand the meaning of names in programming languages.</li>
<li>Correct implementations of substitution need to handle free, bound, and binding instances of names and their scopes correctly.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../04-desugaring/desugaring.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../06-first-order-functions/first-order-functions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../04-desugaring/desugaring.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../06-first-order-functions/first-order-functions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../questionnaire.js"></script>
    </body>
</html>
