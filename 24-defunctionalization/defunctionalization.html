<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Defunctionalization, Refunctionalization - Programming Languages I</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Lecture notes for the Programming Languages I lecture at the University of TÃ¼bingen">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded affix "><li class="part-title">Introduction</li><li class="chapter-item expanded "><a href="../01-intro/intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../02-scala-basics/scala-basics.html"><strong aria-hidden="true">2.</strong> Scala Basics</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic Language Features</li><li class="chapter-item expanded "><a href="../03-arithmetic-expressions/arithmetic-expressions.html"><strong aria-hidden="true">3.</strong> Arithmetic Expressions</a></li><li class="chapter-item expanded "><a href="../04-desugaring/desugaring.html"><strong aria-hidden="true">4.</strong> Desugaring</a></li><li class="chapter-item expanded "><a href="../05-name-binding/name-binding.html"><strong aria-hidden="true">5.</strong> Name Binding</a></li><li class="chapter-item expanded "><a href="../06-first-order-functions/first-order-functions.html"><strong aria-hidden="true">6.</strong> First-Order Functions</a></li><li class="chapter-item expanded "><a href="../07-higher-order-functions/higher-order-functions.html"><strong aria-hidden="true">7.</strong> Higher-Order Functions</a></li><li class="chapter-item expanded "><a href="../08-lazy-evaluation/lazy-evaluation.html"><strong aria-hidden="true">8.</strong> Lazy Evaluation</a></li><li class="chapter-item expanded "><a href="../09-recursive-functions/recursive-functions.html"><strong aria-hidden="true">9.</strong> Recursive Functions</a></li><li class="chapter-item expanded "><a href="../10-mutation/mutation.html"><strong aria-hidden="true">10.</strong> Mutation</a></li><li class="chapter-item expanded affix "><li class="part-title">Miscellaneous</li><li class="chapter-item expanded "><a href="../11-garbage-collection/garbage-collection.html"><strong aria-hidden="true">11.</strong> Garbage Collection</a></li><li class="chapter-item expanded "><a href="../12-meta-interpretation/meta-interpretation.html"><strong aria-hidden="true">12.</strong> Syntactic and Meta-Interpretation</a></li><li class="chapter-item expanded "><a href="../13-church-encoding/church-encoding.html"><strong aria-hidden="true">13.</strong> Church Encodings</a></li><li class="chapter-item expanded "><a href="../14-object-algebras/object-algebras.html"><strong aria-hidden="true">14.</strong> Object Algebras</a></li><li class="chapter-item expanded affix "><li class="part-title">Continuations</li><li class="chapter-item expanded "><a href="../15-continuations-1/continuations-1.html"><strong aria-hidden="true">15.</strong> Continuations: Motivation</a></li><li class="chapter-item expanded "><a href="../16-continuations-2/continuations-2.html"><strong aria-hidden="true">16.</strong> Continuations: Definition</a></li><li class="chapter-item expanded "><a href="../17-first-class-continuations/first-class-continuations.html"><strong aria-hidden="true">17.</strong> First-Class Continuations</a></li><li class="chapter-item expanded "><a href="../18-letcc/letcc.html"><strong aria-hidden="true">18.</strong> Call-with-current-continuation</a></li><li class="chapter-item expanded "><a href="../19-shift-reset/shift-reset.html"><strong aria-hidden="true">19.</strong> Delimited Continuations</a></li><li class="chapter-item expanded affix "><li class="part-title">Monads</li><li class="chapter-item expanded "><a href="../20-monads-intro/monads-intro.html"><strong aria-hidden="true">20.</strong> Monads Intro</a></li><li class="chapter-item expanded "><a href="../21-io-monad/io-monad.html"><strong aria-hidden="true">21.</strong> The IO Monad</a></li><li class="chapter-item expanded "><a href="../22-modular-interpreters/modular-interpreters.html"><strong aria-hidden="true">22.</strong> Modular Interpreters</a></li><li class="chapter-item expanded "><a href="../23-monadic-reflection/monadic-reflection.html"><strong aria-hidden="true">23.</strong> Monadic Reflection</a></li><li class="chapter-item expanded affix "><li class="part-title">Program Transformations</li><li class="chapter-item expanded "><a href="../24-defunctionalization/defunctionalization.html" class="active"><strong aria-hidden="true">24.</strong> Defunctionalization, Refunctionalization</a></li><li class="chapter-item expanded affix "><li class="part-title">Type Systems</li><li class="chapter-item expanded "><a href="../25-type-systems/type-systems.html"><strong aria-hidden="true">25.</strong> Type Systems</a></li><li class="chapter-item expanded "><a href="../26-stlc/stlc.html"><strong aria-hidden="true">26.</strong> Simply Typed Lambda Calculus (STLC)</a></li><li class="chapter-item expanded "><a href="../27-type-inference/type-inference.html"><strong aria-hidden="true">27.</strong> Type Inference</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programming Languages I</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes/blob/master/src/24-defunctionalization/defunctionalization.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="defunctionalization-refunctionalization"><a class="header" href="#defunctionalization-refunctionalization">Defunctionalization, Refunctionalization</a></h1>
<p>The content of this chapter is available as a Scala file <a href="./defunctionalization.scala">here.</a></p>
<p>In the discussion of syntactic interpretation vs. meta interpretation we have learned that we only learn something about (and control)
a language feature if we choose syntactic interpretation.</p>
<p>Today we want to discuss techniques with which we can make our interpreter so syntactic that it corresponds to an abstract machine:
A machine with a (possibly infinite) set of states and a simple transition relation between the states. We already know the technique
with which we can take control over the call stack management: <em>CPS transformation</em>. After CPS-transforming the interpreter, we do not
rely on the order of evaluation and call stack management of the meta-language anymore. We replicate its definition here:</p>
<pre><code class="language-scala">enum Exp:
  case Num(n: Int)
  case Id(name: String)
  case Add(lhs: Exp, rhs: Exp)
  case Fun(param: String, body: Exp)
  case Ap(funExpr: Exp, argExpr: Exp)

object Exp:
  implicit def num2exp(n: Int): Exp = Num(n)
  implicit def id2exp(s: String): Exp = Id(s)

import Exp._

sealed abstract class Value
type Env = Map[String, Value]
case class NumV(n: Int) extends Value
case class ClosureV(f: Fun, env: Env) extends Value

object CPSTransformed {
  def eval[T](e: Exp, env: Env, k: Value =&gt; T): T = e match {
    case Num(n: Int) =&gt; k(NumV(n))
    case Id(x) =&gt; k(env(x))
    case Add(l, r) =&gt;
      eval(l, env,
           lv =&gt; eval(r, env,
                      rv =&gt; (lv, rv) match {
                          case (NumV(v1), NumV(v2)) =&gt; k(NumV(v1 + v2))
                          case _ =&gt; sys.error(&quot;can only add numbers&quot;)
                        }))
    case f@Fun(param, body) =&gt; k(ClosureV(f, env))
    case Ap(f, a) =&gt;
      eval(f, env,
           cl =&gt; cl match {
              case ClosureV(f, closureEnv) =&gt;
                eval(a, env,
                     av =&gt; eval(f.body, closureEnv + (f.param -&gt; av), k))
              case _ =&gt; sys.error(&quot;can only apply functions&quot;)
            })
  }
}
</code></pre>
<p>However, the CPS-transformed interpreter still uses high-level features of the meta-language, most notably first-class functions.
We will now introduce one transformation that can be used to transform a program using higher-order functions into one using only
first-order functions. It is a general program transformation technique, not restricted only to interpreters.</p>
<h2 id="lambda-lifting"><a class="header" href="#lambda-lifting">Lambda Lifting</a></h2>
<p>The first of these techniques is <em>lambda lifting</em>. The goal of lambda lifting is to turn local functions into top-level functions.
That is, all &quot;lambdas&quot; only occur at the top-level. Variables in the local environment that are normally stored in the function's
closure are instead passed as parameters to the top-level function. Lambda lifting is accomplished by the following steps:</p>
<ol>
<li>Invent a new and unique name for each function that is not a top-level function.</li>
<li>Create a function with this name. Its body is the body of the former local function. Such a function will contain free variables.</li>
<li>Add a parameter to the so-obtained top-level function for each free variable in its body.
Hence, it becomes a higher-order function that returns a function when passed these arguments.</li>
<li>Replace the local function by a call to the new top-level function and pass the corresponding local context via the arguments
created in step 3.</li>
</ol>
<p><strong>Example</strong>: Let's lambda-lift the functions <code>y =&gt; y + n</code> and <code>y =&gt; y * n</code> in</p>
<pre><code class="language-scala">def map(f: Int =&gt; Int, xs: List[Int]): List[Int] = xs match {
  case Nil =&gt; Nil
  case (x :: xs) =&gt; f(x) :: map(f, xs)
}

def addAndMultNToList(n: Int, xs: List[Int]) = map(y =&gt; y * n, map(y =&gt; y + n, xs))
</code></pre>
<p>We create two new top-level functions, let's call them <code>f</code> and <code>g</code>. Their bodies are respectively <code>y =&gt; y + n</code> and <code>y =&gt; y * n</code>.
We add a parameter for each free variable. In the example, the free variable is <code>n</code> in both cases:</p>
<pre><code class="language-scala">def fLam(n: Int) = (y: Int) =&gt; y + n
def gLam(n: Int) = (y: Int) =&gt; y * n
</code></pre>
<p>or shorter:</p>
<pre><code class="language-scala">def f(n: Int)(y: Int) = y + n
def g(n: Int)(y: Int) = y * n
</code></pre>
<p>The local function can now be replaced by a call to the new global function.</p>
<pre><code class="language-scala">def addAndMultNToListLifted(n: Int, xs: List[Int]) = map(g(n)(_), map(f(n)(_), xs))
</code></pre>
<p>Let's now perform the same technique to the CPS-transformed interpreter given above. It contains local functions in four places:
two in the <code>Add</code> branch and two in the <code>Ap</code> branch. We call the corresponding top-level functions, from left to right,
<code>addC1</code>, <code>addC2</code>, <code>apC1</code> and <code>apC2</code>.</p>
<p>An interesting novelty in the interpreter is that some local functions (corresponding to <code>addC1</code> and <code>apC1</code>) create local
functions themselves. This means that <code>addC1</code> must call <code>addC2</code> and <code>apC1</code> must call <code>apC2</code>. The rest of the transformation
is a straightforward application of the transformation steps described above:</p>
<pre><code class="language-scala">object LambdaLifted {
  def addC1[T](r: Exp, env: Env, k: Value =&gt; T)(lv: Value) =
    eval(r, env, addC2(lv, k))

  def addC2[T](lv: Value, k: Value =&gt; T)(rv: Value) = (lv, rv) match {
    case (NumV(v1), NumV(v2)) =&gt; k(NumV(v1 + v2))
    case _ =&gt; sys.error(&quot;can only add numbers&quot;)
  }

  def apC1[T](a: Exp, env: Env, k: Value =&gt; T)(cl: Value) = cl match {
    case ClosureV(f, closureEnv) =&gt; eval(a, env, apC2(f, closureEnv, k))
    case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  }

  def apC2[T](f: Fun, closureEnv: Env, k: Value =&gt; T)(av: Value) =
    eval(f.body, closureEnv + (f.param -&gt; av), k)

  def eval[T](e: Exp, env: Env, k: Value =&gt; T): T = e match {
    case Num(n: Int) =&gt; k(NumV(n))
    case Id(x) =&gt; k(env(x))
    case Add(l, r) =&gt; eval(l, env, addC1(r, env, k))
    case f@Fun(param, body) =&gt; k(ClosureV(f, env))
    case Ap(f, a) =&gt; eval(f, env, apC1(a, env, k))
  }
}
</code></pre>
<p>The lambda-lifted interpreter contains no local functions anymore, but it still contains higher-order functions, since <code>addC1</code> etc.
return functions that are passed as parameters to other functions.</p>
<h2 id="defunctionalization"><a class="header" href="#defunctionalization">Defunctionalization</a></h2>
<p><em>Defunctionalization</em> is a program transformation technique that turns higher-order programs that have already been lambda-lifted
into first-order programs that contain no higher-order functions anymore.  Any program contains only finitely many function definitions.
The idea of defunctionalization is to assign a unique identifier to each of these function definitions. The function-&quot;dispatch&quot; then
happens in a function <code>apply</code>, which receives the identifier corresponding to a function definition and dispatches the identifier
to the right function body. Every function application within the program is then replaced by a call to the <code>apply</code> function with
the function identifier as the first argument.</p>
<p>In addition to the unique identifier, the <code>apply</code> function also needs bindings for the free variables in the function body.
Hence we need to store the values for these free variables along with the unique identifier. Finally, the <code>apply</code> function needs
to know about the arguments to the function. These become additional parameters of the <code>apply</code> function.
Let's illustrate defunctionalization in the <code>addAndMultNToList</code> example from above.</p>
<pre><code class="language-scala">enum FunctionValue:
  case F(n: Int)
  case G(n: Int)

import FunctionValue._

def apply(f: FunctionValue, y: Int): Int = f match {
  case F(n) =&gt; y + n
  case G(n) =&gt; y * n
}

def map(f: FunctionValue, xs: List[Int]): List[Int] = xs match {
  case Nil =&gt; Nil
  case (x :: xs) =&gt; apply(f, x) :: map(f, xs)
}

def addAndMultNToListDefun(n: Int, xs: List[Int]) = map(G(n), map(F(n), xs))
</code></pre>
<p>Let's now apply defunctionalization to our CPS-transformed interpreter:</p>
<pre><code class="language-scala">object Defunctionalized {

  enum FunctionValue[T]:
    case AddC1(r: Exp, env: Env, k: FunctionValue[T]) extends FunctionValue[T]
    case AddC2(lv: Value, k: FunctionValue[T]) extends FunctionValue[T]
    case ApC1(a: Exp, env: Env, k: FunctionValue[T]) extends FunctionValue[T]
    case ApC2(f: Fun, closureEnv: Env, k: FunctionValue[T]) extends FunctionValue[T]

  import FunctionValue._

  def apply[T](fv: FunctionValue[T], v: Value): T  = fv match {
    case AddC1(r, env, k) =&gt; eval(r, env, AddC2(v, k))
    case AddC2(lv, k) =&gt; (lv, v) match {
      case (NumV(v1), NumV(v2)) =&gt; apply(k, NumV(v1 + v2))
      case _ =&gt; sys.error(&quot;can only add numbers&quot;)
    }
    case ApC1(a, env, k) =&gt; v match {
      case ClosureV(f, closureEnv) =&gt; eval(a, env, ApC2(f, closureEnv, k))
      case _ =&gt; sys.error(&quot;can only apply functions&quot;)
    }
    case ApC2(f, closureEnv, k) =&gt; eval(f.body, closureEnv + (f.param -&gt; v), k)
  }

  def eval[T](e: Exp, env: Env, k: FunctionValue[T]): T = e match {
    case Num(n: Int) =&gt; apply(k, NumV(n))
    case Id(x) =&gt; apply(k, env(x))
    case Add(l, r) =&gt; eval(l, env, AddC1(r, env, k))
    case f@Fun(param, body) =&gt; apply(k, ClosureV(f, env))
    case Ap(f, a) =&gt; eval(f, env, ApC1(a, env, k))
  }
}
</code></pre>
<p>This interpreter can be seen as an abstract machine. The state space of the abstract machine is
(<code>Exp</code> \( \times \) <code>Env</code> \( \times \) <code>FunctionValue</code>) \( \cup \) (<code>FunctionValue</code> \( \times \) <code>Value</code>),
where \( \times \) stands for cross product and \( \cup \) stands for set union.
Every case in the pattern matches in <code>apply</code> and <code>eval</code> can be read as a transition in this state space.</p>
<h2 id="from-interpreter-to-abstract-machine"><a class="header" href="#from-interpreter-to-abstract-machine">From Interpreter to Abstract Machine</a></h2>
<p>To see that we can read the above functions as transitions of an abstract machine, let's actually
construct that machine.
Its domain of States is the type <code>MachineState[T]</code>.
The final state of the machine is <code>Done(v)</code>, for some value <code>v</code>.
Its transition function is the function named <code>transition</code>.
We can see every intermediate state of the abstract machine.
Its state is fully described by the (first-order) state type. We are no
longer dependent on call-stack management or higher-order functions of
the meta-language (Scala).</p>
<pre><code class="language-scala">object AbstractMachine {
  enum FunctionValue[T]:
    case AddC1(r: Exp, env: Env, k: FunctionValue[T]) extends FunctionValue[T]
    case AddC2(lv: Value, k: FunctionValue[T]) extends FunctionValue[T]
    case ApC1(a: Exp, env: Env, k: FunctionValue[T]) extends FunctionValue[T]
    case ApC2(f: Fun, closureEnv: Env, k: FunctionValue[T]) extends FunctionValue[T]
    case IdentityFV() extends FunctionValue[Value]

  import FunctionValue._

  enum MachineState[T]:
    case EvalState(e: Exp, env: Env, fv: FunctionValue[T]) extends MachineState[T]
    case ApplyState(fv: FunctionValue[T], v: Value) extends MachineState[T]
    case Done(v: Value) extends MachineState[Value]

  import MachineState._

  def transition[T](s: MachineState[T]): MachineState[T] =
    s match {
      case EvalState(e, env, k) =&gt; transitionEval(e, env, k)
      case ApplyState(fv, v) =&gt; transitionApply(fv, v)
      case Done(v) =&gt; sys.error(&quot;already done&quot;)
    }

  def transitionEval[T](e: Exp, env: Env, k: FunctionValue[T]): MachineState[T] = e match {
    case Num(n: Int) =&gt; ApplyState(k, NumV(n))
    case Id(x) =&gt; ApplyState(k, env(x))
    case Add(l, r) =&gt;
      EvalState(l, env, AddC1(r, env, k))
    case f@Fun(param, body) =&gt; ApplyState(k, ClosureV(f, env))
    case Ap(f, a) =&gt;  EvalState(f, env, ApC1(a, env, k))
   }

   def transitionApply[T](fv: FunctionValue[T], v: Value): MachineState[T] = fv match {
    case IdentityFV() =&gt; Done(v)
    case AddC1(r, env, k) =&gt; EvalState(r, env, AddC2(v, k))
    case AddC2(lv, k) =&gt; (lv, v) match {
          case (NumV(v1), NumV(v2)) =&gt; ApplyState(k, NumV(v1 + v2))
          case _ =&gt; sys.error(&quot;can only add numbers&quot;)
         }
    case ApC1(a, env, k) =&gt; v match {
        case ClosureV(f, closureEnv) =&gt; EvalState(a, env, ApC2(f, closureEnv, k))
        case _ =&gt; sys.error(&quot;can only apply functions&quot;)
    }
    case ApC2(f, closureEnv, k) =&gt; EvalState(f.body, closureEnv + (f.param -&gt; v), k)
  }
}
import AbstractMachine._
import FunctionValue._
import MachineState._
</code></pre>
<p>Now let's try this out with a concrete example and look at the tract of transitions</p>
<pre><code class="language-scala">val test = Ap(Fun(&quot;x&quot;, Add(&quot;x&quot;, 1)), 5)
// test: Exp = Ap(
//   funExpr = Fun(param = &quot;x&quot;, body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))),
//   argExpr = Num(n = 5)
// )
val initMS: MachineState[Value] = EvalState(test,
                                            Map.empty,
                                            AbstractMachine.FunctionValue.IdentityFV())
// initMS: MachineState[Value] = EvalState(
//   e = Ap(
//     funExpr = Fun(
//       param = &quot;x&quot;,
//       body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))
//     ),
//     argExpr = Num(n = 5)
//   ),
//   env = Map(),
//   fv = IdentityFV()
// )
val s1 = transition(initMS)
// s1: MachineState[Value] = EvalState(
//   e = Fun(param = &quot;x&quot;, body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))),
//   env = Map(),
//   fv = ApC1(a = Num(n = 5), env = Map(), k = IdentityFV())
// )
val s2 = transition(s1)
// s2: MachineState[Value] = ApplyState(
//   fv = ApC1(a = Num(n = 5), env = Map(), k = IdentityFV()),
//   v = ClosureV(
//     f = Fun(param = &quot;x&quot;, body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))),
//     env = Map()
//   )
// )
val s3 = transition(s2)
// s3: MachineState[Value] = EvalState(
//   e = Num(n = 5),
//   env = Map(),
//   fv = ApC2(
//     f = Fun(param = &quot;x&quot;, body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))),
//     closureEnv = Map(),
//     k = IdentityFV()
//   )
// )
val s4 = transition(s3)
// s4: MachineState[Value] = ApplyState(
//   fv = ApC2(
//     f = Fun(param = &quot;x&quot;, body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))),
//     closureEnv = Map(),
//     k = IdentityFV()
//   ),
//   v = NumV(n = 5)
// )
val s5 = transition(s4)
// s5: MachineState[Value] = EvalState(
//   e = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1)),
//   env = Map(&quot;x&quot; -&gt; NumV(n = 5)),
//   fv = IdentityFV()
// )
val s6 = transition(s5)
// s6: MachineState[Value] = EvalState(
//   e = Id(name = &quot;x&quot;),
//   env = Map(&quot;x&quot; -&gt; NumV(n = 5)),
//   fv = AddC1(r = Num(n = 1), env = Map(&quot;x&quot; -&gt; NumV(n = 5)), k = IdentityFV())
// )
val s7 = transition(s6)
// s7: MachineState[Value] = ApplyState(
//   fv = AddC1(r = Num(n = 1), env = Map(&quot;x&quot; -&gt; NumV(n = 5)), k = IdentityFV()),
//   v = NumV(n = 5)
// )
val s8 = transition(s7)
// s8: MachineState[Value] = EvalState(
//   e = Num(n = 1),
//   env = Map(&quot;x&quot; -&gt; NumV(n = 5)),
//   fv = AddC2(lv = NumV(n = 5), k = IdentityFV())
// )
val s9 = transition(s8)
// s9: MachineState[Value] = ApplyState(
//   fv = AddC2(lv = NumV(n = 5), k = IdentityFV()),
//   v = NumV(n = 1)
// )
val s10 = transition(s9)
// s10: MachineState[Value] = ApplyState(fv = IdentityFV(), v = NumV(n = 6))
val s11 = transition(s10)
// s11: MachineState[Value] = Done(v = NumV(n = 6))
</code></pre>
<p>We can also automate this into a function that collects the list of all states.</p>
<pre><code class="language-scala">def evalMachine(e: Exp): List[MachineState[Value]] = {
  val initMS: MachineState[Value] = EvalState(e,
                                              Map.empty,
                                              AbstractMachine.FunctionValue.IdentityFV())
  List.unfold(initMS)({ case Done(v) =&gt; None
                        case s =&gt; { val s2 = transition(s); Some((s, s2))}})
}

val q = evalMachine(test)
// q: List[MachineState[Value]] = List(
//   EvalState(
//     e = Ap(
//       funExpr = Fun(
//         param = &quot;x&quot;,
//         body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))
//       ),
//       argExpr = Num(n = 5)
//     ),
//     env = Map(),
//     fv = IdentityFV()
//   ),
//   EvalState(
//     e = Fun(param = &quot;x&quot;, body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))),
//     env = Map(),
//     fv = ApC1(a = Num(n = 5), env = Map(), k = IdentityFV())
//   ),
//   ApplyState(
//     fv = ApC1(a = Num(n = 5), env = Map(), k = IdentityFV()),
//     v = ClosureV(
//       f = Fun(param = &quot;x&quot;, body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))),
//       env = Map()
//     )
//   ),
//   EvalState(
//     e = Num(n = 5),
//     env = Map(),
//     fv = ApC2(
//       f = Fun(param = &quot;x&quot;, body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))),
//       closureEnv = Map(),
//       k = IdentityFV()
//     )
//   ),
//   ApplyState(
//     fv = ApC2(
//       f = Fun(param = &quot;x&quot;, body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))),
//       closureEnv = Map(),
//       k = IdentityFV()
//     ),
//     v = NumV(n = 5)
//   ),
//   EvalState(
//     e = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1)),
//     env = Map(&quot;x&quot; -&gt; NumV(n = 5)),
//     fv = IdentityFV()
//   ),
//   EvalState(
//     e = Id(name = &quot;x&quot;),
//     env = Map(&quot;x&quot; -&gt; NumV(n = 5)),
// ...
</code></pre>
<h2 id="refunctionalization"><a class="header" href="#refunctionalization">Refunctionalization</a></h2>
<p>Can we also invert defunctionalization? That is, can we represent a
program such that a data type is replaced by a function type?</p>
<p>Let's look at an example.</p>
<pre><code class="language-scala">enum MyList[T]:
  case MyEmptyList() extends MyList[T]
  case MyCons(x: T, xs: MyList[T]) extends MyList[T]

import MyList._

def nth[T](l: MyList[T], i: Int): T = l match {
  case MyEmptyList() =&gt; sys.error(&quot;index out of range&quot;)
  case MyCons(x, xs) =&gt; if (i == 0) then x else nth(xs, i - 1)
}
</code></pre>
<p>Refunctionalization works smoothly when there is just one pattern match on
a data type. In this case, we represent a list by &quot;its&quot; <code>nth</code> function:</p>
<pre><code class="language-scala">type MyListR[T] = Int =&gt; T

def myEmptyList[T]: MyListR[T] = _ =&gt; sys.error(&quot;index out of range&quot;)
def myCons[T](x: T,  xs: MyListR[T]): MyListR[T] =
  i =&gt; if (i == 0) then x else xs(i - 1)
</code></pre>
<p>The defunctionalized and the refunctionalized lists differ in their modular structure.
In the defunctionalized version, it is &quot;easy&quot; (only addition of code but no modification
of existing code necessary) to add new functions that pattern-match on lists, such
as a <code>length</code>function.</p>
<pre><code class="language-scala">def length[T](l: MyList[T]): Int = l match {
  case MyEmptyList() =&gt; 0
  case MyCons(x, xs) =&gt; 1 + length(xs)
}
</code></pre>
<p>In the refunctionalized version, on the other hand, it is &quot;easy&quot; to add new ways to create lists.
For instance, here is a constructor for the infinite list of numbers</p>
<pre><code class="language-scala">def allNats: MyListR[Int] = i =&gt; i
</code></pre>
<p>The two versions hence corresponds to the two dimensions of the aforementioned &quot;expression problem&quot;.
These program  transformations are hence generally applicable program transformations in
a programmer's modularity toolbox.</p>
<p>But what about refunctionalization in the case that there is more than one pattern-match on the
data type? It turns out that we can refunctionalize if we generalize functions to objects, that is,
if we view functions as special kinds of objects with a single <code>apply</code> method.</p>
<p>For instance, in the case of lists with two pattern-matching functions, <code>nth</code> and <code>length</code>,
we can represent lists as <em>objects</em> with two methods, one for each pattern match.</p>
<pre><code class="language-scala">trait MyListRO[T] {
  def nth(i: Int): T
  def length: Int
}

def myEmptyListO[T]: MyListRO[T] = new MyListRO[T] {
  def nth(i: Int): T = sys.error(&quot;index out of range&quot;)
  def length: Int = 0
}

def myConsO[T](x: T,  xs: MyListRO[T]): MyListRO[T] = new MyListRO[T] {
  def nth(i: Int): T = if (i == 0) then x else xs.nth(i - 1)
  def length: Int =  1 + xs.length
}
</code></pre>
<p>With this generalization, we can defunctionalize any object type (the transformation
could then maybe be called &quot;deobjectionalization&quot;) and we can refunctionalize any
algebraic data type, and thereby completely invert the extensibility of the program.</p>
<p>Recall that both transformations are <em>global</em> and not compositional, that is, the full program must be
transformed at once.</p>
<p>We have glossed over some technical details that would need to be addressed to automate
these transformations and make them inverse to each other. For instance, we have not
addressed how to reverse the lambda lifting part.</p>
<p>Historical notes: Defunctionalization was proposed by John Reynolds in 1972 in his landmark
paper &quot;Definitional Interpreters for Higher-Order Programming Languages&quot;.
Similar to these lecture notes, Reynolds applied defunctionalization to a CPS-transformed interpreter.
The generalization of refunctionalization to use objects instead of functions was presented
in a 2015 paper by Rendel, Trieflinger, and Ostermann entitled &quot;Automatic Refunctionalization to a
Language with Copattern Matching: With Applications to the Expression Problem&quot;. A fully formal account
of the transformations that also addresses invertible lambda lifting and proves that the
transformations are inverses of each other can be found in the 2020 paper
&quot;Decomposition Diversity with Symmetric Data and Codata&quot; by Binder, Jabs, Skupin and Ostermann.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../23-monadic-reflection/monadic-reflection.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../25-type-systems/type-systems.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../23-monadic-reflection/monadic-reflection.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../25-type-systems/type-systems.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../questionnaire.js"></script>
    </body>
</html>
