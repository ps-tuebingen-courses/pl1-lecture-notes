<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Programming Languages I</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Lecture notes for the Programming Languages I lecture at the University of Tübingen">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded affix "><li class="part-title">Introduction</li><li class="chapter-item expanded "><a href="01-intro/intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="02-scala-basics/scala-basics.html"><strong aria-hidden="true">2.</strong> Scala Basics</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic Topics</li><li class="chapter-item expanded "><a href="03-arithmetic-expressions/arithmetic-expressions.html"><strong aria-hidden="true">3.</strong> Arithmetic Expressions (AEId)</a></li><li class="chapter-item expanded "><a href="04-desugaring/desugaring.html"><strong aria-hidden="true">4.</strong> Desugaring</a></li><li class="chapter-item expanded "><a href="05-name-binding/name-binding.html"><strong aria-hidden="true">5.</strong> Name Binding (WAE)</a></li><li class="chapter-item expanded "><a href="06-first-order-functions/first-order-functions.html"><strong aria-hidden="true">6.</strong> First Order Functions (F1WAE)</a></li><li class="chapter-item expanded "><a href="07-higher-order-functions/higher-order-functions.html"><strong aria-hidden="true">7.</strong> Higher Order Functions (FAE)</a></li><li class="chapter-item expanded "><a href="08-lazy-evaluation/lazy-evaluation.html"><strong aria-hidden="true">8.</strong> Lazy Evaluation (LCFAE)</a></li><li class="chapter-item expanded "><a href="09-recursive-functions/recursive-functions.html"><strong aria-hidden="true">9.</strong> Recursive Functions (RCFAE)</a></li><li class="chapter-item expanded "><a href="10-mutation/mutation.html"><strong aria-hidden="true">10.</strong> Mutation (BCFAE)</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Topics 1</li><li class="chapter-item expanded "><a href="11-garbage-collection/garbage-collection.html"><strong aria-hidden="true">11.</strong> Garbage Collection</a></li><li class="chapter-item expanded "><a href="12-meta-interpretation/meta-interpretation.html"><strong aria-hidden="true">12.</strong> Syntactic and Meta Interpretation</a></li><li class="chapter-item expanded "><a href="13-church-encoding/church-encoding.html"><strong aria-hidden="true">13.</strong> Church Encodings</a></li><li class="chapter-item expanded "><a href="14-object-algebras/object-algebras.html"><strong aria-hidden="true">14.</strong> Object Algebras</a></li><li class="chapter-item expanded affix "><li class="part-title">Continuations</li><li class="chapter-item expanded "><a href="15-continuations-1/continuations-1.html"><strong aria-hidden="true">15.</strong> Continuations: Motivation</a></li><li class="chapter-item expanded "><a href="16-continuations-2/continuations-2.html"><strong aria-hidden="true">16.</strong> Continuations: Definition</a></li><li class="chapter-item expanded "><a href="17-first-class-continuations/first-class-continuations.html"><strong aria-hidden="true">17.</strong> First Class Continuations</a></li><li class="chapter-item expanded "><a href="18-letcc/letcc.html"><strong aria-hidden="true">18.</strong> Call-with-current-continuation</a></li><li class="chapter-item expanded "><a href="19-shift-reset/shift-reset.html"><strong aria-hidden="true">19.</strong> Delimited Continuations</a></li><li class="chapter-item expanded affix "><li class="part-title">Monads</li><li class="chapter-item expanded "><a href="20-monads-intro/monads-intro.html"><strong aria-hidden="true">20.</strong> Monads Intro</a></li><li class="chapter-item expanded "><a href="21-io-monad/io-monad.html"><strong aria-hidden="true">21.</strong> The IO Monad</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Topics 2</li><li class="chapter-item expanded "><a href="22-modular-interpreters/modular-interpreters.html"><strong aria-hidden="true">22.</strong> Modular Interpreters</a></li><li class="chapter-item expanded "><a href="23-monadic-reflection/monadic-reflection.html"><strong aria-hidden="true">23.</strong> Monadic Reflection</a></li><li class="chapter-item expanded "><a href="24-defunctionalization/defunctionalization.html"><strong aria-hidden="true">24.</strong> Defunctionalization</a></li><li class="chapter-item expanded affix "><li class="part-title">Type Systems</li><li class="chapter-item expanded "><a href="25-type-systems/type-systems.html"><strong aria-hidden="true">25.</strong> Type Systems</a></li><li class="chapter-item expanded "><a href="26-stlc/stlc.html"><strong aria-hidden="true">26.</strong> Simply Typed Lambda Calculus (STLC)</a></li><li class="chapter-item expanded "><a href="27-type-inference/type-inference.html"><strong aria-hidden="true">27.</strong> Type Inference</a></li><li class="chapter-item expanded affix "><a href="furtherreading.html">Further Reading</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programming Languages I</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>These are lecture notes for the &quot;Programming Languages I&quot; course at the University of Tübingen.
These lecture notes are loosely based on &quot;Programming Languages: Application and Interpretation&quot; by Shriram Krishnamurthi.</p>
<p>These lecture notes can be improved by your corrections, comments and amendments.
Every page of these lectures notes comes with a link to the corresponding document hosted on Github in the top right corner.
Please open a pull request for any changes that help us improve this script.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="why-are-you-here"><a class="header" href="#why-are-you-here">Why are you here?</a></h2>
<p>This is an advanced programming course that focuses on the design and semantics of programming languages.
The goals of this course are:</p>
<ul>
<li>To change the way you solve problems in programming: By principled design,  with a rich toolbox of abstract concepts, rather than by tinkering.</li>
<li>Enable you to think beyond the currently fashionable programming languages.</li>
<li>Enable you to evaluate and discuss programming languages in a principled way.</li>
<li>To show you where computer languages come from and potential future directions.</li>
<li>To demonstrate why languages should be regarded as the ultimate form of abstraction.</li>
<li>To teach you how to recognize abstractions and how to turn them into a language design.</li>
<li>Teach you different ways how to realize a language design and make it practically useful.</li>
<li>To convey a sense of aesthetics in programming.</li>
<li>To introduce you into one of the most beautiful theories in theoretical computer science.</li>
<li>To turn you into a better programmer!</li>
</ul>
<p>Non-goals of this course are:</p>
<ul>
<li>Learn X different programming languages. Rather, you'll learn to decompose a PL into its features and discuss the merits of the features independently of the concrete PL.</li>
<li>Write parsers or implement full-fledged compilers (although we will touch some compiler issues).</li>
<li>Turn you into an evangelist for a particular PL.</li>
</ul>
<h2 id="how-will-we-get-there"><a class="header" href="#how-will-we-get-there">How will we get there?</a></h2>
<p>We will typically explain language features in two steps. First, we'll give an informal introduction and discuss some examples to get
some experience with it. Then we will distill the core of the feature into an executable interpreter. Later, when we have more experience
in formalizing language design into interpreters, we will also use formal mathematical notation.
We will not just present the design of these features as if it had appeared out of the blue sky. Rather, we will discuss the process and
trade-offs (and potential mistakes and pitfalls) that led to these designs. We will also discuss how these features appear in various
available programming languages.
We will mainly use the programming language Scala to write interpreters. Scala is sufficiently powerful to allow concise and elegant
interpreters; on the other hand, it is sufficiently mature and popular for industrial usage. It also has variants of many of the features
we will discuss. The book by Krishnamurthi, on which we loosely base the first part of the course, uses a different language, Racket.
You are also welcome to use Racket instead of (or in addition to) Scala. Racket embodies an important tradition of PL design that is worth
knowing, hence we encourage you, independently of this course, to study it!</p>
<h2 id="how-we-will-study-programming-languages"><a class="header" href="#how-we-will-study-programming-languages">How we will study programming languages</a></h2>
<p>Rather than use vague labels such as &quot;object-oriented&quot; or &quot;functional&quot;, we will decompose languages into small features, similar to how
matter can be explained and decomposed into atoms, cells into DNA fragments, or organisms into the biological taxonomy.
In addition to the decomposition into small-grained features, we will use a conceptual technique called &quot;desugaring&quot; to distinguish
essential from non-essential language parts and identify the core constructs of a language.</p>
<h2 id="topics-for-class-discussion"><a class="header" href="#topics-for-class-discussion">Topics for class discussion:</a></h2>
<ul>
<li>How can programming languages be evaluated, classified and compared?</li>
<li>Why are labels like &quot;object-oriented&quot;, &quot;declarative&quot;, or &quot;functional&quot; too coarse-grained to be useful?</li>
<li>How can we turn programming language research into a science?</li>
<li>What would you like to learn in this course? What are your expectations?</li>
<li>Which programming languages do you know? Which features of these languages do you
like or dislike, and why?</li>
<li>Is the choice of programming language for a programming project significant?</li>
<li>Are interpreters a good way to capture the meaning of a PL? How do they compare to informal descriptions, formal specifications, and compilers?</li>
<li>How important is the syntax of a PL?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scala-basics"><a class="header" href="#scala-basics">Scala Basics</a></h1>
<p>The content of this chapter is available as a Scala file <a href="02-scala-basics/./scala-basics.scala">here.</a></p>
<pre><code class="language-scala">val x = 2 + 2;
// x: Int = 4
</code></pre>
<pre><code class="language-scala">// val für Konstanten
// def für Methoden
// var für Variablen

abstract class Person(val name: String) {
  // String name
  // val name: String

  def sayHello = {
    print(&quot;hello, &quot; + name)
  }
}

trait ByeBye {
  def sayGoodbye = {
    print(&quot;bye&quot;)
  }
}

class Tillmann(name: String) extends Person(name) with ByeBye {
  override def sayHello = {
    print(&quot;hi&quot;)
  }
}

object Me extends Tillmann(&quot;Tillmann&quot;)




trait UniPerson
case class Student(val matrikelnummer: Int) extends UniPerson
case class Professor(val fachgebiet: String) extends UniPerson

object PatternMatching {
  def showUniPerson(p: UniPerson): String =
    p match {
      case Student(m) =&gt; &quot;student nr &quot; + m
      case Professor(f) =&gt; &quot;professor on &quot; + f
    }

  def test = {
    print(showUniPerson(Student(123)))
    print(showUniPerson(Professor(&quot;programming languages&quot;)))
  }
}


enum UniPersonEnum:
  case StudentEnum(val matrikelnummer: Int)
  case ProfessorEnum(val fachgebiet: String)

object PatternMatchingEnum {
  import UniPersonEnum._

  def showUniPerson(p: UniPersonEnum): String =
    p match {
      case StudentEnum(m) =&gt; &quot;student nr &quot; + m
      case ProfessorEnum(f) =&gt; &quot;professor on &quot; + f
    }

  def test = {
    print(showUniPerson(StudentEnum(123)))
    print(showUniPerson(ProfessorEnum(&quot;programming languages&quot;)))
  }
}


object AE {
  // Abstract Syntax Tree
  enum Exp:
    case Num(n: Int)
    case Add(lhs: Exp, rhs: Exp)

  import Exp._

  // Example
  val onePlusEight = Add(Num(1), Add(Num(5), Num(3)))

  // Interpreter
  def eval(e: Exp): Int =
    e match {
      case Num(n) =&gt; n
      case Add(lhs, rhs) =&gt;
        eval(lhs) + eval(rhs)
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arithmetic-expressions-with-variables"><a class="header" href="#arithmetic-expressions-with-variables">Arithmetic Expressions With Variables</a></h1>
<p>The content of this chapter is available as a Scala file <a href="03-arithmetic-expressions/./arithmetic-expressions.scala">here.</a></p>
<p>Let us now consider an extension of the arithmetic expression language with variables. We do this by a new kind of expression, which we
call Identifier, or Id.</p>
<p>\[
\begin{array}{lclr}
e &amp; := &amp; n &amp; \textit{Numeric Literals} \\
&amp; | &amp; (e + e) &amp; \textit{Addition} \\
&amp; | &amp; (e * e) &amp; \textit{Multiplication} \\
&amp; | &amp; x &amp; \textit{Identifier}
\end{array}
\]</p>
<pre><code class="language-scala">object AEId {
</code></pre>
<pre><code class="language-scala">enum Exp:
  case Num(n: Int) extends Exp
  case Add(lhs: Exp, rhs: Exp) extends Exp
  case Mul(lhs: Exp, rhs: Exp) extends Exp
  case Id(x: String) extends Exp
import Exp._
</code></pre>
<p>Here is a sample program written in this language, directly written down using case class constructors:</p>
<pre><code class="language-scala">val test0 = Add(Mul(Id(&quot;x&quot;),Num(2)),Add(Id(&quot;y&quot;),Id(&quot;y&quot;)))
</code></pre>
<p>With a proper parser we could choose a syntax like <code>x*2+y+y</code>. We do not care much about concrete syntax and parsing, though.</p>
<p>That said, to make writing examples less verbose, Scala's implicits come to the rescue.
Calls to implicit functions are inserted automatically by the compiler if they help to restore well-typedness. For instance, we can define</p>
<pre><code class="language-scala">implicit def num2exp(n: Int): Exp = Num(n)
implicit def sym2exp(x: String): Exp = Id(x)
</code></pre>
<p>to lift integers and Strings to expressions. Using these implicits, the example can be written as:</p>
<pre><code class="language-scala">val test = Add(Mul(&quot;x&quot;,2),Add(&quot;y&quot;,&quot;y&quot;))
</code></pre>
<p>To give meaning to identifiers, we use <em>environments</em>. Environments are mappings from Identifiers (which we represent as Strings) to Values.
In our simple language the only values are integers, hence:</p>
<pre><code class="language-scala">type Env = Map[String,Int]
</code></pre>
<p>An evaluator (or interpreter) for this language takes an expression and an environment as parameter and produces a value - in this case
&quot;Int&quot;. This interpreter uses pattern matching over case classes.</p>
<pre><code class="language-scala">def eval(e: Exp, env: Env) : Int = e match {
  case Num(n) =&gt; n
  case Id(x) =&gt; env(x)
  case Add(l,r) =&gt; eval(l,env) + eval(r,env)
  case Mul(l,r) =&gt; eval(l,env) * eval(r,env)
}
</code></pre>
<p>A different (and arguably more 'object-oriented') way to implement this evaluator would be to add an abstract &quot;eval&quot; method to the Exp
class and override it in all subclasses, each implementation corresponding to its corresponding case in the pattern match. The choice
between these alternatives matters, since they support different dimensions of extensibility.</p>
<p>We will mainly use the more functional style using pattern matching, because it matches better to the order in which we present these
topics in the lecture. To try the example, we need a sample environment that gives values to the (free) variables in the sample expression.</p>
<p>The test environment also illustrates how Scala supports direct definitions of constant maps.</p>
<pre><code class="language-scala">val testEnv = Map(&quot;x&quot; -&gt; 3, &quot;y&quot; -&gt; 4)
</code></pre>
<p>We can automatically test our evaluator using assert :</p>
<pre><code class="language-scala">val exa = eval(test, testEnv)
// exa: Int = 14
assert(eval(test, testEnv) == 14)
</code></pre>
<pre><code class="language-scala">}
</code></pre>
<p>We will now learn a different way to encode algorithms that operate on expressions (like the evaluator). To this end, we will now use
so-called &quot;folds&quot;. Folds are well-known for lists, but the concept is more general and applies to arbitrary algebraic data types.
We will present folds in such a style that they resemble visitors as known from the OO design pattern literature. They correspond to
so-called &quot;internal visitors&quot; in which the traversal is encoded within the &quot;accept&quot; function.
An internal visitor consists of one function for each syntactic construct of the language. It has a type parameter that determines the
&quot;return type&quot; of invoking the visitor on an expression. This type parameter is used in all positions in which the original syntax
specifies a subexpression.
Internal visitors also correspond to a &quot;bottom-up&quot; traversal of the syntax tree.</p>
<pre><code class="language-scala">object Visitors {
</code></pre>
<pre><code class="language-scala">case class VisitorAE[T](num: Int =&gt; T, add: (T, T) =&gt; T)
</code></pre>
<p>The fold function below itself applies a visitor to an expression. Note that the recursion is performed in the fold function, hence all visitors
are not recursive.</p>
<p>Also note that this design enforces that all algorithms specified via this visitor interface are compositional by design. This means that
the recursion structure of the algorithm corresponds to the recursion structure of the expression. Put in another way, it means that the
semantics (in terms of the meta-language) of a composite expression is determined by the semantics of the subexpressions; the syntax of
the subexpressions is irrelevant.</p>
<p>Compositional specifications are particularly nice because they enable &quot;equational reasoning&quot;: Subexpressions can be replaced by other
subexpressions with the same semantics without changing the semantics of the whole.</p>
<pre><code class="language-scala">enum ExpAE:
  case NumAE(n: Int) extends ExpAE
  case AddAE(lhs: ExpAE, rhs: ExpAE) extends ExpAE
import ExpAE._

def foldExp[T](v: VisitorAE[T], e: ExpAE): T = {
  e match {
    case NumAE(n) =&gt; v.num(n)
    case AddAE(l, r) =&gt; v.add(foldExp(v, l), foldExp(v, r))
  }
}
</code></pre>
<p>Here is our evaluator from above rephrased using the visitor infrastructure.</p>
<pre><code class="language-scala">val evalVisitorAE = VisitorAE[Int](x =&gt; x, (a, b) =&gt; a + b)
</code></pre>
<p>We can of course restore the original interface of <code>eval</code> using <code>foldExp</code>:</p>
<pre><code class="language-scala">def eval(e: ExpAE) = foldExp(evalVisitorAE, e)
</code></pre>
<p>Let's test whether it works.</p>
<pre><code class="language-scala">val exaVisitorAE = eval(AddAE(AddAE(NumAE(1),NumAE(2)),NumAE(3)))
// exaVisitorAE: Int = 6
assert(exaVisitorAE == 6)
</code></pre>
<p>We can also apply other algorithms using visitors, such as counting the number of <code>NumAE</code> literals, or printing to a string:</p>
<pre><code class="language-scala">val countVisitorAE = VisitorAE[Int]( _=&gt;1, _+_)
val printVisitorAE = VisitorAE[String](_.toString, &quot;(&quot;+_+&quot;+&quot;+_+&quot;)&quot;)
</code></pre>
<pre><code class="language-scala">}
</code></pre>
<p>Let's now try the same with the AE language with identifiers. It all works in the same way:</p>
<pre><code class="language-scala">object AEIdVisitor {
import AEId._
</code></pre>
<pre><code class="language-scala">case class Visitor[T](num: Int =&gt; T, add: (T, T) =&gt; T, mul: (T, T) =&gt; T, id: String =&gt; T)
val expVisitor = Visitor[Exp](Num(_), Add(_, _), Mul(_, _), Id(_))
val countVisitor = Visitor[Int](_=&gt;1, _ + _, _ + _, _ =&gt; 0)
val printVisitor = Visitor[String](_.toString, &quot;(&quot; + _ + &quot;+&quot; + _ + &quot;)&quot;, _ + &quot;*&quot; + _, identity)

def foldExp[T](v: Visitor[T], e: Exp) : T = {
  e match {
    case Num(n) =&gt; v.num(n)
    case Add(l,r) =&gt; v.add(foldExp(v, l), foldExp(v, r))
    case Mul(l,r) =&gt; v.mul(foldExp(v, l), foldExp(v, r))
    case Id(x) =&gt; v.id(x)
  }
}
</code></pre>
<pre><code class="language-scala">def countNums(e: Exp) = foldExp(countVisitor, e)

val exaCount = countNums(test)
// exaCount: Int = 1
assert(exaCount == 1)
</code></pre>
<p>However, what about the evaluator? If we instantiate <code>T</code> = <code>Int</code>, then how can we access the environment? Insight: For evaluation, we must
instantiate <code>T</code> with a function type <code>Env =&gt; Int</code>! This way of transforming a multi-argument function into a single-argument
higher-order function is called <em>currying</em>.</p>
<pre><code class="language-scala">val evalVisitor = Visitor[Env=&gt;Int](
   env =&gt; _ ,
   (a, b) =&gt; env =&gt;
     a(env) + b(env),
   (a, b) =&gt; env =&gt;
     a(env) * b(env),
   x =&gt; env =&gt;
     env(x))
</code></pre>
<pre><code class="language-scala">}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="desugaring"><a class="header" href="#desugaring">Desugaring</a></h1>
<p>The content of this chapter is available as a Scala file <a href="04-desugaring/./desugaring.scala">here.</a></p>
<h2 id="desugaring-1"><a class="header" href="#desugaring-1">Desugaring</a></h2>
<p>You have already seen the basic structure of an interpreter by means of an interpreter for a language of arithmetic <code>Exps</code>:</p>
<pre><code class="language-scala">object AE {
  // Abstract Syntax Tree
  enum Exp:
    case Num(n: Int) extends Exp
    case Add(lhs: Exp, rhs: Exp) extends Exp
  import Exp._

  // Example
  val ex = Add(Num(1), Add(Num(5), Num(3)))

  // Interpreter
  def eval(e: Exp): Int =
    e match {
      case Num(n) =&gt; n
      case Add(lhs, rhs) =&gt;
        eval(lhs) + eval(rhs)
    }
}
</code></pre>
<p>In this lecture we want to study the technique of desugaring as a means to structure programming languages and decompose a language into
a core language and syntactic sugar.</p>
<p>For illustration, consider the following proposed extensions to the language:</p>
<ol>
<li><code>Mult</code></li>
<li><code>Sub</code></li>
<li>Unary Negation</li>
</ol>
<p>Extension number 1 is a good example for a core language extension. We have no way of expressing <code>Mult</code> in terms of the existing constructs
(if we had some looping construct we could express <code>Mult</code> as repeated <code>Add</code> but we do not have loops).</p>
<p>Hence we add this language construct to the (core) language:</p>
<pre><code class="language-scala">object MAE {
  // Abstract Syntax Tree
  enum Exp:
    case Num(n: Int) extends Exp
    case Add(lhs: Exp, rhs: Exp) extends Exp
    case Mult(lhs: Exp, rhs: Exp) extends Exp
  import Exp._
  // Example
  val ex = Add(Num(1), Mult(Num(5), Num(3)))

  // Interpreter
  def eval(e: Exp): Int =
    e match {
      case Num(n) =&gt; n
      case Add(lhs, rhs) =&gt; eval(lhs) + eval(rhs)
      case Mult(lhs, rhs) =&gt;  eval(lhs) * eval(rhs)
    }
}
</code></pre>
<p>Let us now consider extension #2, <code>Sub</code>. One way to support sub is to add it to the core language, just like <code>Mult</code>:</p>
<pre><code class="language-scala">object SMAE {
  // Abstract Syntax Tree
  enum Exp:
    case Num(n: Int) extends Exp
    case Add(lhs: Exp, rhs: Exp) extends Exp
    case Mult(lhs: Exp, rhs: Exp) extends Exp
    case Sub(lhs: Exp, rhs: Exp) extends Exp
  import Exp._
  // Example
  val ex = Sub(Num(1), Mult(Num(5), Num(3)))

  // Interpreter
  def eval(e: Exp): Int =
    e match {
      case Num(n) =&gt; n
      case Add(lhs, rhs) =&gt; eval(lhs) + eval(rhs)
      case Mult(lhs, rhs) =&gt;  eval(lhs) * eval(rhs)
      case Sub(lhs, rhs) =&gt;  eval(lhs) - eval(rhs)
    }
}
</code></pre>
<p>However, another way of adding sub is to treat it as syntactic sugar using the fact that <code>a - b = a + (-1 * b)</code>
One way of expressing the desugaring is as a syntax transformation:</p>
<pre><code class="language-scala">def desugarSMAE2MAE(e: SMAE.Exp) : MAE.Exp = e match {
  case SMAE.Exp.Num(n) =&gt; MAE.Exp.Num(n)
  case SMAE.Exp.Add(lhs, rhs) =&gt; MAE.Exp.Add(desugarSMAE2MAE(lhs), desugarSMAE2MAE(rhs))
  case SMAE.Exp.Mult(lhs, rhs) =&gt; MAE.Exp.Mult(desugarSMAE2MAE(lhs), desugarSMAE2MAE(rhs))
  case SMAE.Exp.Sub(lhs, rhs) =&gt;
    MAE.Exp.Add(desugarSMAE2MAE(lhs),
                 MAE.Exp.Mult(MAE.Exp.Num(-1),desugarSMAE2MAE(rhs)))
}
</code></pre>
<p>With this desugaring in place, we do not need an interpreter for SMAE anymore; rather we can reuse the MAE interpreter:</p>
<pre><code class="language-scala">val res = MAE.eval(desugarSMAE2MAE(SMAE.ex))
// res: Int = -14
</code></pre>
<p>If we had written other algorithms on MAE, or had proven properties of MAE, they'd be applicable to SMAE, too. Hence desugaring is a way
of reusing code, proofs, ... . It is important, though, that the desugared language feature is gone after desugaring. For instance,
a pretty printer would print the desugared code. A debugger would use the desugared code. This can be an important downside to desugaring.
There are ways to avoid or mitigate these shortcomings, but they require additional work.
There is a second way of realizing desugaring which does not require the definition of a copy of the AST classes. We can desugar earlier,
namely during the construction of the AST:</p>
<pre><code class="language-scala">object SMAE2 {
  // Abstract Syntax Tree
  enum Exp:
    case Num(n: Int) extends Exp
    case Add(lhs: Exp, rhs: Exp) extends Exp
    case Mult(lhs: Exp, rhs: Exp) extends Exp
  object Exp:
    def sub(e1: Exp, e2: Exp) : Exp =
      Add(e1, Mult(Num(-1), e2))
  import Exp._

  // Compared to SMAE, we only have to change upper case Sub by lower case sub
  // when constructing examples.
  val ex = sub(Num(1), Mult(Num(5), Num(3)))

  // Interpreter - no case for sub needed
  def eval(e: Exp): Int =
    e match {
      case Num(n) =&gt; n
      case Add(lhs, rhs) =&gt; eval(lhs) + eval(rhs)
      case Mult(lhs, rhs) =&gt;  eval(lhs) * eval(rhs)
    }
}
</code></pre>
<p>Let us now consider the third extension, unary minus. Here we have three choices:</p>
<ol>
<li>Add unary minus to the core language</li>
<li>Treat unary minus as syntactic sugar for the core language using  <code>-x = (-1)*x</code></li>
<li>Treat unary minus as syntactic sugar on top of the syntactic sugar using <code>-x = 0 - x</code>.</li>
</ol>
<p>We will use the third option to illustrate that one can build layers of syntactic sugar:</p>
<pre><code class="language-scala">object USMAE {
  // Abstract Syntax Tree
  enum Exp:
    case Num(n: Int) extends Exp
    case Add(lhs: Exp, rhs: Exp) extends Exp
    case Mult(lhs: Exp, rhs: Exp) extends Exp
  object Exp:
    def sub(e1: Exp, e2: Exp) : Exp =
      Add(e1, Mult(Num(-1), e2))
    def unaryminus(e: Exp) = sub(Num(0), e)
  import Exp._

  // Compared to SMAE, we only have to change upper case Sub by lower case sub
  // when constructing examples.
  val ex = sub(unaryminus(Num(1)), Mult(Num(5), Num(3)))

  // Interpreter - no case for sub needed
  def eval(e: Exp): Int =
    e match {
      case Num(n) =&gt; n
      case Add(lhs, rhs) =&gt; eval(lhs) + eval(rhs)
      case Mult(lhs, rhs) =&gt;  eval(lhs) * eval(rhs)
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="name-binding"><a class="header" href="#name-binding">Name Binding</a></h1>
<p>The content of this chapter is available as a Scala file <a href="05-name-binding/./name-binding.scala">here.</a></p>
<pre><code class="language-scala">import scala.language.implicitConversions
</code></pre>
<h2 id="name-binding-1"><a class="header" href="#name-binding-1">Name Binding</a></h2>
<p>We want, step by step, to develop our primitive calculator language into a full-fledged PL.
One important milestone on this way is the ability to deal with names. While our previous language allowed expressions with identifiers
in them, it had no <em>binders</em>: Constructs that allow to give meaning to a new name.
In this variant of the language, called WAE, we introduce such a binder called &quot;with&quot; with which we can give an expression a name that
can be used in the body of the &quot;with&quot; expression. This intuition is captured in the  definition of the <code>With</code> case class below,
which extends our previous  language.
We study this WAE language to better understand what names mean in  programming languages, and how they can be implemented.</p>
<pre><code class="language-scala">object Syntax {
  enum Exp:
    case Num(n: Int) extends Exp
    case Add(lhs: Exp, rhs: Exp) extends Exp
    case Mul(lhs: Exp, rhs: Exp) extends Exp
    case Id(x: String) extends Exp
    case With(x: String, xdef: Exp, body: Exp) extends Exp
}
import Syntax._
import Exp._
</code></pre>
<p>We use implicits again to make example programs less verbose.</p>
<pre><code class="language-scala">implicit def num2exp(n: Int): Exp = Num(n)
implicit def string2exp(x: String): Exp = Id(x)
</code></pre>
<p>A first example program in WAE.</p>
<pre><code class="language-scala">val test = With(&quot;x&quot;, 5, Add(&quot;x&quot;,&quot;x&quot;))
</code></pre>
<p>Note that we deal with <em>two</em> languages here:</p>
<ol>
<li>This Scala file with Scala code.</li>
<li>Most of the functions work on programs written in the WAE language.</li>
</ol>
<p>Most of the time, we concentrate on WAE, but sometimes, we also talk about Scala.
We have not defined a concrete syntax for WAE, but it is a real language nevertheless. We sometimes use some made-up syntax for examples
on the blackboard or in comments.</p>
<h2 id="substitution"><a class="header" href="#substitution">Substitution</a></h2>
<p>Instead of dealing with identifiers as external entities as in AE, identifiers can now be defined within the language. This justifies a
new treatment of identifiers. We will explain them in terms of <em>substitution</em>, a notion well-known informally from high school algebra.
The idea is the following: The interpreter transforms the term</p>
<pre><code>  with (x = 5) {
    x + x
  }
</code></pre>
<p>into</p>
<pre><code>  5 + 5
</code></pre>
<p>before proceeding. That is, all occurrences of <code>x</code> have been replaced by <code>5</code>.
Note that these two programs -- before and after the substitution -- are certainly not <em>equal</em>: They look quite different. However,
they are <em>equivalent</em> in the sense that when evaluated, they will produce the same number. Such transformations between different but
somehow equivalent programs are an important tool for the study of programs, and of programming languages. Often, if we know which
programs behave identically, we understand better how programs behave in general. We will see more examples of this in this lecture.
Hence, the implementation of the <code>With</code> case of our interpreter should be something like:</p>
<pre><code>case With(x, xdef, body) =&gt; eval(subst(body,x,Num(eval(xdef))))
</code></pre>
<p>for a function <code>subst</code> with signature</p>
<pre><code>subst: (Exp,String,Num) =&gt; Exp
</code></pre>
<p>The type of the third parameter is <code>Num</code> instead of <code>Exp</code> because it is more difficult to get substitution correct when arbitrary
expressions can be inserted (accidential name capture problem, more about that later).
Since we want to experiment with different versions of substitution, we write the interpreter in such a way that we can parameterize
it with a substitution function:</p>
<pre><code class="language-scala">def makeEval(subst: (Exp,String,Num)=&gt;Exp) : Exp=&gt;Int = {
  def eval(e: Exp) : Int = e match {
    case Num(n) =&gt; n
    case Id(x) =&gt; sys.error(&quot;unbound variable: &quot; + x)
    case Add(l,r) =&gt; eval(l) + eval(r)
    case Mul(l,r) =&gt; eval(l) * eval(r)
    case With(x, xdef, body) =&gt; eval(subst(body,x,Num(eval(xdef)))) // take the int and wrap it into a Num
  }
  eval
}
</code></pre>
<h3 id="substitution-take-1"><a class="header" href="#substitution-take-1">Substitution, take 1</a></h3>
<p>To substitute identifier <code>i</code> in <code>e</code> with expression <code>v</code>, replace all identifiers in <code>e</code> that have the name <code>i</code> with the expression <code>v</code>.
Let's try to formalize this definition:</p>
<pre><code class="language-scala">val subst1 : (Exp,String,Num) =&gt; Exp = (e,i,v) =&gt; e match {
  case Num(n) =&gt; e
  case Id(x) =&gt; if (x == i) v else e
  case Add(l,r) =&gt; Add( subst1(l,i,v), subst1(r,i,v))
  case Mul(l,r) =&gt; Mul( subst1(l,i,v), subst1(r,i,v))
  case With(x,xdef,body) =&gt; With( if (x == i) v else x,
                                    subst1(xdef,i,v),
                                    subst1(body,i,v))
  }
</code></pre>
<p>Unfortunately this does not even type-check! And rightly so, because it might otherwise turn reasonable programs into programs that are
not even syntactically legal anymore.
Exercise for self-study: Find an expression that would be transformed into one that is not syntactically legal.
To see the reason for this, we need to define some terminology (the word &quot;instance&quot; here means &quot;occurence&quot;):</p>
<p><strong>Definition (Binding Instance)</strong>:
A binding instance of an identifier is the instance of the identifier that gives it its value. In WAE, the <code>x</code> position of a <code>With</code> is the only binding instance.</p>
<p><strong>Definition (Scope)</strong>:
The scope of a binding instance is the region of program text in which instances of the identifier refer to the value bound by the binding instance.</p>
<p><strong>Definition (Bound Instance)</strong>:
An identifier is bound if it is contained within the scope of a binding instance of its name.</p>
<p><strong>Definition (Free Instance)</strong>:
An identifier not contained in the scope of any binding instance of its name is said to be free.
Examples: In WAE, the String in <code>Id(&quot;x&quot;)</code> is a bound or free instance, and the String in <code>With(&quot;x&quot;, ..., ...)</code> is a binding instance.
The scope of this binding instance is the third sub-term of <code>With</code>.</p>
<p>Now the reason can be revealed.  Our first attempt failed because we substituted the identifier occurring in the binding position in the
with-expression.  This renders the expression illegal because after substitution the binding position where an identifier was expected
is now occupied by a Num.
To correct this mistake, we make another take at substitution:</p>
<h3 id="substitution-take-2"><a class="header" href="#substitution-take-2">Substitution, take 2</a></h3>
<p>To substitute identifier <code>i</code> in <code>e</code> with expression <code>v</code>, replace all identifiers in <code>e</code> which are not binding
instances that have the name <code>i</code> with the expression <code>v</code>.
Here is the formalization of this definition.</p>
<pre><code class="language-scala">val subst2 : (Exp,String,Num) =&gt; Exp = (e,i,v) =&gt; e match {
  case Num(n) =&gt; e

  // Bound or free instance =&gt; substitute if names match
  case Id(x) =&gt; if (x == i) v else e

  case Add(l,r) =&gt; Add( subst2(l,i,v), subst2(r,i,v))
  case Mul(l,r) =&gt; Mul( subst2(l,i,v), subst2(r,i,v))

  // binding instance =&gt; do not substitute
  case With(x,xdef,body) =&gt; With( x,
                                  subst2(xdef,i,v),
                                  subst2(body,i,v))
}
</code></pre>
<p>Let's create an interpreter that uses this substitution function.</p>
<pre><code class="language-scala">def eval2 = makeEval(subst2)

assert(eval2(test) == 10) // it works!

val test2 = With(&quot;x&quot;, 5, Add(&quot;x&quot;, With(&quot;x&quot;, 3, 10))) // another test

assert(eval2(test2) == 15) // works as expected

val test3 = With(&quot;x&quot;, 5, Add(&quot;x&quot;, With(&quot;x&quot;, 3, &quot;x&quot;))) // another test

// assert(eval2(test3) == 8) // Bang! Result is 10 instead!
</code></pre>
<p>What went wrong here? Our substitution algorithm respected binding instances, but not their scope. In the sample expression, the <code>With</code>
introduces a new scope for the inner <code>x</code>. The scope of the outer <code>x</code> is shadowed or masked by the inner binding. Because substitution
doesn’t recognize this possibility, it incorrectly substitutes the inner <code>x</code>.</p>
<h3 id="substitution-take-3"><a class="header" href="#substitution-take-3">Substitution, take 3</a></h3>
<p>To substitute identifier <code>i</code> in <code>e</code> with expression <code>v</code>, replace all non-binding identifiers in <code>e</code> having
the name <code>i</code> with the expression <code>v</code>, unless the identifier is in a scope different from that introduced by <code>i</code>.</p>
<pre><code class="language-scala">val subst3 : (Exp,String,Num) =&gt; Exp = (e,i,v) =&gt; e match {
    case Num(n) =&gt; e
    case Id(x) =&gt; if (x == i) v else e
    case Add(l,r) =&gt; Add( subst3(l,i,v), subst3(r,i,v))
    case Mul(l,r) =&gt; Mul( subst3(l,i,v), subst3(r,i,v))
    case With(x,xdef,body) =&gt; With( x,
                                    subst3(xdef,i,v),
                                    // what if we forget to substitute into the body?
                                    body)
}

def eval3 = makeEval(subst3)

assert(eval3(test) == 10)

assert(eval3(test2) == 15)

assert(eval3(test3) == 8) // Success!

val test4 = With(&quot;x&quot;, 5, Add(&quot;x&quot;, With(&quot;y&quot;, 3,&quot;x&quot;)))

// assert(eval3(test4) == 10) // Bang! unbound variable: &quot;x&quot;
</code></pre>
<p>The inner expression should result in an error, because <code>x</code> has no value. Once again, substitution has changed a correct program into
an incorrect one!
Let’s understand what went wrong. Why didn’t we substitute the inner <code>x</code>? Substitution halts at the <code>With</code> because, by definition, every
<code>With</code> introduces a new scope, which we said should delimit substitution. But this <code>With</code> contains an instance of <code>x</code>, which we very much
want substituted! So which is it - substitute within nested scopes or not? Actually, the two examples above should reveal that our
latest definition for substitution, which may have seemed sensible at first blush, is too draconian: it rules out substitution within
any nested scopes.</p>
<h3 id="substitution-take-4"><a class="header" href="#substitution-take-4">Substitution, take 4</a></h3>
<p>To substitute identifier <code>i</code> in <code>e</code> with expression <code>v</code>, replace all non-binding identifiers in <code>e</code> having
the name <code>i</code> with the expression <code>v</code>, except within nested scopes of <code>i</code>.
Finally, we have a version of substitution that works. A different, more succinct way of phrasing this definition is:
&quot;To substitute identifier <code>i</code> in <code>e</code> with expression <code>v</code>, replace all free instances of <code>i</code> in <code>e</code> with <code>v</code>.&quot;</p>
<pre><code class="language-scala">val subst4 : (Exp,String,Num) =&gt; Exp = (e,i,v) =&gt; e match {
    case Num(n) =&gt; e
    case Id(x) =&gt; if (x == i) v else e
    case Add(l,r) =&gt; Add( subst4(l,i,v), subst4(r,i,v))
    case Mul(l,r) =&gt; Mul( subst4(l,i,v), subst4(r,i,v))
    // do not substitute when shadowed
    case With(x,xdef,body) =&gt; if (x == i) e
                                 else With(x,
                                           subst4(xdef,i,v),
                                           subst4(body,i,v))
}

def eval4 = makeEval(subst4)

assert(eval4(test) == 10)

assert(eval4(test2) == 15)

assert(eval4(test3) == 8)

assert(eval4(test4) == 10) // Success!

val test5 = With(&quot;x&quot;, 5, With(&quot;x&quot;, &quot;x&quot;, &quot;x&quot;))

// assert(eval4(test5) == 5) // Bang! unbound variable &quot;x&quot;
</code></pre>
<p>This program should evaluate to <code>5</code>, but it too halts with an error. This is because we prematurely stopped substituting for <code>x</code> occuring in
a bound position. We should substitute in the named expression of a <code>With</code> even if the with in question defines a new scope for the identifier
being substituted, because its named expression is still in the scope of the enclosing binding of the identifier.</p>
<h3 id="substitution-take-5"><a class="header" href="#substitution-take-5">Substitution, take 5</a></h3>
<p>We finally get a valid
programmatic definition of substitution (relative to the language we have so far):</p>
<pre><code class="language-scala">val subst5 : (Exp,String,Num) =&gt; Exp = (e,i,v) =&gt; e match {
    case Num(n) =&gt; e
    case Id(x) =&gt; if (x == i) v else e
    case Add(l,r) =&gt; Add( subst5(l,i,v), subst5(r,i,v))
    case Mul(l,r) =&gt; Mul( subst5(l,i,v), subst5(r,i,v))
    // handle shadowing correctly
    case With(x,xdef,body) =&gt; With(x,
                                   subst5(xdef,i,v),
                                   if (x == i) body else subst5(body,i,v))
}

def eval5 = makeEval(subst5)

assert(eval5(test) == 10)

assert(eval5(test2) == 15)

assert(eval5(test3) == 8)

assert(eval5(test4) == 10)

assert(eval5(test5) == 5) // Success!
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ol>
<li>Substitution can be used to understand the meaning of names in programming languages.</li>
<li>Correct implementations of substitution need to handle free, bound, and binding instances of names and their scopes correctly.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-order-functions"><a class="header" href="#first-order-functions">First order functions</a></h1>
<p>The content of this chapter is available as a Scala file <a href="06-first-order-functions/./first-order-functions.scala">here.</a></p>
<h2 id="first-order-functions-1"><a class="header" href="#first-order-functions-1">First-Order Functions</a></h2>
<p>In the last lecture we have seen how we can give commonly occuring (sub)expressions a name via the <code>With</code> construct. Often, however,
we can identify <em>patterns</em> of expressions that occur in many places, such as <code>5*5/2</code>, <code>7*7/2</code> and <code>3*3/2</code>, the common pattern
being <code>x*x/2</code>. In this case, the abstraction capabilities of <code>With</code> are not sufficient.
One way to enable more powerful abstractions are <em>functions</em>. Depending on the context of use and the interaction with other language
features (such as imperative features or objects), functions are also sometimes called <em>procedures</em> or <em>methods</em>.
Here we consider so-called first-order functions, that - unlike higher-order functions - are not expressions and can hence not be passed
to or be returned from other functions. First-order functions are simply called by name.
To introduce first-order functions, we need two new things: The possibility to define functions, and the possibility to call functions.
A call to a function is an expression, whereas functions are defined separately. Functions can have an arbitrary number of arguments.
The following definitions are the language we have analyzed so far together with the new language constructs for first-order functions:</p>
<pre><code class="language-scala">object Syntax {
  enum Exp:
    case Num(n: Int) extends Exp
    case Add(lhs: Exp, rhs: Exp) extends Exp
    case Mul(lhs: Exp, rhs: Exp) extends Exp
    case Id(x: String) extends Exp
    case With(x: String, xdef: Exp, body: Exp) extends Exp

    /** The new language constructs for first-order functions: */
    case Call(f: String, args: List[Exp]) extends Exp // functions are called by name

  object Exp:
    /** The new language constructs for first-order functions: */
    case class FunDef(args: List[String], body: Exp)
    type Funs = Map[String,FunDef]

    /** We use implicits again to make example programs less verbose. */
    implicit def num2exp(n: Int): Exp = Num(n)
    implicit def string2exp(x: String): Exp = Id(x)
}
import Syntax._
import Exp._
</code></pre>
<p>A function has a number of formal args and a body. Note that a first-order function also
has a name. To make the invariant that there can only be one function for each
name explicit, we have stored functions in the form of a map from function names to
<code>FunDefs</code> above.</p>
<p>The substitution for the new language is a straightforward extension of the former one.</p>
<pre><code class="language-scala">def subst(e: Exp,i: String,v: Num) : Exp =  e match {
    case Num(n) =&gt; e
    case Id(x) =&gt; if (x == i) v else e
    case Add(l,r) =&gt; Add( subst(l,i,v), subst(r,i,v))
    case Mul(l,r) =&gt; Mul( subst(l,i,v), subst(r,i,v))
    case With(x,xdef,body) =&gt; With(x,
                                   subst(xdef,i,v),
                                   if (x == i) body else subst(body,i,v))
    case Call(f,args) =&gt; Call(f, args.map(subst(_,i,v)))
}
</code></pre>
<p>We will first study a &quot;reference interpreter&quot; based on substitution.
We pass the map of functions as an additional parameter.</p>
<pre><code class="language-scala">def eval(funs: Funs, e: Exp) : Int = e match {
  case Num(n) =&gt; n
  case Id(x) =&gt; sys.error(&quot;unbound identifier: &quot; + x)
  case Add(l,r) =&gt; eval(funs,l) + eval(funs,r)
  case Mul(l,r) =&gt; eval(funs,l) * eval(funs,r)
  case With(x, xdef, body) =&gt; eval(funs,subst(body,x,Num(eval(funs,xdef))))
  case Call(f,args) =&gt; {
     val fd = funs(f) // lookup function definition
     val vargs = args.map( eval(funs,_)) // evaluate function arguments
     if (fd.args.size != vargs.size) sys.error(&quot;number of paramters in call to &quot; + f + &quot; does not match&quot;)
     // We construct the function body to be evaluated by subsequently substituting all formal
     // arguments with their respective argument values.
     // If we have only a single argument &quot;fd.arg&quot; and a single argument value &quot;varg&quot;,
     // the next line of code is equivalent to:
     // val substbody = subst(fd.body, fd.arg, Num(varg))
     val substbody = fd.args.zip(vargs).foldLeft(fd.body)( (b,av) =&gt; subst(b,av._1,Num(av._2)) )
     eval(funs,substbody)
  }
}
</code></pre>
<p>Is the extension really so straightforward?  It can be seen in the last line of our
definition for <code>subst</code> that variable substitution deliberately ignores the function
name <code>f</code>. The substitution for <code>f</code> instead is handled separately inside <code>eval</code>.
We say in this case that function names and variable names live in different &quot;name spaces&quot;.
An alternative would be to have them share one namespace. As an exercise, think about how
to support a common namespace for function names and variable names.</p>
<p>A test case:</p>
<pre><code class="language-scala">val someFuns: Funs = Map( &quot;adder&quot; -&gt; FunDef(List(&quot;a&quot;,&quot;b&quot;), Add(&quot;a&quot;,&quot;b&quot;)),
                     &quot;doubleadder&quot; -&gt; FunDef(List(&quot;a&quot;,&quot;x&quot;), Add(Call(&quot;adder&quot;, List(&quot;a&quot;,5)),Call(&quot;adder&quot;, List(&quot;x&quot;,7)))))
</code></pre>
<pre><code class="language-scala">val callSomeFuns = eval(someFuns,Call(&quot;doubleadder&quot;,List(2,3)))
// callSomeFuns: Int = 17
assert( callSomeFuns == 17)
</code></pre>
<h3 id="the-scope-of-function-definitions"><a class="header" href="#the-scope-of-function-definitions">The scope of function definitions:</a></h3>
<p>As can be seen in the example above, each function can &quot;see&quot; the other functions. We say that in this language functions have a <em>global scope</em>.
Exercise: Can a function also invoke itself? Is this useful?
We will now study an environment-based version of the interpreter. To motivate environments, consider the following sample program:</p>
<pre><code class="language-scala">val testProg = With(&quot;x&quot;, 1, With(&quot;y&quot;, 2, With(&quot;z&quot;, 3, Add(&quot;x&quot;,Add(&quot;y&quot;,&quot;z&quot;)))))
</code></pre>
<p>When considering the <code>With</code> case of the interpreter, the interpreter will subsequently produce and evaluate the following intermediate expressions:</p>
<pre><code class="language-scala">val testProgAfterOneStep     = With(&quot;y&quot;, 2, With(&quot;z&quot;, 3, Add(1,Add(&quot;y&quot;,&quot;z&quot;))))
val testProgAfterTwoSteps    = With(&quot;z&quot;, 3, Add(1,Add(2,&quot;z&quot;)))
val testProgAfterThreeSteps  = Add(1,Add(2,3))
</code></pre>
<p>At this point only pure arithmetic is left. But we see that the interpreter had to apply subsitution three times. In general, if the
program size is n, then the interpreter may perform up to O(n) substitutions, each of which takes O(n) time. This quadratic complexity
seems rather wasteful. Can we do better?
We can avoid the redundancy by deferring the substitutions until they are really needed. Concretely, we define a repository of deferred
substitutions, called <em>environment</em>. It tells us which identifiers are supposed to be eventually substituted by which value. This idea
is captured in the following type definition:</p>
<pre><code class="language-scala">type Env = Map[String,Int]
</code></pre>
<p>Initially, we have no substitutions to perform, so the repository is empty. Every time we encounter a construct (a <code>With</code> or an application <code>Call</code>)
that requires substitution, we augment the repository with one more entry, recording the identifier’s name and the value (if eager) or
expression (if lazy) it should eventually be substituted with. We continue to evaluate without actually performing the substitution.
This strategy breaks a key invariant we had established earlier, which is that any identifier the interpreter could encounter must be
free, for had it been bound, it would have already been substituted.  Now that we’re longer using the substitution-based model, we may
encounter bound identifiers during interpretation.  How do we handle them?  We must substitute them by consulting the repository.</p>
<pre><code class="language-scala">def evalWithEnv(funs: Funs, env: Env, e: Exp) : Int = e match {
  case Num(n) =&gt; n
  case Id(x) =&gt; env(x) // look up in repository of deferred substitutions
  case Add(l,r) =&gt; evalWithEnv(funs,env,l) + evalWithEnv(funs,env,r)
  case Mul(l,r) =&gt; evalWithEnv(funs,env,l) * evalWithEnv(funs,env,r)
  case With(x, xdef, body) =&gt; evalWithEnv(funs,env + ((x,evalWithEnv(funs,env,xdef))),body)
  case Call(f,args) =&gt; {
     val fd = funs(f) // lookup function definition
     val vargs = args.map(evalWithEnv(funs,env,_)) // evaluate function arguments
     if (fd.args.size != vargs.size) sys.error(&quot;number of paramters in call to &quot; + f + &quot; does not match&quot;)
     // We construct the environment by associating each formal argument to its actual value
     val newenv = Map() ++ fd.args.zip(vargs)
     evalWithEnv(funs,newenv,fd.body)
  }
}

val evalEnvSomeFuns = evalWithEnv(someFuns,Map.empty, Call(&quot;doubleadder&quot;,List(2,3)))
// evalEnvSomeFuns: Int = 17
assert( evalEnvSomeFuns == 17)
</code></pre>
<p>In the interpreter above, we have extended the empty environment when constructing <code>newenv</code>. A conceivable alternative is to
extend <code>env</code> instead, like so:</p>
<pre><code class="language-scala">def evalDynScope(funs: Funs, env: Env, e: Exp) : Int = e match {
  case Num(n) =&gt; n
  case Id(x) =&gt; env(x)
  case Add(l,r) =&gt; evalDynScope(funs,env,l) + evalDynScope(funs,env,r)
  case Mul(l,r) =&gt; evalDynScope(funs,env,l) * evalDynScope(funs,env,r)
  case With(x, xdef, body) =&gt; evalDynScope(funs,env + ((x,evalDynScope(funs,env,xdef))),body)
  case Call(f,args) =&gt; {
     val fd = funs(f)
     val vargs = args.map(evalDynScope(funs,env,_))
     if (fd.args.size != vargs.size) sys.error(&quot;number of paramters in call to &quot;+ f + &quot; does not match&quot;)
     val newenv = env ++ fd.args.zip(vargs) // extending env instead of Map() !!
     evalDynScope(funs,newenv,fd.body)
  }
}

val evalDynSomeFuns = evalDynScope(someFuns,Map.empty, Call(&quot;doubleadder&quot;,List(2,3)))
// evalDynSomeFuns: Int = 17
assert( evalDynSomeFuns == 17)
</code></pre>
<p>Does this make a difference? Yes, it does. Here is an example:</p>
<pre><code class="language-scala">val funnyFun: Funs = Map( &quot;funny&quot; -&gt; FunDef(List(&quot;a&quot;), Add(&quot;a&quot;,&quot;b&quot;)))
</code></pre>
<pre><code class="language-scala">val evalDynFunnyFun = evalDynScope(funnyFun, Map.empty, With(&quot;b&quot;, 3, Call(&quot;funny&quot;,List(4))))
// evalDynFunnyFun: Int = 7
assert(evalDynFunnyFun == 7)
</code></pre>
<p>Obviously this interpreter is &quot;buggy&quot; in the sense that it does not agree with the substitution-based interpreter. But is this semantics reasonable?
Let's introduce some terminology to make the discussion simpler:</p>
<blockquote>
<p><strong>Definition (Static Scope)</strong>:
In a language with static scope, the scope of an identifier’s binding is a syntactically delimited region.
A typical region would be the body of a function or other binding construct.</p>
</blockquote>
<blockquote>
<p><strong>Definition (Dynamic Scope)</strong>: In a language with dynamic scope, the scope of an identifier’s binding is the entire remainder of the
execution during which that binding is in effect.</p>
</blockquote>
<p>We see that <code>eval</code> and <code>evalWithEnv</code> give our language static scoping, whereas <code>evalDynScope</code> gives our language dynamic scoping.
Armed with this terminology, we claim that dynamic scope is entirely unreasonable. The problem is that we simply cannot determine what
the value of a program will be without knowing everything about its execution history. If a function <code>f</code> were invoked by some
sequence of other functions that did not bind a value for some parameter of <code>f</code>, then that particular application of <code>f</code> would result in an error, even though a
previous application of <code>f</code> in the very same program’s execution may have completed successfully! In other words, simply by looking at the
source text of <code>f</code>, it would be impossible to determine one of the most rudimentary properties of a program: whether or not a given
identifier was bound. You can only imagine the mayhem this would cause in a large software system, especially with multiple developers
and complex ﬂows of control. We will therefore regard dynamic scope as an error. That said, there are facets of dynamic binding
that are quite useful. For instance, exception handlers are typically dynamically scoped: A thrown exception is dispatched to the
most recently encountered active exception handler for that exception type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher order functions</a></h1>
<p>The content of this chapter is available as a Scala file <a href="07-higher-order-functions/./higher-order-functions.scala">here.</a></p>
<h1 id="higher-order-functions-1"><a class="header" href="#higher-order-functions-1">Higher-Order Functions</a></h1>
<p>F1WAE, the language with first-order functions, lets us abstract over patterns that involve numbers. But what if we want to abstract
over patterns that involve functions, such as the &quot;list fold&quot; pattern, whose instantiations include summing or multiplying a list of
integers?</p>
<p>To enable this kind of abstraction, we need to make functions &quot;first-class&quot;, which means that they become values that can be passed to
or returned from functions or stored in data structures. Languages with first-class functions enable so-called &quot;higher-order functions&quot;,
which are functions that accept or return a (possibly again higher-order) function.</p>
<p>We will see that this extension will make our language both simpler and much more powerful. This seeming contradiction is famously
addressed by the first sentence of the Scheme language specification:</p>
<blockquote>
<p>&quot;Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that
make additional features appear necessary.&quot;</p>
</blockquote>
<p>The simplicity is due to the fact that this language is so expressive that many other language features can be &quot;encoded&quot;, i.e., they do
not need to be added to the language but can be expressed with the existing features.</p>
<p>This language, which we call &quot;FAE&quot;, is basically the so-called &quot;lambda calculus&quot;, a minimal but powerful programming language that has
been highly influential in the design and theory of programming languages.</p>
<p>FAE is the language of arithmetic expressions, AE, plus only two additional language constructs: Function abstraction and function application.</p>
<pre><code class="language-scala">object Syntax {
  enum Exp:
    case Num(n: Int)
    case Id(name: String)
    case Add(lhs: Exp, rhs: Exp)

    // Both function definitions and applications are expressions.
    case Fun(param: String, body: Exp)
    case Ap(funExpr: Exp, argExpr: Exp)

  object Exp:
    implicit def num2exp(n: Int): Exp = Num(n)
    implicit def id2exp(s: String): Exp = Id(s)
    // &quot;with&quot; would be a better name for this function, but it is reserved in Scala
    def wth(x: String, xdef: Exp, body: Exp) : Exp = Ap(Fun(x,body),xdef)
}

import Syntax._
import Exp._
</code></pre>
<p>Due to the lambda calculus, the concrete syntax for function abstraction is often written
with a lambda, such as <code>lambda x. x+3</code>, thus also called lambda abstraction. The Scala
syntax for lambda terms is <code>(x) =&gt; x+3</code>, the Haskell syntax is <code>\x -&gt; x+3</code>.</p>
<p>The concrete syntax for function application is often either juxtaposition <code>f a</code> or
using brackets <code>f(a)</code>. Haskell and the lambda calculus use the former, Scala uses the
latter.</p>
<p>The <code>with</code> construct is not needed anymore since it can be encoded using <code>Ap</code> and
<code>Fun</code>. For instance, <code>with x = 7 in x+3</code> can be encoded (using Scala syntax) as
<code>((x) =&gt; x+3)(7)</code>. We have made this idea explicit above by giving a constructive
translation. Remember that such translations are often called &quot;desugaring&quot;.</p>
<p>Like for F1WAE, we will at first define the meaning of FAE in terms of substitution. Here is the substitution function for FAE.</p>
<pre><code class="language-scala">def subst0(e1 : Exp, x: String, e2: Exp) : Exp = e1 match {
  case Num(n) =&gt; e1
  case Add(l,r) =&gt; Add(subst0(l,x,e2), subst0(r,x,e2))
  case Id(y) =&gt; if (x == y) e2 else Id(y)
  case Ap(f,a) =&gt; Ap(subst0(f,x,e2), subst0(a,x,e2))
  case Fun(param,body) =&gt;
    if (param == x) e1  else Fun(param, subst0(body, x, e2))
}
</code></pre>
<p>Let's try whether <code>subst0</code> produces reasonable results.</p>
<pre><code class="language-scala">assert( subst0(Add(5,&quot;x&quot;), &quot;x&quot;, 7) == Add(5, 7))
assert( subst0(Add(5,&quot;x&quot;), &quot;y&quot;, 7) == Add(5,&quot;x&quot;))
assert( subst0(Fun(&quot;x&quot;, Add(&quot;x&quot;,&quot;y&quot;)), &quot;x&quot;, 7) == Fun(&quot;x&quot;, Add(&quot;x&quot;,&quot;y&quot;)))
</code></pre>
<p>Looks good. However, what happens if <code>e2</code> contains free variables? The danger here is that they may be accidentially &quot;captured&quot; by the substitution.
For instance, consider</p>
<pre><code class="language-scala">val subst0Test = subst0(Fun(&quot;x&quot;, Add(&quot;x&quot;,&quot;y&quot;)), &quot;y&quot;, Add(&quot;x&quot;,5))
// subst0Test: Exp = Fun(
//   param = &quot;x&quot;,
//   body = Add(
//     lhs = Id(name = &quot;x&quot;),
//     rhs = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 5))
//   )
// )
</code></pre>
<p>The result is <code>Fun(&quot;x&quot;,Add(&quot;x&quot;,Add(&quot;x&quot;,5)))</code>
This is not desirable, since it again violates static scoping.</p>
<p>Note that this problem did not show up in earlier languages, because there we only substituted variables by numbers, but not by
expressions that may contain free variables: The type of <code>e2</code> was <code>Num</code> and not <code>Exp</code>.</p>
<p>Hence we are still not done with defining substitution. But what is the desired result of the substitution above?
The answer is that we must avoid the name clash by renaming the variable bound by the &quot;lambda&quot; if the variable name occurs free in <code>e2</code>.
This new variable name should be &quot;fresh&quot;, i.e., not occur free in <code>e2</code>.</p>
<p>For instance, in the example above, we could first rename <code>&quot;x&quot;</code> to the fresh name <code>&quot;x0&quot;</code> and only then substitute, i.e.</p>
<p><code>subst(Fun(&quot;x&quot;, Add(&quot;x&quot;,&quot;y&quot;)), &quot;y&quot;, Add(&quot;x&quot;,5)) == Fun(&quot;x0&quot;,Add(&quot;x0&quot;,Add(&quot;x&quot;,Num(5))))</code></p>
<p>Let's do this step by step.</p>
<pre><code class="language-scala">def freshName(names: Set[String], default: String) : String = {
  var last : Int = 0
  var freshName = default
  while (names contains freshName) { freshName = default+last; last += 1; }
  freshName
}

val freshNameExa1 = freshName(Set(&quot;y&quot;,&quot;z&quot;),&quot;x&quot;)
// freshNameExa1: String = &quot;x&quot;
val freshNameExa2 = freshName(Set(&quot;x2&quot;,&quot;x0&quot;,&quot;x4&quot;,&quot;x&quot;,&quot;x1&quot;),&quot;x&quot;)
// freshNameExa2: String = &quot;x3&quot;
assert( freshNameExa1 == &quot;x&quot;)
assert( freshNameExa2 == &quot;x3&quot;)

def freeVars(e: Exp) : Set[String] =  e match {
   case Id(x) =&gt; Set(x)
   case Add(l,r) =&gt; freeVars(l) ++ freeVars(r)
   case Fun(x,body) =&gt; freeVars(body) - x
   case Ap(f,a) =&gt; freeVars(f) ++ freeVars(a)
   case Num(n) =&gt; Set.empty
}

val freeVarsExa = freeVars(Fun(&quot;x&quot;,Add(&quot;x&quot;,&quot;y&quot;)))
// freeVarsExa: Set[String] = Set(&quot;y&quot;)
assert(freeVarsExa == Set(&quot;y&quot;))

def subst(e1 : Exp, x: String, e2: Exp) : Exp = e1 match {
  case Num(n) =&gt; e1
  case Add(l,r) =&gt; Add(subst(l,x,e2), subst(r,x,e2))
  case Id(y) =&gt; if (x == y) e2 else Id(y)
  case Ap(f,a) =&gt; Ap(subst(f,x,e2),subst(a,x,e2))
  case Fun(param,body) =&gt;
    if (param == x) e1 else {
      val fvs = freeVars(Fun(param,body)) ++ freeVars(e2) + x
      val newvar = freshName(fvs, param)
      Fun(newvar, subst(subst(body, param, Id(newvar)), x, e2))
    }
}

assert( subst(Add(5,&quot;x&quot;), &quot;x&quot;, 7) == Add(5, 7))
assert( subst(Add(5,&quot;x&quot;), &quot;y&quot;, 7) == Add(5,&quot;x&quot;))
assert( subst(Fun(&quot;x&quot;, Add(&quot;x&quot;,&quot;y&quot;)), &quot;x&quot;, 7) == Fun(&quot;x&quot;, Add(&quot;x&quot;,&quot;y&quot;)))
// test capture-avoiding substitution
assert( subst(Fun(&quot;x&quot;, Add(&quot;x&quot;,&quot;y&quot;)), &quot;y&quot;, Add(&quot;x&quot;,5)) == Fun(&quot;x0&quot;,Add(Id(&quot;x0&quot;),Add(Id(&quot;x&quot;),Num(5)))))
assert( subst(Fun(&quot;x&quot;, Add(Id(&quot;x0&quot;), Id(&quot;y&quot;))), &quot;y&quot;, Add(Id(&quot;x&quot;), 5)) == Fun(&quot;x1&quot;, Add(Id(&quot;x0&quot;), Add(Id(&quot;x&quot;), Num(5)))) )
</code></pre>
<p>OK, equipped with this new version of substitution we can now define the interpreter for this language.
But how do we evaluate a function abstraction? Obviously we cannot return a number.</p>
<p>We realize that functions are also values! Hence we have to broaden the return type of our evaluator to also allow functions as values.
For simplicity, we use <code>Exp</code> as our return type since it allows us to return both numbers and functions. Later we will become more
sophisticated.</p>
<p>This means that a new class of errors can occur: A subexpression evaluates to a number where a function is expected, or vice versa.
Such errors are called <em>type errors</em>, and we will talk about them in much more detail later.</p>
<p>For now, it means that we need to analyze (typically by pattern matching) the result of recursive invocations of eval to check whether the result has the right type.</p>
<p>The remainder of the interpreter is unsurprising:</p>
<pre><code class="language-scala">def eval(e: Exp) : Exp = e match {
  case Id(v) =&gt; sys.error(&quot;unbound identifier: &quot; + v)
  case Add(l,r) =&gt; (eval(l), eval(r)) match {
                     case (Num(x),Num(y)) =&gt; Num(x+y)
                     case _ =&gt; sys.error(&quot;can only add numbers&quot;)
                    }
  case Ap(f,a) =&gt; eval(f) match {
     case Fun(x,body) =&gt; eval( subst(body,x, eval(a)))  // call-by-value
     // case Fun(x,body) =&gt; eval( subst(body,x, a))        // call-by-name
     case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  }
  case _ =&gt; e // numbers and functions evaluate to themselves
}
</code></pre>
<p>We can also make the return type more precise to verify the invariant  that numbers and functions are the only values.</p>
<pre><code class="language-scala">def eval2(e: Exp) : Either[Num,Fun] = e match {
  case Id(v) =&gt; sys.error(&quot;unbound identifier: &quot; + v)
  case Add(l,r) =&gt; (eval2(l), eval2(r)) match {
                     case (Left(Num(x)),Left(Num(y))) =&gt; Left(Num(x+y))
                     case _ =&gt; sys.error(&quot;can only add numbers&quot;)
                    }
  case Ap(f,a) =&gt; eval2(f) match {
     case Right(Fun(x,body)) =&gt; eval2( subst(body,x, eval(a)))
     case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  }
  case f@Fun(_,_) =&gt; Right(f)
  case n@Num(_) =&gt; Left(n)
}
</code></pre>
<p>Let's test:</p>
<pre><code class="language-scala">val test = Ap( Fun(&quot;x&quot;,Add(&quot;x&quot;,5)), 7)
assert( eval(test) == Num(12))
</code></pre>
<p>FAE is a computationally (Turing)-complete language. For instance, we can define  a non-terminating program. This program is commonly
called Omega:</p>
<pre><code class="language-scala">val omega = Ap(Fun(&quot;x&quot;,Ap(&quot;x&quot;,&quot;x&quot;)), Fun(&quot;x&quot;,Ap(&quot;x&quot;,&quot;x&quot;)))
// try eval(omega) to crash the interpreter ;-)
</code></pre>
<p>Omega can be extended to yield a fixed point combinator, which can be used to encode arbitrary recursive functions. We'll come back to
this topic later.</p>
<p>Let's now discuss what an environment-based version of this interpreter looks like.
Here is a first attempt:</p>
<pre><code class="language-scala">type Env0 = Map[String, Exp]

def evalWithEnv0(e: Exp, env: Env0) : Exp = e match {
  case Id(x) =&gt; env(x)
  case Add(l,r) =&gt; {
    (evalWithEnv0(l,env), evalWithEnv0(r,env)) match {
      case (Num(v1),Num(v2)) =&gt; Num(v1+v2)
      case _ =&gt; sys.error(&quot;can only add numbers&quot;)
    }
  }
  case Ap(f,a) =&gt; evalWithEnv0(f,env) match {
    case Fun(x,body) =&gt; evalWithEnv0(body, Map(x -&gt; evalWithEnv0(a,env)))
    case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  }
  case _ =&gt; e // numbers and functions evaluate to themselves
}

assert( evalWithEnv0(test, Map.empty) == Num(12))
</code></pre>
<p>However, consider the following example:</p>
<pre><code class="language-scala">val test2 = wth(&quot;x&quot;, 5, Ap(Fun(&quot;f&quot;, Ap(&quot;f&quot;,3)), Fun(&quot;y&quot;,Add(&quot;x&quot;,&quot;y&quot;))))
</code></pre>
<p>It works fine in the substitution-based interpreter,</p>
<pre><code class="language-scala">val evalTest2 = eval(test2)
// evalTest2: Exp = Num(n = 8)
assert(evalTest2 == Num(8))
</code></pre>
<p>but</p>
<pre><code class="language-scala">val evalEnv0Test2 = evalWithEnv0(test2,Map.empty)
// java.util.NoSuchElementException: key not found: x
// 	at scala.collection.immutable.Map$Map1.apply(Map.scala:245)
// 	at repl.MdocSession$App.evalWithEnv0(higher-order-functions.md:208)
// 	at repl.MdocSession$App.evalWithEnv0(higher-order-functions.md:210)
// 	at repl.MdocSession$App.evalWithEnv0(higher-order-functions.md:216)
// 	at repl.MdocSession$App.evalWithEnv0(higher-order-functions.md:216)
// 	at repl.MdocSession$App.evalWithEnv0(higher-order-functions.md:216)
// 	at repl.MdocSession$App.$init$$$anonfun$1(higher-order-functions.md:248)
// 	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
</code></pre>
<p>yields a <code>key not found: x</code> error.
The problem is that we have forgotten the deferred substitutions to be performed in the body of the function.</p>
<p>What can we do to fix this problem?
We could try to replace the second line in the &quot;Ap&quot; case by</p>
<pre><code>case Fun(x,body) =&gt; evalWithEnv0(body, env + (x -&gt; evalWithEnv0(a,env)))
</code></pre>
<p>but this would again introduce dynamic scoping.</p>
<p>Hence, when we evaluate a function, we do not only have to store the function, but also the environment active when the function was
created. This pair of function and environment is called a <em>closure</em>. The environment stored in the closure is used when the function
is eventually applied.</p>
<p>Hint: If you cannot answer what a closure is and how it is used in the  interpreter, you will be toast in the exam!
Since closures are not expressible in the language syntax, we now come to the point where we need a separate category of <em>values</em>.
The values in FAE can be either numbers or closures.</p>
<pre><code class="language-scala">sealed abstract class Value
type Env = Map[String, Value]
case class NumV(n: Int) extends Value
case class ClosureV(f: Fun, env: Env) extends Value
</code></pre>
<p>The evaluator becomes :</p>
<pre><code class="language-scala">def evalWithEnv(e: Exp, env: Env) : Value = e match {
  case Num(n: Int) =&gt; NumV(n)
  case Id(x) =&gt; env(x)
  case Add(l,r) =&gt; {
    (evalWithEnv(l,env), evalWithEnv(r,env)) match {
      case (NumV(v1),NumV(v2)) =&gt; NumV(v1+v2)
      case _ =&gt; sys.error(&quot;can only add numbers&quot;)
    }
  }
  case f@Fun(param,body) =&gt; ClosureV(f, env)
  case Ap(f,a) =&gt; evalWithEnv(f,env) match {
    // Use environment stored in closure to realize proper lexical scoping!
    case ClosureV(f,closureEnv) =&gt; evalWithEnv(f.body, closureEnv + (f.param -&gt; evalWithEnv(a,env)))
    case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  }
}
assert( evalWithEnv(test, Map.empty) == NumV(12))
assert( evalWithEnv(test2,Map.empty) == NumV(8))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lazy-evaluation"><a class="header" href="#lazy-evaluation">Lazy Evaluation</a></h1>
<p>The content of this chapter is available as a Scala file <a href="08-lazy-evaluation/./lazy-evaluation.scala">here.</a></p>
<h2 id="motivation-for-lazy-evaluation"><a class="header" href="#motivation-for-lazy-evaluation">Motivation for Lazy Evaluation</a></h2>
<p>Read &quot;Why Functional Programming Matters&quot; by John Hughes available at http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html</p>
<p>What lazy evaluation means:</p>
<p>The choice of evaluation strategy is a purely semantic change that requires no change to the syntax.
For this reason we reuse the syntactic definitions of FAE, hence load
<a href="08-lazy-evaluation/../07-higher-order-functions/higher-order-functions.scala">higher-order-functions.scala</a>
before executing this script.
Before we discuss lazy evaluation, we will first discuss a related evaluation strategy, <em>call-by-name</em>.</p>
<p><em>Call-by-name</em> can be explained very succintly in the substitution-based interpreter: Instead of evaluating the argument <code>a</code> in the
<code>Ap</code> case before substitution, we substitute the unevaluated argument into the body. The rest remains exactly the same.</p>
<pre><code class="language-scala">def evalcbn(e: Exp) : Exp = e match {
  case Id(v) =&gt; sys.error(&quot;unbound identifier: &quot; + v)
  case Add(l,r) =&gt; (evalcbn(l), evalcbn(r)) match {
                     case (Num(x),Num(y)) =&gt; Num(x+y)
                     case _ =&gt; sys.error(&quot;can only add numbers&quot;)
                    }
  case Ap(f,a) =&gt; evalcbn(f) match {
     case Fun(x,body) =&gt; evalcbn( subst(body,x, a)) // no evaluation of a!
     case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  }
  case _ =&gt; e
}
</code></pre>
<p>Does this change the semantics, or is it just an implementation detail? In other words, is <code>eval(e) == evalcbn(e)</code> for all <code>e</code> ?
Let's try two former test cases.</p>
<pre><code class="language-scala">assert(evalcbn(test) == eval(test))
assert(evalcbn(test2) == eval(test2))
</code></pre>
<p>One can formally prove that if <code>eval</code> and <code>evalcbn</code> both produce a number then the numbers are equal. Do they also agree if they produce
a function?
Not necessarily. Consider:</p>
<pre><code class="language-scala">val test3 = Ap(Fun(&quot;f&quot;,Fun(&quot;x&quot;,Ap(&quot;f&quot;,&quot;x&quot;))),Add(1,2))

assert(eval(test3) == Fun(&quot;x&quot;,Ap(Num(3),Id(&quot;x&quot;))))
assert(evalcbn(test3) == Fun(&quot;x&quot;,Ap(Add(Num(1),Num(2)),Id(&quot;x&quot;))))
</code></pre>
<p>However, if both produce a function, then the functions &quot;behave&quot; the same. More specifically, the function bodies produced by <code>eval</code>
may be &quot;more evaluated&quot; than those produced by <code>evalcbn</code> since for the latter the evaluation of the arguments substituted for the parameters
in the body is deferred. If we evaluated within function bodies (also called evaluation &quot;under a
lambda&quot;) - which our interpreters do not do - we could produce the expression returned from <code>eval</code> from the expression returned by <code>evalcbn</code>.
This kind of equivalence is also called &quot;beta-equivalence&quot;.</p>
<p>Most importantly, however, <code>eval</code> and <code>evalcbn</code> differ with regard to their termination behavior. We have seen that <code>omega</code> is a diverging
expression. In <code>eval</code>, the term</p>
<pre><code class="language-scala"> val test4 = Ap(Fun(&quot;x&quot;,5),omega)
</code></pre>
<p>is hence also diverging. In contrast:</p>
<pre><code class="language-scala">assert(evalcbn(test4) == Num(5))
</code></pre>
<h2 id="extra-material-infinite-lists-in-fae-not-relevant-for-exam"><a class="header" href="#extra-material-infinite-lists-in-fae-not-relevant-for-exam">Extra material: Infinite lists in FAE (not relevant for exam)</a></h2>
<p>Using our call-by-name interpreter, we can express the same kinds of programming patterns that we have tried in Haskell, such as
infinite lists.</p>
<p>We do not have direct support for lists, but we can encode lists. This kind of encoding is called <em>Church encoding</em>.</p>
<pre><code class="language-scala">val nil = Fun(&quot;c&quot;, Fun(&quot;e&quot;, &quot;e&quot;))
val cons  = Fun(&quot;x&quot;, Fun(&quot;xs&quot;, Fun(&quot;c&quot;, Fun(&quot;e&quot;, Ap(Ap(&quot;c&quot;, &quot;x&quot;), Ap(Ap(&quot;xs&quot;, &quot;c&quot;),&quot;e&quot;))))))
</code></pre>
<p>For instance, the list 1,2,3 is encoded as:</p>
<pre><code class="language-scala">val list123 = Ap(Ap(&quot;cons&quot;,1),Ap(Ap(&quot;cons&quot;,2),Ap(Ap(&quot;cons&quot;,3), &quot;nil&quot;)))
</code></pre>
<p>The map function on lists becomes :</p>
<pre><code class="language-scala">val maplist = Fun(&quot;f&quot;, Fun(&quot;l&quot;, Ap(Ap(&quot;l&quot;, Fun(&quot;x&quot;, Fun(&quot;xs&quot;, Ap(Ap(&quot;cons&quot;, Ap(&quot;f&quot;,&quot;x&quot;)),&quot;xs&quot;)))), &quot;nil&quot;)))
</code></pre>
<p>For instance, we can map the successor function over the 1,2,3 list.</p>
<pre><code class="language-scala">val test5 = wth(&quot;cons&quot;,cons,
            wth(&quot;nil&quot;, nil,
            wth(&quot;maplist&quot;, maplist,
            Ap(Ap(&quot;maplist&quot;, Fun(&quot;x&quot;, Add(&quot;x&quot;,1))), list123))))
</code></pre>
<p>Since it is somewhat difficult to print out the resulting list in our primitive language we construct the result we expect explicitly.</p>
<pre><code class="language-scala">val test5res = wth(&quot;cons&quot;,cons,
               wth(&quot;nil&quot;, nil,
                 Ap(Ap(&quot;cons&quot;,2),Ap(Ap(&quot;cons&quot;,3),Ap(Ap(&quot;cons&quot;,4), &quot;nil&quot;)))))
assert(eval(test5) == eval(test5res))
</code></pre>
<p>Using <code>evalcbn</code> instead of <code>eval</code> the assertion does not hold (why?), but the results are beta-equivalent.
We can also construct infinite lists. To this end, we need some form of recursion. We choose the standard fixed-point operator Y.
This operator only works under call-by-name or other so-called &quot;non-strict&quot; evaluation strategies.</p>
<pre><code class="language-scala">val y = Fun(&quot;f&quot;, Ap(Fun(&quot;x&quot;,Ap(&quot;f&quot;, Ap(&quot;x&quot;,&quot;x&quot;))), Fun(&quot;x&quot;,Ap(&quot;f&quot;,Ap(&quot;x&quot;,&quot;x&quot;)))))
</code></pre>
<p>Using Y, we can construct infinite lists, such as the list of all natural numbers.</p>
<pre><code class="language-scala">val allnats = Ap(Ap(&quot;y&quot;, Fun(&quot;nats&quot;, Fun(&quot;n&quot;, Ap(Ap(&quot;cons&quot;,&quot;n&quot;), Ap(&quot;nats&quot;, Add(&quot;n&quot;,1)))))),1)
</code></pre>
<p>We can also perform standard computations on infinite lists, such as mapping the successor function over it.</p>
<pre><code class="language-scala">val list2toinfty = wth(&quot;cons&quot;,cons,
                   wth(&quot;nil&quot;, nil,
                   wth(&quot;y&quot;, y,
                   wth(&quot;maplist&quot;, maplist,
                      Ap(Ap(&quot;maplist&quot;, Fun(&quot;x&quot;, Add(&quot;x&quot;,1))), allnats)))))
</code></pre>
<p>Of course, <code>list2toinfty</code> diverges when we use <code>eval</code>, but it works fine with <code>evalcbn</code>. It is hard to verify the result due to
an almost unreadable output. Hence we propose the following</p>
<p>Exercise: Extend the language such that you can implement the &quot;take&quot; function as known from Haskell within the language
(if0-expressions or something like it are needed for that). Now add a &quot;print&quot; function that prints a number on the console.
Use it to display that the first 3 list elements of <code>list2toinfty</code> are 2,3,4.</p>
<p><em>end of extra material</em></p>
<h2 id="environment-based-lazy-evaluation"><a class="header" href="#environment-based-lazy-evaluation">Environment-based lazy evaluation</a></h2>
<p>Let us now consider the question how we can implement call-by-name in the environment-based interpreter. Translating the idea of not
evaluating the function argument to the environment-based version seems to  suggest that the environment should map identifiers to
expression instead of values.</p>
<p>However, we run into the same problems that we had with first-class functions before we introduced closures: What happens to the
deferred substitutions that still have to be applied in the function argument? If we discard the environment in which the function
argument was defined we again introduce a variant of dynamic scoping.</p>
<p>Hence, like for closures, we need to store the environment together with the expression. We call such a  pair a <em>thunk</em>. An environment
hence becomes a mapping from symbols to thunks. Note that environments and thunks are hence mutually recursive. In Scala, we can hence
not use type definitions of the form</p>
<pre><code>   type Thunk = (Exp, Env)
   type Env = Map[String, Thunk]
</code></pre>
<p>Instead, we use a Scala class Env to express this recursion.
Since we want to experiment with different variants of how to generate and evaluate thunks we first create a parameterizable variant
of the evaluator that leaves open how to</p>
<ol>
<li>represent thunks (type <code>Thunk</code>)</li>
<li>create thunks (method <code>delay</code>)</li>
<li>evaluate thunks (method <code>force</code>).
<strong>Hint</strong>: Research on the internet what abstract type members in Scala are. For instance, here: http://www.scala-lang.org/node/105</li>
</ol>
<pre><code class="language-scala">trait CBN {
    type Thunk

    case class EnvThunk(map: Map[String, Thunk]) {
      def apply(key: String) = map.apply(key)
      def +(other: (String, Thunk)) : EnvThunk = EnvThunk(map+other)
    }

    def delay(e: Exp, env: EnvThunk) : Thunk
    def force(t: Thunk) : ValueCBN

    // since values also depend on EnvThunk and hence on Thunk they need to
    // be defined within this trait
    sealed abstract class ValueCBN
    case class NumV(n: Int) extends ValueCBN
    case class ClosureV(f: Fun, env: EnvThunk) extends ValueCBN
    def evalCBN(e: Exp, env: EnvThunk) : ValueCBN = e match {
      case Id(x) =&gt; force(env(x)) // force evaluation of thunk if identifier is evaluated
      case Add(l,r) =&gt; {
        (evalCBN(l,env), evalCBN(r,env)) match {
          case (NumV(v1),NumV(v2)) =&gt; NumV(v1+v2)
          case _ =&gt; sys.error(&quot;can only add numbers&quot;)
        }
      }
      case Ap(f,a) =&gt; evalCBN(f,env) match {
        // delay argument expression and add it to environment of the closure
        case ClosureV(f,cenv) =&gt; evalCBN(f.body, cenv + (f.param -&gt; delay(a,env)))
        case _ =&gt; sys.error(&quot;can only apply functions&quot;)
      }
      case Num(n) =&gt; NumV(n)
      case f@Fun(x,body) =&gt; ClosureV(f,env)
    }
}
</code></pre>
<p>Let's now create an instance of CBN that corresponds to the substitution-based call-by-name interpreter. A thunk is just a pair
of expression and environment. Forcing a thunk just evaluates it in the stored environment.
To understand what is going on during evaluation of tests we trace argument evaluation by a  printout to the console.</p>
<pre><code class="language-scala">object CallByName extends CBN {
  type Thunk = (Exp,EnvThunk)
  def delay(e: Exp, env: EnvThunk) = (e,env)
  def force(t: Thunk) = {
    println(&quot;Forcing evaluation of expression: &quot;+t._1)
    evalCBN(t._1,t._2)
  }
}

assert(CallByName.evalCBN(test, CallByName.EnvThunk(Map.empty)) == CallByName.NumV(12))
// Forcing evaluation of expression: Num(7)
</code></pre>
<h2 id="call-by-need"><a class="header" href="#call-by-need">Call-by-need</a></h2>
<p>Call-by-name is rather wasteful: If an argument is used <em>n</em> times in the body, the argument expression is re-evaluated <em>n</em>-times.
For instance, in</p>
<pre><code class="language-scala">val cbntest = wth(&quot;double&quot;, Fun(&quot;x&quot;, Add(&quot;x&quot;,&quot;x&quot;)),
               Ap(&quot;double&quot;, Add(2,3)))
</code></pre>
<p>the sum of 2 and 3 is computed twice.  If the argument is passed again to another function, this may lead to an exponential blow-up.</p>
<p>Example:</p>
<pre><code class="language-mdoc:silent">val blowup  = wth(&quot;a&quot;, Fun(&quot;x&quot;, Add(&quot;x&quot;,&quot;x&quot;)),
              wth(&quot;b&quot;, Fun(&quot;x&quot;, Add(Ap(&quot;a&quot;,&quot;x&quot;), Ap(&quot;a&quot;,&quot;x&quot;))),
              wth(&quot;c&quot;, Fun(&quot;x&quot;, Add(Ap(&quot;b&quot;,&quot;x&quot;), Ap(&quot;b&quot;,&quot;x&quot;))),
              wth(&quot;d&quot;, Fun(&quot;x&quot;, Add(Ap(&quot;c&quot;,&quot;x&quot;), Ap(&quot;c&quot;,&quot;x&quot;))),
              wth(&quot;e&quot;, Fun(&quot;x&quot;, Add(Ap(&quot;d&quot;,&quot;x&quot;), Ap(&quot;d&quot;,&quot;x&quot;))),
              wth(&quot;f&quot;, Fun(&quot;x&quot;, Add(Ap(&quot;e&quot;,&quot;x&quot;), Ap(&quot;e&quot;,&quot;x&quot;))),
              Ap(&quot;f&quot;, Add(2,3))))))))
</code></pre>
<p>Can we do better? Yes, by caching the value when the argument expression is evaluated for the first time. This evaluation strategy is
called <em>call-by-need</em>.</p>
<p>Caching is easy to implement in Scala:</p>
<pre><code class="language-scala">object CallByNeed extends CBN {
  case class MemoThunk(e: Exp, env: EnvThunk) {
    var cache: ValueCBN = null
  }
  type Thunk = MemoThunk
  def delay(e: Exp, env: EnvThunk) = MemoThunk(e,env)
  def force(t: Thunk) = {
    if (t.cache == null) {
      println(&quot;Forcing evaluation of expression: &quot;+t.e)
      t.cache = evalCBN(t.e, t.env)
      t.cache
    } else println (&quot;Reusing cached value &quot;+t.cache+&quot; for expression &quot;+t.e)
    t.cache
  }
}
</code></pre>
<p>For instance, compare call-by-need and call-by-name in <code>cbntest</code> or <code>blowup</code>.
However, the meta-language (i.e., the subset of Scala features) used in the interpreter has become more complicated:</p>
<p>Since we are using mutation, the order of evaluation and aliasing of object references becomes important.
Luckily, call-by-need agrees with call-by-name with regard to produced values and termination behavior, hence it is usually not
necessary to reason about programs with the call-by-need semantics. If, however, one wants to reason about the performance of a
program in a call-by-need setting, one has to take these additional complications into account.
In practice, it is even worse, since languages like Haskell perform additional optimizations that, for instance, switch to call-by-value if an analysis can
determine that an argument will definitely be used (lookup &quot;strictness analysis&quot;).</p>
<p>Topics for class discussion:</p>
<ul>
<li>Is it a good idea to mix a language with implicit mutation (such as Java, Scala, C++, Python, ...) with lazy evaluation?</li>
<li>How can one simulate lazy evaluation in an eager language? Basic idea: 'Lambda' as evaluation firewall.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursive-functions"><a class="header" href="#recursive-functions">Recursive Functions</a></h1>
<p>The content of this chapter is available as a Scala file <a href="09-recursive-functions/./recursive-functions.scala">here.</a></p>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>Let's try to write a function that computes the sum of the first \( n \) integers. Let's pretend we do not know that the sum of the
first \( n \) integers is \( n*(n+1)/2 \) and instead compute the sum in a loop. Let's try to do this in FAE (with <code>If0</code>):</p>
<pre><code class="language-scala">val sumattempt = wth(&quot;sum&quot;, Fun(&quot;n&quot;, If0(&quot;n&quot;, 0, Add(&quot;n&quot;, Ap(&quot;sum&quot;, Add(&quot;n&quot;,-1))))), Ap(&quot;sum&quot;, 10))
</code></pre>
<p><code>sumattempt</code> won't work and yield an unbound identifier error (why?). An alternative would be to use a variant of the
<em>y</em> combinator to support recursion properly, but today we want to talk about direct support for recursion. More specifically,
we want a language construct <code>Letrec</code> that is similar to <code>with</code>, except that the bound String can be used in the expression
the String is bound to:</p>
<pre><code class="language-scala">Letrec(x: String, e: Exp, body: Exp)
</code></pre>
<p>With this new construct our language looks like this:</p>
<pre><code class="language-scala">object Syntax {
  enum Exp:
    case Num(n: Int)
    case Id(name: String)
    case Add(lhs: Exp, rhs: Exp)
    case If0(cond: Exp, thenExp: Exp, elseExp: Exp)
    case Fun(param: String, body: Exp)
    case Ap(funExpr: Exp, argExpr: Exp)
    case Letrec(x: String, e: Exp, body: Exp)

  object Exp:
    implicit def num2exp(n: Int): Exp = Num(n)
    implicit def id2exp(s: String): Exp = Id(s)
    def wth(x: String, xdef: Exp, body: Exp) : Exp = Ap(Fun(x,body),xdef)
}

import Syntax._
import Exp._
</code></pre>
<p>Using <code>Letrec</code>, our example can be expressed as follows.</p>
<pre><code class="language-scala">val sum = Letrec(&quot;sum&quot;, Fun(&quot;n&quot;, If0(&quot;n&quot;, 0, Add(&quot;n&quot;, Ap(&quot;sum&quot;, Add(&quot;n&quot;,-1))))), Ap(&quot;sum&quot;, 10))
</code></pre>
<p>Let's now consider the semantics of <code>Letrec</code>. Consider the evaluation of <code>Letrec(x,e,body)</code> in an environment <code>env</code>.
What environment should we use to evaluate <code>e</code> and <code>body</code>, respectively? Using <code>env</code> for <code>e</code> will produce a <code>ClosureV(Fun(&quot;n&quot;,...&quot;sum&quot;'...),env)</code>,
and hence the environment when evaluating body will be <code>envbody = env + (x -&gt; ClosureV(Fun(&quot;n&quot;,...&quot;sum&quot;...),env))</code>.</p>
<p>This is bad, because the <code>env</code> in the closure does not contain a binding for <code>&quot;sum&quot;</code> and hence the recursive invocation will fail.
The environment in the closure must contain a mapping for <code>&quot;sum&quot;</code>. Hence envbody should look like</p>
<pre><code>  envbody = env + (x -&gt; ClosureV(Fun(&quot;n&quot;, ...&quot;sum&quot;...),
                                 env + (&quot;sum&quot; -&gt; ClosureV(Fun(&quot;n&quot;,...&quot;sum&quot;...),env)))
</code></pre>
<p>This looks better, but now the second closure contains an environment with no binding of <code>&quot;sum&quot;</code>. What we need is an environment
that satisfies the equation:</p>
<pre><code>  envbody == env + (x -&gt; ClosureV(Fun(&quot;n&quot;, ...&quot;sum&quot;..), envbody))
</code></pre>
<p>Obviously envbody must be <code>circular</code>. There are different ways to create such a circular environment. We will choose mutation to create
a circle. More specifically, we introduce a mutable pointer to a value <code>class ValuePointer</code> which will be initialized with a null pointer.</p>
<p>In the <code>Letrec</code> case, we put such a <code>ValuePointer</code> in the environment and evaluate the (recursive) expression in that environment.
Then we update the pointer with the result of evaluating that expression.</p>
<p>The only other change we need to make is to dereference a potential value pointer in the <code>Id</code> case. We deal with the necessary case
distinction by a polymorphic <code>value</code> method.
Due to the mutual recursion between <code>ValueHolder</code> and <code>Value</code> the definitions are put into an object.</p>
<pre><code class="language-scala">object Values {
  trait ValueHolder {
    def value : Value
  }
  sealed abstract class Value extends ValueHolder { def value = this }
  case class ValuePointer(var v: Value) extends ValueHolder { def value = v }
  case class NumV(n: Int) extends Value
  case class ClosureV(f: Fun, env: Env) extends Value
  type Env = Map[String, ValueHolder]
}

import Values._  // such that we do not have to write Values.ValueHolder etc.
</code></pre>
<p>The interpreter is unchanged except for the additional <code>Letrec</code> case and the modified <code>Id</code> case.</p>
<pre><code class="language-scala">def eval(e: Exp, env: Env) : Value = e match {
  case Num(n: Int) =&gt; NumV(n)
  case Id(x) =&gt; env(x).value  // dereference potential ValuePointer
  case If0(cond, thenExp, elseExp) =&gt; eval(cond,env) match {
    case NumV(0) =&gt; eval(thenExp,env)
    case _ =&gt; eval(elseExp,env)
  }
  case Add(l,r) =&gt; {
    (eval(l,env), eval(r,env)) match {
      case (NumV(v1),NumV(v2)) =&gt; NumV(v1+v2)
      case _ =&gt; sys.error(&quot;can only add numbers&quot;)
    }
  }
  case f@Fun(param,body) =&gt; ClosureV(f, env)
  case Ap(f,a) =&gt; eval(f,env) match {
    case ClosureV(f,closureEnv) =&gt; eval(f.body, closureEnv + (f.param -&gt; eval(a,env)))
    case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  }
  case Letrec(x,e,body) =&gt; {
    val vp = ValuePointer(null)  // initialize pointer with null
    val newenv = env + (x -&gt; vp)  // evaluate e in the environment extended with the placeholder
    vp.v = eval(e,newenv)         // create the circle in the environment
    eval(body,newenv) // evaluate body in circular environment
  }
}
</code></pre>
<p>The sum of numbers from 1 to 10 should be 55.</p>
<pre><code class="language-scala">assert(eval(sum, Map.empty) == NumV(55))

// These test cases were contributed by rzhxeo (Sebastian Py)
var func = Fun(&quot;n&quot;, If0(&quot;n&quot;, 0, Ap(&quot;func&quot;, Add(&quot;n&quot;, -1))))
var test1 = Letrec(&quot;func&quot;, func, Ap(&quot;func&quot;, 1))
var test2 = Letrec(&quot;func&quot;, Ap(Fun(&quot;notUsed&quot;, func), 0), Ap(&quot;func&quot;, 1))
assert(eval(test1, Map()) == NumV(0))
assert(eval(test2, Map()) == NumV(0))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutation"><a class="header" href="#mutation">Mutation</a></h1>
<p>The content of this chapter is available as a Scala file <a href="10-mutation/./mutation.scala">here.</a></p>
<p>Today we study <em>mutation</em>. More specifically, we want to equip our language with mutable data structures.</p>
<p>Typical mutable data structures in common languages include objects with mutable fields or structures/records in languages like C or Pascal.
We will study a particularly simple mutable data structure: Boxes. In OO parlance, boxes can be thought of as an object with
a single field that can be mutated. Despite their simplicity, boxes already illustrate all main issues associated with adding
mutable state to a language.</p>
<p>A different and less interesting form of mutation is the mutability of <em>variables</em>, such as the possibility to assign something
to a 'local' variable bound via a lambda or <code>with</code>. We will not talk about mutable variables today.
We will add boxes to our base language, FAE.</p>
<pre><code class="language-scala">object Syntax {
  enum Exp:
    case Num(n: Int)
    case Id(name: String)
    case Add(lhs: Exp, rhs: Exp)
    case Mul(lhs: Exp, rhs: Exp)
    case If0(cond: Exp, thenExp: Exp, elseExp: Exp)
    case Fun(param: String, body: Exp)
    case Ap (funExpr: Exp, argExpr: Exp)

    /** To add mutation to FAE, we add four language constructs: */
    case NewBox(e: Exp) // create a new box
    case SetBox(b: Exp, e: Exp) // assign to a box
    case OpenBox(b: Exp) // read value in a box
    case Seq(e1: Exp, e2: Exp) // sequencing of expressions

  object Exp:
    implicit def num2exp(n: Int): Exp = Num(n)
    implicit def id2exp(s: String): Exp = Id(s)
    def wth(x: String, xdef: Exp, body: Exp) : Exp = Ap(Fun(x,body),xdef)
}
import Syntax._
import Exp._
</code></pre>
<p>In this new language, the following sample program,</p>
<pre><code class="language-scala">val test1 = wth(&quot;b&quot;, NewBox(0),
              Seq(
                SetBox(&quot;b&quot;, Add(1, OpenBox(&quot;b&quot;))),
                OpenBox(&quot;b&quot;)))
</code></pre>
<p>should give as result <code>1</code> in a proper implementation.
Let's consider how our interpreter could handle sequencing.</p>
<p>Here is an attempt:</p>
<pre><code class="language-scala">  case Seq(e1, e2) =&gt; {
    eval(e1, env)
    eval(e2, env)
  }
</code></pre>
<p>This cannot be correct. As long as our interpreter does not use mutation, evaluation could not make any changes to the environment,
hence there is no way the evaluation of <code>e1</code> could have any effect on the evaluation of <code>e2</code>.</p>
<p>In order to demostrate the actual nature of mutation, we will not use mutation in our meta-language to implement mutation
in our object language. Thus, we will not use a mutable data structure to implement the environment in our interpreter.
Instead, one may turn to the so-called environment-passing style, in which the interpreter returns also a possibly updated environment
together with the computed value when it evaluates an expression.  However, this solution does not always work.  Consider the following
example:</p>
<pre><code class="language-scala">val test2 = wth(&quot;a&quot;, NewBox(1),
              wth(&quot;f&quot;, Fun(&quot;x&quot;, Add(&quot;x&quot;, OpenBox(&quot;a&quot;))),
                Seq(SetBox(&quot;a&quot;,2),
                  Ap(&quot;f&quot;, 5))))
</code></pre>
<p>The mutation should affect the box stored in the closure bound to <code>f</code>.  But with the implementation strategy described above it would not.
Note that changing the value of <code>a</code> in the example is not a vialation of static scope. Scoping only says where an identifier is bound;
it does not say to what an identifier is bound, in particular, whether whatever bound to the identifier is fixed.</p>
<p>Indeed, the variable <code>a</code> is bound to the same box in both the static environment where the function <code>f</code> is created and the dynamic environment
where the function <code>f</code> is applied.</p>
<p>As before, when applying the function <code>f</code> to the argument 5, we can choose either</p>
<ol>
<li>
<p>To use the static environment (where the variable <code>a</code> is bound to a boxed 1) stored in the closure created for <code>f</code>.</p>
</li>
<li>
<p>Or to use the dynamic environment (where the variable <code>a</code> is bound to a boxed 2) present at the time of applying <code>f</code>.</p>
</li>
</ol>
<p>The first choice leads the program to evaluate to 6 rather than the expected 7. The second will record the change to the box,
but it reintroduces dynamic scoping. So both choices do not work.
Insight: We need <em>two</em> repositories of information.
One, the environment, guards static scope.</p>
<pre><code class="language-scala">sealed abstract class Value
type Env = Map[String, Value]
case class NumV(n: Int) extends Value
case class ClosureV(f: Fun, env: Env) extends Value
</code></pre>
<p>The other, which we call <em>store</em>, is tracking dynamic changes.
Determining the value inside a box will become a two-step process: We first evaluate the box expression to an <em>address</em>,
and then use the store to lookup the value stored at that address. We choose to represent addresses by integers.</p>
<pre><code class="language-scala">type Address = Int
case class AddressV(a: Address) extends Value

type Store = Map[Address, Value]
</code></pre>
<p>We will often need a fresh address in the store. We do so using a counter variable.</p>
<pre><code class="language-scala">var _nextAddress = 0

def nextAddress : Address = {
  _nextAddress += 1
  _nextAddress
}
</code></pre>
<p>Note: We promised to implement the interpreter without using mutation. Here we did use mutation, but this usage of mutation
is not essential: we could instead just search for the largest address in the present store and add one to it.
Let's now discuss the evaluation of FAE with conditionals and boxes, BCFAE. To this end, consider the following sample program:</p>
<pre><code class="language-scala">val test3 = wth(&quot;switch&quot;, NewBox(0),
             wth(&quot;toggle&quot;, Fun(&quot;dummy&quot;, If0(OpenBox(&quot;switch&quot;),
                                          Seq(SetBox(&quot;switch&quot;, 1), 1),
                                          Seq(SetBox(&quot;switch&quot;, 0), 0))),
                 Add(Ap(&quot;toggle&quot;,42), Ap(&quot;toggle&quot;,42))))
</code></pre>
<p>This program should return 1. Let's discuss on the blackboard what the environment and store should look like during the
evaluation of this program.</p>
<table><thead><tr><th>ID</th><th>Exp</th><th>Value</th><th>Env</th><th>Store</th></tr></thead><tbody>
<tr><td>A</td><td>wth(..</td><td></td><td>&quot;switch&quot; -&gt; .</td><td>1 -&gt; NumV(0)</td></tr>
<tr><td>B</td><td>wth(..</td><td></td><td>&quot;toggle&quot; -&gt; ..</td><td></td></tr>
<tr><td>C</td><td>Add(..</td><td></td><td></td><td></td></tr>
<tr><td>D</td><td>Ap(&quot;toggle&quot;)</td><td>1</td><td></td><td>1 -&gt; NumV(1)</td></tr>
<tr><td>E</td><td>Ap(&quot;toggle&quot;)</td><td>0</td><td></td><td>1 -&gt; NumV(0)</td></tr>
<tr><td>F</td><td>Add(0,1)</td><td>1</td><td></td><td></td></tr>
</tbody></table>
<p>Insight:
We must pass the current store in to evaluate every expression and pass the possibly updated store out after the evaluation.
This is called <em>store-passing style</em>.  Consequently, we have to update the type of our evaluator.</p>
<pre><code class="language-scala">def eval(e: Exp, env: Env, s: Store) : (Value, Store) = e match {
  /* All expressions whose evaluation does not alter the store just return s. */
  case Num(n) =&gt; (NumV(n), s)
  case Id(x) =&gt; (env(x), s)
  case f@Fun(_, _) =&gt; (ClosureV(f, env), s)


// In recursive cases we have to thread the store through the evaluation. In particular, we define the order of evaluation
// explicitly through data flow dependencies.

  case If0(cond, thenExp, elseExp)
    =&gt; eval(cond, env, s) match {
         case (NumV(0), s1) =&gt; eval(thenExp, env, s1)
         case (_, s1)       =&gt; eval(elseExp, env, s1)

         /* An alternative that enfoces runtime type-correctness of
          * the conditional expression:
         case (NumV(_), s1) =&gt; eval(elseExp, env, s1)
         case _             =&gt; sys.error(&quot;can only test if a number is 0&quot;) */
       }

  case Add(l, r)
    =&gt; eval(l, env, s) match {
         case (NumV(v1), s1)
           =&gt; eval(r, env, s1) match {
                case (NumV(v2), s2) =&gt; (NumV(v1 + v2), s2)
                case _ =&gt; sys.error(&quot;can only add numbers&quot;)
              }
         case _
           =&gt; sys.error(&quot;can only add numbers&quot;)
       }

  case Mul(l, r)
    =&gt; eval(l, env, s) match {
         case (NumV(v1), s1)
           =&gt; eval(r, env, s1) match {
                case (NumV(v2), s2) =&gt; (NumV(v1 * v2), s2)
                case _ =&gt; sys.error(&quot;can only multiply numbers&quot;)
              }
         case _ =&gt; sys.error(&quot;can only multiply numbers&quot;)
       }

  case Ap(f, a)
    =&gt; eval(f, env, s) match {
         case (ClosureV(f, closureEnv), s1)
           =&gt; eval(a, env, s1) match {
                case (av, s2)
                  =&gt; eval(f.body, closureEnv + (f.param -&gt; av), s2)
              }
         case _ =&gt; sys.error(&quot;can only apply functions&quot;)
       }


// In a sequence, we ignore the result of evaluating e1 but not its effect on the store.

  case Seq(e1, e2) =&gt; eval(e2, env, eval(e1, env, s)._2)

//  A new box is created by putting it into the store at a new address.

  case NewBox(e: Exp)
    =&gt; eval(e, env, s) match {
         case (v, s1) =&gt; {
           val a = nextAddress
           (AddressV(a), s1 + (a -&gt; v))
         }
       }

// Setting a box is now a two-step process: First evaluate b to an
// address, then lookup and update the value associated to the
// address in the store. Note that &quot;updated&quot; is a functional method.

  case SetBox(b: Exp, e: Exp)
    =&gt; eval(b, env, s) match {
         case (AddressV(a), s1)
           =&gt; eval(e, env, s1) match {
                case (ev, s2) =&gt; (ev, s2.updated(a, ev))
              }
         case _ =&gt; sys.error(&quot;can only set boxes&quot;)
       }

// OpenBox uses the same two-step process but does not update the
// store.

  case OpenBox(b: Exp)
    =&gt; eval(b, env, s) match {
         case (AddressV(a), s1) =&gt; (s1(a), s1)
         case _                 =&gt; sys.error(&quot;can only open boxes&quot;)
       }
}
</code></pre>
<p>From an implementation point of view, our interpreter has the problem that nothing is ever removed from the store.
One possibility would be to add an operation &quot;removeBox&quot; or the like to the language, but this would lead to dangling pointers
and all the problems associated with manual memory management.</p>
<p>Our model of stores is sufficient to illustrate how modern languages deal with memory management: by garbage collection.
Garbage collectors automatically reclaim memory that is no longer referenced from within the active part of the computation.
We can model a (naive) mark-and-sweep garbage collector as follows:</p>
<pre><code class="language-scala">def gc(env: Env, store: Store) : Store = {

  def allAddrInVal(v: Value) : Set[Address] = v match {
    case AddressV(a)      =&gt; Set(a)
    case NumV(_)          =&gt; Set.empty
    case ClosureV(f, env) =&gt; allAddrInEnv(env)
  }

  def allAddrInEnv(env: Env) : Set[Address] =
    env.values.map(allAddrInVal _).fold(Set.empty)(_ union _)

  def mark(seed: Set[Address]) : Set[Address] = {
    val newAddresses = seed.flatMap(ad =&gt; allAddrInVal(store(ad)))
    if (newAddresses.subsetOf(seed)) seed
    else mark(seed union newAddresses)
  }

  val marked = mark(allAddrInEnv(env)) // mark ...
  store.view.filterKeys(marked(_)).toMap // and sweep!
}
</code></pre>
<pre><code class="language-scala">val teststore = Map(
  6  -&gt; NumV(42),
  7  -&gt; NumV(6),
  8  -&gt; AddressV(6),
  9  -&gt; AddressV(7),
  10 -&gt; ClosureV(Fun(&quot;x&quot;, &quot;y&quot;), Map(&quot;y&quot; -&gt; AddressV(8)))
)

/*
10 -&gt; 8 -&gt; 6
      9 -&gt; 7        */

assert(gc(Map(&quot;a&quot; -&gt; AddressV(10)), teststore) == teststore - 7 - 9)
</code></pre>
<p>Note that garbage collectors only <em>approximate</em> the set of semantically disposable store entities. Even with garbage collectors,
applications may very well suffer from memory leaks. The approximation should be <em>safe</em>, in the sense that a datum is never reclaimed
when it is used by subsequent computations.</p>
<p>Furthermore, it must reclaim enough garbage to be actually useful. Reachability has turned
out to be a rather useful (and sound) approximation of semantic disposability. Garbage collectors must also be efficient.
Efficiency of GC is a huge research topic that we are not going to discuss. One efficiency problem with garbage collectors based on
reachability that we want to mention is the &quot;stop-the-world&quot; phenomenon.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="garbage-collection"><a class="header" href="#garbage-collection">Garbage Collection</a></h1>
<p>The content of this chapter is available as a Scala file <a href="11-garbage-collection/./garbage-collection.scala">here.</a></p>
<p>Let us now consider a more accurate modeling of garbage collection (gc). This time, we will use a mutable store instead of
a functional store, because our purpose is not to explain mutation but to explain gc.</p>
<p>This is the well-known syntax of our language: FAE with boxes.</p>
<pre><code class="language-scala">enum Exp:
  case Num(n: Int)
  case Id(name: String)
  case Add(lhs: Exp, rhs: Exp)
  case Mul(lhs: Exp, rhs: Exp)
  case If0(cond: Exp, thenExp: Exp, elseExp: Exp)
  case Fun(param: String, body: Exp)
  case Ap (funExpr: Exp, argExpr: Exp)

  case NewBox(e: Exp)
  case SetBox(b: Exp, e: Exp)
  case OpenBox(b: Exp)
  case Seq(e1: Exp, e2: Exp)

object Exp:
  implicit def num2exp(n: Int): Exp = Num(n)
  implicit def id2exp(s: String): Exp = Id(s)
  def wth(x: String, xdef: Exp, body: Exp) : Exp = Ap(Fun(x,body),xdef)

import Exp._
</code></pre>
<p>We will equip our values with a mutable flag that is useful for mark-and-sweep garbage collection.
In real systems it is implemented as a bit flag, or, if the so-called &quot;tri-color algorithm&quot; is used, with two bit flags.</p>
<pre><code class="language-scala">abstract class Value {
  var marked : Boolean = false
}
</code></pre>
<p>We will also use a mutable map instead of a map for environments. This is not needed for mark-and-sweep,
but for copying garbage collectors such as Cheney&quot;s&quot; semi-space garbage collection algorithm.</p>
<pre><code class="language-scala">type Env = scala.collection.mutable.Map[String, Value]
case class NumV(n: Int) extends Value
case class ClosureV(f: Fun, env: Env) extends Value
case class AddressV(a: Int) extends Value
</code></pre>
<p>To be able to experiment with different store and gc designs, we create an interface for stores.
The stack parameter in <code>malloc</code> is needed during gc to determine the root nodes from which the algorithms can start.</p>
<pre><code class="language-scala">trait Store {
  def malloc(stack: List[Env], v: Value) : Int
  def update(index: Int, v: Value) : Unit
  def apply(index: Int) : Value
}
</code></pre>
<p>In our interpreter, the stack of environments is only implicitly available on the stack of the meta-language.
To reify the call-stack we need to make it explicit. We do so by constructing the stack explicitly and passing it as parameter.
The first element of the stack is the current environment; the rest is only needed for gc.</p>
<pre><code class="language-scala">def eval(e: Exp, stack: List[Env], store: Store) : Value = e match {

  case Num(n) =&gt; NumV(n)

  case Id(x) =&gt; stack.head(x)

  case f@Fun(_, _) =&gt; ClosureV(f, stack.head)

  /* With a mutable store, we do not have to thread it according to
   * the order of evaluation any more.
   */

  case If0(cond, thenExp, elseExp)
    =&gt; eval(cond, stack, store) match {
         case NumV(0) =&gt; eval(thenExp, stack, store)
         case _       =&gt; eval(elseExp, stack, store)
       }

  /* The mutable store allows us to take advantage of Scala's
   * evaluation order and perform two pattern matchings
   * simultaneously.
   */

  case Add(l, r)
    =&gt; (eval(l, stack, store), eval(r, stack, store)) match {
         case (NumV(v1), NumV(v2)) =&gt; NumV(v1 + v2)
         case _ =&gt; sys.error(&quot;can only add numbers&quot;)
       }

  case Mul(l, r)
    =&gt; (eval(l, stack, store), eval(r, stack, store)) match {
         case (NumV(v1), NumV(v2)) =&gt; NumV(v1 * v2)
         case _ =&gt; sys.error(&quot;can only multiply numbers&quot;)
       }

  /* A new environment should be pushed onto the stack only when
   * binding occurs. Where exactly in BCFAE do bindings happen?
   */

  case Ap(f, a)
    =&gt; eval(f, stack, store) match {
         case ClosureV(f, cEnv)
           =&gt; eval(
                f.body,
                (cEnv += (f.param -&gt; eval(a, stack, store))) :: stack,
                store
              )
         case _ =&gt; sys.error(&quot;can only apply functions&quot;)
       }

  /* The mutable store allows us to implement Seq-expression
   * in terms of sequencing in Scala itself.
   */

  case Seq(e1, e2)
    =&gt; eval(e1, stack, store); eval(e2, stack, store)

  case NewBox(e: Exp)
    =&gt; {
         val a = store.malloc(stack, eval(e, stack, store))
         AddressV(a)
       }

  case SetBox(b: Exp, e: Exp)
    =&gt; eval(b, stack, store) match {
         case AddressV(a)
           =&gt; {
                val ev = eval(e, stack, store)
                store.update(a, ev)
                ev
              }
         case _ =&gt; sys.error(&quot;can only set boxes&quot;)
       }

  case OpenBox(b: Exp)
    =&gt; eval(b, stack, store) match {
         case AddressV(a) =&gt; store(a)
         case _ =&gt; sys.error(&quot;can only open boxes&quot;)
       }
}
</code></pre>
<p>Here is one implementation of the Store interface that does not perform gc. It just runs out of memory once the store is full.</p>
<pre><code class="language-scala">class NoGCStore(size: Int) extends Store {

  val memory = new Array[Value](size)

  var nextFreeAddr : Int = 0

  def malloc(stack: List[Env], v: Value) : Int = {
    val x = nextFreeAddr
    if (x &gt;= size) sys.error(&quot;out of memory&quot;)
    nextFreeAddr += 1
    update(x, v)
    x
  }

  def update(index: Int, v: Value) : Unit = memory.update(index, v)

  def apply(index: Int) = memory(index)
}
</code></pre>
<p>Here is a mark-and-sweep garbage collector.</p>
<pre><code class="language-scala">class MarkAndSweepStore(size: Int) extends Store {

  val memory = new Array[Value](size)

  var free : Int = size

  var nextFreeAddr : Int = 0

  def malloc(stack: List[Env], v: Value) : Int = {
    if (free &lt;= 0) gc(stack)
    if (free &lt;= 0) sys.error(&quot;out of memory&quot;)

    /* Here we find the next available location in memory via a while-
     * loop. In order to avoid maintaining a list of available spaces
     * (because we are lazy), let us assume that no box created in
     * BCFAE can have an address pointing to a null memory cell (which
     * also is the case).
     *
     * If we ensure the invariant that the variable `free` has always
     * the number of free memory space, then the following loop will
     * always halt. The nontermination situation will generate an out-
     * of-memory error and the program will abort. */

    while (memory(nextFreeAddr) != null) {
      nextFreeAddr += 1
      if (nextFreeAddr == size) nextFreeAddr = 0
    }

    free -= 1
    update(nextFreeAddr, v)
    nextFreeAddr
  }

  def update(index: Int, v: Value) : Unit = memory.update(index, v)

  def apply(index: Int) = memory(index)

  def allAddrInVal(v: Value) : Set[Int] = v match {
    case AddressV(a)      =&gt; Set(a)
    case NumV(_)          =&gt; Set.empty
    case ClosureV(f, env) =&gt; allAddrInEnv(env)
  }

  def allAddrInEnv(env: Env) : Set[Int] =
    env.values.map(allAddrInVal _).fold(Set.empty)(_ union _)

  def mark(seed: Set[Int]) : Unit = {
    seed.foreach(memory(_).marked = true)
    val newAddresses = seed.flatMap(
                         ad =&gt; allAddrInVal(memory(ad))
                       ).filter(!memory(_).marked)
    if(newAddresses != Set.empty) {
      mark(newAddresses)
    }
  }

  /* What graph algorithm underlies the mark step as implemented here?
   * What potential problem could it cause in a &quot;real&quot; interpreter? */

  def sweep() : Unit = {
    memory.indices.foreach(
      index =&gt;   if (memory(index) == null) {
                   /* No work needed on an empty memory cell */
                 }
                 else if (memory(index).marked) {
                   /* Reset `marked` flag for the next gc */
                   memory(index).marked = false
                 }
                 else {
                   free += 1
                   memory(index) = null
                 }
    )
  }

  def gc(stack: List[Env]) : Unit = {
    println(&quot;\nSTARTING GC\nSTACK = &quot; + stack + &quot;\nSTORE = &quot; + memory)
    mark(stack.map(allAddrInEnv _).fold(Set.empty)(_ union _))
    sweep()
    println(&quot;GC COMPLETE\nSTORE = &quot; + memory +
            &quot;\nNUMBER OF FREE SLOTS = &quot; + free)
  }
}
</code></pre>
<pre><code class="language-scala">val test4 = wth(&quot;makedata&quot;, Fun(&quot;x&quot;, NewBox(NewBox(NewBox(&quot;x&quot;)))),
                Seq(Ap(&quot;makedata&quot;, 1),
                Seq(Ap(&quot;makedata&quot;, 2),
                Seq(wth(&quot;s&quot;, Ap(&quot;makedata&quot;, 3),
                            Ap(&quot;makedata&quot;, &quot;s&quot;)),
                    Ap(&quot;makedata&quot;, 4)))))
</code></pre>
<pre><code class="language-scala">def runTest4 = eval(
                 test4,
                 List(scala.collection.mutable.Map.empty),
                 new MarkAndSweepStore(5)
               )
</code></pre>
<p>This model of garbage collection does not illustrate the difficulty of memory management. In most languages, the size of
the allocated memory regions on the heap vary, and hence one needs an algorithm to find a free and large-enough spot on the heap.
There are various algorithms and heuristics (best-fit, worst-fit, first-fit, ...) for that purpose.</p>
<p>There are also various alternative gc designs. Mark-and-sweep is a non-moving algorithm, where reachable heap objects are never moved.
In contrast to that, copying gc algorithms move the reachable objects to a different portion of the heap. One of the oldest algorithms
is the semi-space garbage collector, in particular with the implementation purpose.</p>
<p>Topic for class discussion: What are the pros and cons of moving vs. non-moving gc?</p>
<p>It can be shown empirically that most unreachable objects become unreachable while they are still young. Generational gc algorithms
take this empirical fact into account and divide the objects into generations, whereby the (small) youngest generation of objects
is garbage-collected more frequently.</p>
<p>A typical problem of the simple gc algorithms we discussed is the stop-the-world phenomenon: All execution has to be stopped during
a gc cycle. This issue is addressed by incremental or concurrent garbage collectors. Incremental garbage collectors typically reduce
the total throughput but increase responsiveness and real-time behavior.</p>
<p>A completely different approach to memory management is <em>reference counting</em>. In reference counting, each object on the heap
(in our case, each box) maintains a counter which says how many pointers currently point to that object. The counter is adjusted
whenever a pointer variable is assigned to this object (incremented), or moved from this object to another object (decremented).
When the counter is 0, the object can be reclaimed.</p>
<p>The obvious disadvantage of reference counting is that it cannot detect cycles on the heap. Hence reference counting algorithm
must be augmented with some means to detect cycles.
Topic for class discussion: What are the pros and cons of reference counting vs. tracing garbage collectors such as mark-and-sweep
or semi-space?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntactic-and-meta-interpretation"><a class="header" href="#syntactic-and-meta-interpretation">Syntactic and Meta Interpretation</a></h1>
<p>The content of this chapter is available as a Scala file <a href="12-meta-interpretation/./meta-interpretation.scala">here.</a></p>
<p>For each desired language semantics, there exist many different ways to implement an interpreter in some meta-language
to encode this semantics.</p>
<p>One question that is of particular importance is whether a language feature is implemented by using a corresponding
language feature of the meta-language, or whether it is implemented using more primitive language constructs.
The first case is called meta-interpretation, the second case syntactic interpretation.</p>
<p>Meta-interpretation can be convenient if we are not interested in having control over the exact meaning of the construct,
or if the way the meta-language handles this construct is just what we want for our object-language.</p>
<p>Syntactic interpretation is required if we want to understand what the language feature really means in terms
of more primitive constructs, or if we want to implement the language feature differently than the meta-language.
Of course, if the meta-language has no corresponding feature, then we have no choice but to make a syntactic interpretation.</p>
<p>Our FAE interpreter is a meta-interpreter with respect to many features. For instance, it does not tell us</p>
<ul>
<li>the precision of numbers, or the algorithm for addition</li>
<li>how the call stack is managed, e.g. the maximum depth of recursion supported by the interpreter</li>
<li>whether/how memory management for closures works (they are objects on the heap!)</li>
</ul>
<p>That said, it is possible to make the FAE interpreters still more &quot;meta&quot;. Here are two examples.
The first one is a version of FAE that uses a different representation of the program syntax, namely one using
meta-language functions to represent object-language functions. This technique is called higher-order abstract syntax, or HOAS.
For instance, the function <code>Fun(&quot;x&quot;, Add(&quot;x&quot;,5))</code> is now represented as <code>Fun(x =&gt; Add(x,5))</code>.
The interpreter becomes rather short, because substitution and lexical scoping are now being dealt with by the
corresponding meta-level construct.</p>
<pre><code class="language-scala">object HOAS {
  enum Exp:
    case Num(n: Int)
    case Id(name: String)
    case Add(lhs: Exp, rhs: Exp)
    case Fun(f: Exp =&gt; Exp)
    case Ap(funExpr: Exp, argExpr: Exp)

  import Exp._

  def eval(e: Exp) : Exp = e match {
      case Id(v) =&gt; sys.error(&quot;unbound identifier: &quot;+v)
      case Add(l,r) =&gt; (eval(l), eval(r)) match {
                         case (Num(x),Num(y)) =&gt; Num(x+y)
                         case _ =&gt; sys.error(&quot;can only add numbers&quot;)
                        }
      case Ap(f,a) =&gt; eval(f) match {
         case Fun(f) =&gt; eval( f(eval(a)))
         case _ =&gt; sys.error(&quot;can only apply functions&quot;)
      }
      case _ =&gt; e // numbers and functions evaluate to themselves
    }
}
</code></pre>
<p>A different way to use meta-level functions in the interpreter is to represent object-level closures by meta-level closures.
Notice that this interpreter then has no control anymore about scoping; rather, it is completely inherited from the meta-language.</p>
<p>A particularly pleasing and important property of this interpreter below is that it is <em>compositional</em>, meaning that all recursive calls
of <code>eval</code> are only on subparts of the original expression. This means that it becomes particularly easy to reason about program equivalence
in the object-language in terms of program equivalence in the meta-language: Two object-language expressions are equivalent if their
&quot;denotations&quot; as meta-level expressions are equivalent in the meta-level.</p>
<p>Compositionality is the cornerstone of denotational semantics.  A denotational semantics can be thought of as a
compositional interpreter in which the meta-language is mathematics.
Compositionality also has a rather practical side-effect: It means that we can implement the interpreter in the internal visitor style
that  we learned about in the first lecture (recall that the internal visitor  style enforces compositionality).
Recommended exercise: Re-implement the interpreter as an internal visitor.</p>
<pre><code class="language-scala">enum Exp:
  case Num(n: Int)
  case Id(name: String)
  case Add(lhs: Exp, rhs: Exp)
  case Fun(param: String, body: Exp)
  case Ap(funExpr: Exp, argExpr: Exp)

import Exp._

object Compositional {
    sealed abstract class Value
    type Env = Map[String, Value]
    case class NumV(n: Int) extends Value
    case class FunV(f: Value =&gt; Value) extends Value

    def eval(e: Exp) : Env =&gt; Value = e match {
      case Num(n: Int) =&gt; (env) =&gt; NumV(n)
      case Id(x) =&gt; env =&gt; env(x)
      case Add(l,r) =&gt; { (env) =&gt;
        (eval(l)(env),  eval(r)(env)) match {
          case (NumV(v1),NumV(v2)) =&gt; NumV(v1+v2)
          case _ =&gt; sys.error(&quot;can only add numbers&quot;)
        }
      }
      case Fun(param,body) =&gt; (env) =&gt; FunV((v) =&gt; eval(body)(env + (param -&gt; v)))
      case Ap(f,a) =&gt; (env) =&gt; (eval(f)(env), eval(a)(env)) match {
        // Use environment stored in (meta-level) closure to realize proper lexical scoping!
        case (FunV(g),arg) =&gt; g(arg)
        case _ =&gt; sys.error(&quot;can only apply functions&quot;)
      }
    }
}
</code></pre>
<p>For comparison, here is our original FAE interpreter.</p>
<pre><code class="language-scala">object FAE {
    sealed abstract class Value
    type Env = Map[String, Value]
    case class NumV(n: Int) extends Value
    case class ClosureV(f: Fun, env: Env) extends Value

    def eval(e: Exp, env: Env) : Value = e match {
      case Num(n: Int) =&gt; NumV(n)
      case Id(x) =&gt; env(x)
      case Add(l,r) =&gt; {
        (eval(l,env), eval(r,env)) match {
          case (NumV(v1),NumV(v2)) =&gt; NumV(v1+v2)
          case _ =&gt; sys.error(&quot;can only add numbers&quot;)
        }
      }
      case f@Fun(param,body) =&gt; ClosureV(f, env)
      case Ap(f,a) =&gt; eval(f,env) match {
        // Use environment stored in closure to realize proper lexical scoping!
        case ClosureV(f,closureEnv) =&gt; eval(f.body, closureEnv + (f.param -&gt; eval(a,env)))
        case _ =&gt; sys.error(&quot;can only apply functions&quot;)
      }
    }
}
</code></pre>
<p>We will soon learn about ways to make FAE more syntactic in various ways. For instance, we will no longer rely on call-stack management
of the meta-language, or the existence of higher-order functions.</p>
<p>One dimension in which the interpreter could easily be made more syntactic is the treatment of numbers and arithmetic.
For instance, we could represent numbers as sequences of digits instead of Scala numbers.
Another aspect in which our FAE interpreter relies on the host language is memory management.</p>
<p>This is particularly relevant for environments stored inside closures. These environments cannot be organized on the call stack
and hence need memory management. Since we are using Scala references to refer to environments, environments that are no longer
needed are collected by the Scala (or rather, Java) virtual machine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="church-encodings"><a class="header" href="#church-encodings">Church Encodings</a></h1>
<p>The content of this chapter is available as a Scala file <a href="13-church-encoding/./church-encoding.scala">here.</a></p>
<p>Today we shrink our language. It does not seem to be big, but today we want to  illustrate how powerful our core language,
the lambda calculus, is. Here is a shrinked version of FAE that does not even have numbers anymore. For testing purposes,
we introduce a new expression <code>PrintDot</code> whose semantics is to print a dot on the screen.</p>
<pre><code class="language-scala">enum Exp:
  case Id(name: String)
  case Fun(param: String, body: Exp)
  case Ap(funExpr: Exp, argExpr: Exp)
  case PrintDot()

object Exp:
  implicit def id2exp(s: String): Exp = Id(s)

import Exp._

abstract class Value
type Env = Map[String, Value]
// the only values are closures
case class ClosureV(f:Fun, env:Env) extends Value
</code></pre>
<p>Notice that the only values in this language are closures. This means that there cannot be the situation anymore that we expect,
say, a number but get in fact a closure. Hence, this language has the fascinating property that  no dynamic type errors can occur.</p>
<pre><code class="language-scala">def eval(e: Exp, env: Env) : Value = e match {
  // We give the identity function as dummy value for PrintDot
  case PrintDot() =&gt; print(&quot;.&quot;); ClosureV(Fun(&quot;x&quot;,&quot;x&quot;), Map.empty)
  case Id(x) =&gt; env(x)
  case f@Fun(param,body) =&gt; ClosureV(f, env)
  case Ap(f,a) =&gt; eval(f,env) match {
    case ClosureV(f,closureEnv) =&gt; eval(f.body, closureEnv + (f.param -&gt; eval(a,env)))
  }
}
</code></pre>
<p>Now we want to illustrate that we can, in principle, bootstrap a full programming language from this small core.
To do so, we use the technique of Church encoding. This means that each datum is represented by its own fold function.</p>
<h2 id="church-encoding-of-booleans"><a class="header" href="#church-encoding-of-booleans">Church Encoding of Booleans</a></h2>
<p>Let's start with booleans and boolean arithmetic.</p>
<pre><code class="language-scala">val f = Fun(&quot;t&quot;, Fun(&quot;f&quot;, &quot;f&quot;))  // false
val t = Fun(&quot;t&quot;, Fun(&quot;f&quot;, &quot;t&quot;))  // true
val and = Fun(&quot;a&quot;, Fun(&quot;b&quot;, Ap(Ap(&quot;a&quot;, &quot;b&quot;),&quot;a&quot;)))
val or = Fun(&quot;a&quot;, Fun(&quot;b&quot;, Ap(Ap(&quot;a&quot;, &quot;a&quot;), &quot;b&quot;)))
val not = Fun(&quot;a&quot;, Fun(&quot;t&quot;, Fun(&quot;f&quot;, Ap(Ap(&quot;a&quot;,&quot;f&quot;),&quot;t&quot;))))
</code></pre>
<p>We can now write our own control structures, such as <code>if/then/else</code></p>
<pre><code class="language-scala">val ifthenelse = Fun(&quot;cond&quot;, Fun(&quot;t&quot;, Fun(&quot;f&quot;, Ap(Ap(&quot;cond&quot;, &quot;t&quot;), &quot;f&quot;))))
</code></pre>
<h2 id="church-encoding-of-numbers"><a class="header" href="#church-encoding-of-numbers">Church Encoding of Numbers</a></h2>
<p>Let's now consider Numbers. We encode them as Peano numbers. These encodings of numbers are often called <em>Church numbers</em>.</p>
<pre><code class="language-scala">val zero = Fun(&quot;s&quot;, Fun(&quot;z&quot;, &quot;z&quot;))
val succ = Fun(&quot;n&quot;, Fun(&quot;s&quot;, Fun(&quot;z&quot;, Ap(&quot;s&quot;, Ap(Ap(&quot;n&quot;, &quot;s&quot;), &quot;z&quot;)))))
val one = Ap(succ, zero)
val two = Ap(succ, one)
val three = Ap(succ, two)
val add  = Fun(&quot;a&quot;, Fun(&quot;b&quot;, Fun(&quot;s&quot;, Fun(&quot;z&quot;, Ap(Ap(&quot;a&quot;,&quot;s&quot;), Ap(Ap(&quot;b&quot;, &quot;s&quot;), &quot;z&quot;))))))
val mult = Fun(&quot;a&quot;, Fun(&quot;b&quot;, Fun(&quot;s&quot;, Fun(&quot;z&quot;, Ap(Ap(&quot;a&quot;, Ap(&quot;b&quot;,&quot;s&quot;)), &quot;z&quot;)))))
val exp  = Fun(&quot;a&quot;, Fun(&quot;b&quot;, Ap(Ap(&quot;b&quot;, Ap(mult, &quot;a&quot;)), one)))
val iszero = Fun(&quot;a&quot;, Ap(Ap(&quot;a&quot;, Fun(&quot;x&quot;, f)), t))
</code></pre>
<p>The predecessor function is more complicated (why?). We do not show it here.
For testing, here is a function that prints a unary representation of a number.</p>
<pre><code class="language-scala">val printnum = Fun(&quot;a&quot;, Ap(Ap(&quot;a&quot;, Fun(&quot;x&quot;, PrintDot())), f))
</code></pre>
<h2 id="church-encoding-of-lists"><a class="header" href="#church-encoding-of-lists">Church encoding of lists</a></h2>
<p>Again straightforward, except &quot;tail&quot;, which we do not show here. It needs the same kind of trick (called &quot;pairing trick&quot;)
as the predecessor function.</p>
<pre><code class="language-scala">val emptylist = Fun(&quot;c&quot;, Fun(&quot;e&quot;, &quot;e&quot;))
val cons = Fun(&quot;h&quot;, Fun(&quot;r&quot;, Fun(&quot;c&quot;, Fun(&quot;e&quot;, Ap(Ap(&quot;c&quot;, &quot;h&quot;), Ap(Ap(&quot;r&quot;,&quot;c&quot;), &quot;e&quot;))))))
val head = Fun(&quot;l&quot;, Ap(Ap(&quot;l&quot;, Fun(&quot;h&quot;, Fun(&quot;t&quot;, &quot;h&quot;))), f))
</code></pre>
<p>For instance, we can multiply all numbers in a list</p>
<pre><code class="language-scala">val multlist = Fun(&quot;l&quot;, Ap(Ap(&quot;l&quot;, mult), one))
</code></pre>
<p>Here is the list 3,2,3:</p>
<pre><code class="language-scala">val list323 = Ap(Ap(cons, three), Ap(Ap(cons, two), Ap(Ap(cons,three), emptylist)))

</code></pre>
<pre><code class="language-scala">val test = Ap(printnum, Ap(multlist, list323))
</code></pre>
<p>Calling <code>exec</code> should yield 18 dots before the dummy result</p>
<pre><code class="language-scala">val exec = eval(test, Map.empty)
// ..................
// exec: Value = ClosureV(
//   f = Fun(param = &quot;x&quot;, body = Id(name = &quot;x&quot;)),
//   env = Map()
// )
</code></pre>
<p>Topic for class discussion: Can we do these encodings directly in Scala or Haskell?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-algebras"><a class="header" href="#object-algebras">Object Algebras</a></h1>
<p>The content of this chapter is available as a Scala file <a href="14-object-algebras/./object-algebras.scala">here.</a></p>
<p>Object algebras: A practical way of using Church Encodings</p>
<p>In previous lectures, we have talked about the &quot;expression problem&quot;: The problem of
encoding a data structure (like expressions) and functions on that data structure
(like evaluators, or pretty-printers) in such a way that both the data structure
and the functions thereon can be extended without modifying code, while at the same
time maintaining static type safety.</p>
<p>Church encodings look like an obscure theoretical idea at first, but we will see
that their incarnation as &quot;object algebras&quot; leads to a quite attractive and practical
solution to the expression problem.</p>
<p>Let's look at a Scala version of the Church encodings we saw for the lambda
calculus. We use objects instead of functions, but otherwise
it is the same. Let's start with booleans.</p>
<pre><code class="language-scala">trait Bool {
  def ifthenelse[T](t: T, e: T) : T
}

case object T extends Bool {
  def ifthenelse[T](t: T, e: T) = t
}
case object F extends Bool {
  def ifthenelse[T](t: T, e: T) = e
}
def and(a: Bool, b: Bool) : Bool = a.ifthenelse(b,a)
</code></pre>
<p>In Smalltalk and related languages, booleans are actually implemented
like that (at least conceptually).</p>
<p>In the same way, we can encode Church numerals.</p>
<pre><code class="language-scala">trait NumC {
  def fold[T](z: T, s: T =&gt; T) : T
}
case object Zero extends NumC {
  def fold[T](z: T, s: T =&gt; T) = z
}

case class Succ(n: NumC) extends NumC {
  def fold[T](z: T, s: T =&gt; T) = s(n.fold(z,s))
}

def plus(a: NumC, b: NumC) = {
  new NumC {
    def fold[T](z: T, s: T =&gt; T) : T = {
      a.fold(b.fold(z,s), s)
    }
  }
}
</code></pre>
<pre><code class="language-scala">val oneC = Succ(Zero)
val twoC = Succ(oneC)
val threeC = Succ(twoC)

def testplusC = plus(twoC,threeC).fold[Unit]( (), _ =&gt; print(&quot;.&quot;))
</code></pre>
<p>Object algebras are a different way to do Church encodings
in object-oriented languages. This is what the encoding
of Church numbers looks like in object algebra style.</p>
<pre><code class="language-scala">trait NumSig[T] {
  def z : T
  def s(p: T) : T
}

trait Num {
  def apply[T](x: NumSig[T]) : T
}
</code></pre>
<p>In other words, every constructor of the data type is turned into
a function of the <code>NumSig</code> type, with recursive occurences being replaced
by the type constructor <code>T</code>.
Actual numbers have the type <code>Num</code>, i.e., they are basically functions of type
<code>NumSig[T] =&gt; T</code>.</p>
<p>In the terminology of universal algebra, <code>NumSig</code> is an algebraic
signature, and <code>NumSig[T] =&gt; T</code> is the type of algebras for that signature.
Compared to the Church encoding above, we bundle the arguments of the
<code>fold</code>-function into a trait <code>NumSig</code> and pass them as a single object.
The advantage of this encoding is that we can extend the set of parameters
of the <code>fold</code> by using inheritance.</p>
<p>In this encoding, the <code>plus</code>-function looks like this:</p>
<pre><code class="language-scala">def plus(a: Num, b: Num) = new Num {
  def apply[T](x: NumSig[T]) : T = a( new NumSig[T] {
    def z = b(x)
    def s(p: T) = x.s(p)
  })
}
</code></pre>
<p>Here is the representation of some numbers.</p>
<pre><code class="language-scala">val zero : Num = new Num { def apply[T](x: NumSig[T]) = x.z }
val one : Num = new Num { def apply[T](x: NumSig[T]) = x.s(x.z) }
val two : Num = new Num { def apply[T](x: NumSig[T]) = x.s(one(x)) }
val three : Num = new Num { def apply[T](x: NumSig[T]) = x.s(two(x)) }
</code></pre>
<p>This is an interpretation of the <code>Num</code>-&quot;language&quot; as Scala integers:</p>
<pre><code class="language-scala">object NumAlg extends NumSig[Int] {
  def z = 0
  def s(x : Int) = x + 1
}
</code></pre>
<pre><code class="language-scala">val testplus = plus(two, three)(NumAlg)
// testplus: Int = 5
</code></pre>
<p>Let's look at a more useful application of object algebras. We encode
expression trees as object algebras.</p>
<pre><code class="language-scala">trait Exp[T] {
  implicit def id(name: String) : T
  def fun(param: String, body: T): T
  def ap(funExpr: T, argExpr: T) :T
  implicit def num(n: Int) : T
  def add(e1: T, e2: T) : T
  def wth(x: String, xdef: T, body: T) : T = ap(fun(x,body), xdef)
}
</code></pre>
<p>The structure of expressions forces compositional interpretations. Hence
we use the compositional interpretation using meta-level closures to represent
closures.</p>
<pre><code class="language-scala">sealed abstract class Value
type Env = Map[String, Value]
case class ClosureV(f: Value =&gt; Value) extends Value
case class NumV(n: Int) extends Value
</code></pre>
<p>An interpretation of expressions is now an implementation of the <code>Exp</code> interface</p>
<pre><code class="language-scala">trait eval extends Exp[Env =&gt; Value] {
  def id(name: String) = env =&gt; env(name)
  def fun(param: String, body: Env =&gt; Value) = env =&gt; ClosureV(v =&gt; body(env + (param -&gt; v)))
  def ap(funExpr: Env =&gt; Value, argExpr: Env =&gt; Value) = env =&gt; funExpr(env) match {
    case ClosureV(f) =&gt; f(argExpr(env))
    case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  }
  def num(n: Int) = env =&gt; NumV(n)
  def add(e1: Env =&gt; Value, e2: Env =&gt; Value) = env =&gt; (e1(env), e2(env)) match {
    case (NumV(n1), NumV(n2)) =&gt; NumV(n1 + n2)
    case _ =&gt; sys.error(&quot;can only add numbers&quot;)
  }
}

object eval extends eval
</code></pre>
<p>An example program becomes a function that is parametric in the choosen interpretation:</p>
<pre><code class="language-scala">def test[T](semantics : Exp[T]) = {
  import semantics._

  ap(ap(fun(&quot;x&quot;, fun(&quot;y&quot;, add(&quot;x&quot;, &quot;y&quot;))), 5), 3)
}
</code></pre>
<p>We evaluate the program by folding the <code>eval</code>-visitor over it.</p>
<pre><code class="language-scala">val testres = test(eval)(Map.empty)
// testres: Value = NumV(n = 8)
</code></pre>
<p>The object algebra encoding of expressions is quite extensible. For instance, we can
add another case to the expression data type by extending the interface.</p>
<pre><code class="language-scala">trait ExpWithMult[T] extends Exp[T] {
  def mult(e1: T, e2: T) : T
}

trait evalWithMult extends eval with ExpWithMult[Env =&gt; Value] {
  def mult(e1: Env =&gt; Value, e2: Env =&gt; Value) = env =&gt; (e1(env), e2(env)) match {
    case (NumV(n1), NumV(n2)) =&gt; NumV(n1 * n2)
    case _ =&gt; sys.error(&quot;can only multiply numbers&quot;)
  }
}
object evalWithMult extends evalWithMult

def testMult[T](semantics : ExpWithMult[T]) = {
  import semantics._

  ap(ap(fun(&quot;x&quot;, fun(&quot;y&quot;, mult(&quot;x&quot;, &quot;y&quot;))), 5), 3)
}
</code></pre>
<pre><code class="language-scala">val testresMult = testMult(evalWithMult)(Map.empty)
// testresMult: Value = NumV(n = 15)
</code></pre>
<p>Note that there is no danger of confusing the language variants. For instance,
an attempt to pass <code>testMult</code> to <code>eval</code> will be a static type error.</p>
<p>At the same time, we can add another function on expressions (such as a pretty-printer)
without changing existing code, too: Just add a 
<code>trait prettyPrint extends Exp[String]</code> and, if pretty-printing of <code>ExpWithMult</code>
is required, extend with <code>trait prettyPrintMult extends prettyPrint with ExpWithMult[String]</code>.
This is the object algebra way of solving the expression problem.</p>
<p>We can also go one step further and combine object algebras with
typed higher-order abstract syntax, using higher-kinded type members.
Don't panic if you don't understand what is going on here.</p>
<pre><code class="language-scala">trait ExpT {
  type Rep[_]
  def fun[S,T](f: Rep[S] =&gt; Rep[T]): Rep[S =&gt; T]
  def ap[S,T](funExpr: Rep[S =&gt; T], argExpr: Rep[S]) : Rep[T]
  implicit def num(n: Int) : Rep[Int]
  def add(e1: Rep[Int], e2: Rep[Int]) : Rep[Int]
}
</code></pre>
<p>Instead of having the semantic domain as a type parameter <code>T</code> as above, 
we encode it as a higher-kinded abstract type member <code>Rep[_]</code>. This leads
to significantly shorter type signatures and more fine-grained typing 
via Scala's support for &quot;path-dependent types&quot;.</p>
<p>Note that, in contrast to <code>eval</code>, no dynamic checks (<code>match</code> ...) are needed
in the interpreter. Also, the result type of the evaluator is just <code>X</code>. In
contrast to <code>Value</code>, this is a &quot;tagless&quot; type, that is, it does not maintain
information at runtime about which variant it is. This is because the <code>ExpT</code>
datatype guarantees well-typedness of expressions. This interpreter will, in
general, run much faster and can in fact be formulated in such a way that
interpreting a program is just as fast as writing the program directly in
the meta language.</p>
<pre><code class="language-scala">object evalT extends ExpT {
  type Rep[X] = X
  def fun[S,T](f: S =&gt; T) = f
  def ap[S,T](f: S =&gt; T, a: S) = f(a)
  def num(n: Int) = n
  def add(e1: Int, e2: Int) = e1 + e2
}

object prettyprintT extends ExpT {
  var counter = 0
  type Rep[X] = String
  def fun[S,T](f: String =&gt; String) = {
    val varname = &quot;x&quot; + counter.toString
    counter += 1
    &quot;(&quot; + varname + &quot; =&gt; &quot; +  f(varname) + &quot;)&quot;
  }
  def ap[S,T](f: String, a: String) = f + &quot;(&quot; + a + &quot;)&quot;
  def num(n: Int) = n.toString
  def add(e1: String, e2: String) = &quot;(&quot; + e1 + &quot;+&quot; + e2 + &quot;)&quot;
}

def test2(semantics: ExpT) = {
  import semantics._
  ap(ap(fun((x: Rep[Int]) =&gt; fun((y: Rep[Int]) =&gt; add(x, y))), 5), 3)
}
</code></pre>
<pre><code class="language-scala">val testres2 = test2(evalT)
// testres2: Int = 8
val testres3 = test2(prettyprintT)
// testres3: String = &quot;(x0 =&gt; (x1 =&gt; (x0+x1)))(5)(3)&quot;
</code></pre>
<p>An attempt to construct an ill-formed object program will be detected by
the Scala type checker. For instance, the following program which adds
a number and a function is rejected by the Scala type checker:</p>
<pre><code class="language-scala">def testilltyped(semantics: ExpT) = {
  import semantics._
  add(5, fun((x: Rep[Int]) =&gt; x))
}
// error:
// Found:    semantics.Rep[Int =&gt; Int]
// Required: semantics.Rep[Int]
//   add(5, fun((x: Rep[Int]) =&gt; x))
//          ^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>The type system encoded in the <code>ExpT</code> type is the so-called &quot;simply-typed lambda calculus&quot;. 
Encoding more expressive type system in a similar style (including, e.g., type parameters) 
is an active area of research. </p>
<p>References:
B. Olivira, W.Cook. Extensibility for the Masses: Practical Extensibility with Object Algebras. Proc. ECOOP 2012.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="continuations-1"><a class="header" href="#continuations-1">Continuations 1</a></h1>
<p>The content of this chapter is available as a Scala file <a href="15-continuations-1/./continuations-1.scala">here.</a></p>
<p>Consider the following very simple program:</p>
<pre><code class="language-scala">def inputNumber(prompt: String): Int = {
  println(prompt)
  Integer.parseInt(readLine())
}
def progSimple = {
  println(inputNumber(&quot;First number:&quot; ) + inputNumber(&quot;Second number&quot;))
}
</code></pre>
<p>Now consider a web version of the program:</p>
<ul>
<li>the first number is entered on the first page</li>
<li>then the first number is submitted, a form to enter the second number is shown</li>
<li>when the second number is submitted, a form with the result is generated and shown.</li>
</ul>
<p>Even this &quot;addition server&quot; is difficult to implement. Because http is a stateless protocol (for good reasons),
every web program is basically forced to terminate after every request. This means that
the Web developer must turn this application into three programs:</p>
<ol>
<li>The first program displays the first form.</li>
<li>The second program consumes the form values from the first form, and generates the second form.</li>
<li>The third program consumes the form values from the second form, computes the output, and generates the result.</li>
</ol>
<p>Because the value entered in the first form is needed by the third program to compute its output, this
value must somehow be transmitted between from the first program to the third. This is typically done
by using the hidden field mechanism of HTML.</p>
<p>Suppose, instead of using a hidden field, the application developer used a Java Servlet session object,
or a database field, to store the first number. (Application developers are often pushed to do this
because that is the feature most conveniently supported by the language and API they are employing.)
Then, if the developer were to exploratorily open multiple windows
the application can compute the wrong answer.
Hence, the actual program in a web developer's mind has the structure of the following program.
An actual web program is of course more complicated, but this primitive model of web
programming is sufficient to explain the problem.</p>
<pre><code class="language-scala">// we use the return type &quot;Nothing&quot; for functions that will never return (normally)
def webdisplay(s: String) : Nothing = {
  println(s)
  sys.error(&quot;program terminated&quot;)
}

def webread(prompt: String, continue: String) : Nothing = {
  println(prompt)
  println(&quot;send input to: &quot; + continue)
  sys.error(&quot;program terminated&quot;)
}

def program1 = webread(&quot;enter first number&quot;, &quot;s2&quot;)
def program2(n1: Int) = webread(&quot;enter second number and remind me of previoulsy entered number &quot; + n1, &quot;s3&quot;)
def program3(n1: Int, n2: Int) = webdisplay(&quot;The sum of &quot; + n1 + &quot; and &quot;+ n2 + &quot; is &quot; + (n1 + n2))
</code></pre>
<p>We could write a better <code>webread</code> and <code>webdisplay</code> procedure if we could somehow get hold of the
pending computation at the time when the procedure was invoked. Such a pending computation is
called <em>continuation</em>.</p>
<p>Let's consider the continuation at the point of the first interaction in the original program,</p>
<pre><code class="language-scala">def prog = {
  println(inputNumber() + inputNumber())
}
</code></pre>
<p>The pending computation (or, continuation in the following) is to take the result of the first
<code>inputNumber</code> invocation, add to it the result of the second invocation, and display it.</p>
<p>We can express the continuation as a function:</p>
<pre><code class="language-scala">val cont1 = (n: Int) =&gt; println(n + inputNumber(&quot;Second number&quot;))
</code></pre>
<p>Similarly, the continuation at the second point of interaction is:</p>
<pre><code class="language-scala">val cont2 = (m: Int) =&gt; println(n + m)
</code></pre>
<p>where <code>n</code> is the result of the first input, which is stored in the closure of <code>cont2</code>.</p>
<p>Assuming an explicit representation of the continuation, it is obvious that we can now
write a version of <code>webread</code>, called <code>webread_k</code>, which takes the continuation as second parameter and invokes
the continuation once the answer to the result is received by the server.
This can be implemented, say, by associating to a continuation a unique ID, store the continuation
in a hashmap on the server using this ID, and storing the ID in the form such that it gets
submitted back to the server once the client presses the submit button.</p>
<p>Here is code illustrating the idea. For simplicity we assume that all web forms return
a single integer value.</p>
<pre><code class="language-scala">val continuations = new scala.collection.mutable.HashMap[Symbol, Int =&gt; Nothing]()
var nextIndex : Int = 0
def getNextID = {
  nextIndex += 1
  Symbol(&quot;c&quot; + nextIndex.toString)
}

def webread_k(prompt: String, k: Int =&gt; Nothing) : Nothing = {
  val id = getNextID
  continuations += (id -&gt; k)
  println(prompt)
  println(&quot;to continue, invoke continuation: &quot; + id.toString)
  sys.error(&quot;program terminated&quot;)
}

def continue(kid: Symbol, result: Int) = continuations(kid)(result)
</code></pre>
<p>Using <code>webread_k</code>, we can now define our addition server as follows.
If you try <code>webprog</code>, ignore the stack traces.</p>
<pre><code class="language-scala">def webprog = webread_k(&quot;enter first number&quot;, (n) =&gt;
              webread_k(&quot;enter second number&quot;, (m) =&gt; webdisplay(&quot;The sum of &quot; + n + &quot; and &quot; + m + &quot; is &quot; + (n + m))))
</code></pre>
<p>For instance, try:</p>
<pre><code>scala&gt; webprog           -- yields some continuation id 'c1
scala&gt; continue('c1,5)   -- yields some continuation id 'c2
scala&gt; continue('c2,7)

This should yield the result 12 as expected. But also try:
scala&gt; webprog           -- yields some continuation id 'c1
scala&gt; contine('c1,5)    -- yields some continuation id 'c2
scala&gt; contine('c1,6)    -- yields some continuation id 'c3
scala&gt; continue('c2,3)   -- should yield 8
scala&gt; continue('c3,3)   -- should yield 9
</code></pre>
<p>The style of programming in <code>webprog</code>, which is obviously more complicated than the logical
structure of <code>progSimple</code>, shows up in many practical programming scenarios - server-side web programming
is just one of them. For instance, in JavaScript many API functions for asynchronous communication
such as httprequest in AJAX require to pass a callback function, which leads to similar code
as the one in <code>webprog</code> above.</p>
<p>Let's consider this &quot;web transformation&quot; - the transformation from <code>progSimple</code> to <code>webprog</code> - in more detail.
To this purpose, let's make our application a bit more sophisticated. Instead of entering only two
numbers, the user enters n numbers, e.g., the prices of a list of n items.</p>
<p>Here is the &quot;non-web&quot; version of the application:</p>
<pre><code class="language-scala">def allCosts(itemList: List[String]) : Int = itemList match {
   case Nil =&gt; 0
   case x :: rest =&gt; inputNumber(&quot;Cost of item &quot; + x + &quot;:&quot;) + allCosts(rest)
}
</code></pre>
<pre><code class="language-scala">val testData : List[String] = List(&quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;)

def test = println(&quot;Total sum: &quot; + allCosts(testData))
</code></pre>
<p>This version of <code>allCosts</code> is clearly not web-friendly, because it uses <code>inputNumber</code>,
which we do not know how to implement for the web.</p>
<p>The first thing to observe is that on its own, <code>allCosts</code> is not a complete program: it doesn't do anything unless
it is called with actual parameters!
Instead, it is a library procedure that may be used in many different contexts. Because it has a web interaction,
however, there is the danger that at the point of interaction, the rest of the computation -- that is, the
computation that invoked <code>allCosts</code> -- will be lost. To prevent this, <code>allCosts</code> must consume an extra argument,
a continuation, that represents the rest of the pending computation. To signify this change in contract, we will use
the convention of appending <code>_k</code> to the name of the procedure and <code>k</code> to name the continuation parameter.</p>
<p>Here is a first attempt to define <code>allCosts_k</code>.</p>
<pre><code class="language-scala"> def allCosts_k(itemList: List[String], k: Int =&gt; Nothing) : Nothing = itemList match {
   case Nil =&gt; 0
   case x :: rest =&gt; webread_k(&quot;Cost of item &quot; + x + &quot;:&quot;, n =&gt; n + allCosts_k(rest,k))
}
</code></pre>
<p>This may look reasonable, but it suffers from an immediate problem. When the recursive call occurs, if
the list had two or more elements, then there will immediately be another web interaction. Because this will
terminate the program, the pending addition will be lost! Therefore, the addition of <code>n</code> has to move into the
continuation fed to <code>allCosts_k</code>. In code:</p>
<pre><code class="language-scala">def allCosts_k(itemList: List[String], k: Int =&gt; Nothing) : Nothing = itemList match {
   case Nil =&gt; 0
   case x :: rest =&gt; webread_k(&quot;Cost of item &quot; + x + &quot;:&quot;, n =&gt; allCosts_k(rest, m =&gt; k(m + n)))
}
</code></pre>
<p>That is, the receiver of the web interaction is invoked with the cost of the first item. When <code>allCosts_k</code> is invoked
recursively, it is applied to the rest of the list. Its receiver must therefore receive the tally of costs of the
remaining items. That explains the pattern in the receiver.</p>
<p>The only problem is, where does a continuation ever get a value? We create larger-and-larger continuation on
each recursive invocation, but what ever invokes them?</p>
<p>Here is the same problem from a different angle (that also answers the question above). Notice that each
recursive invocation of <code>allCosts_k</code> takes place in the aftermath of a web interaction. We have already seen how
the act of web interaction terminates the pending computation. Therefore, when the list empties, where
is the value 0 going? Presumably to the pending computation, but there is none. Any computation that
would have been pending has now been recorded in <code>k</code>, which is expecting a value. Therefore, the correct
transformation of this procedure is:</p>
<pre><code class="language-scala">def allCosts_k(itemList: List[String], k: Int =&gt; Nothing) : Nothing = itemList match {
   case Nil =&gt; k(0)
   case x :: rest =&gt; webread_k(&quot;Cost of item &quot; + x + &quot;:&quot;, n =&gt; allCosts_k(rest, m =&gt; k(m + n)))
}

def testweb = allCosts_k(testData, m =&gt; webdisplay(&quot;Total sum: &quot; + m))
</code></pre>
<p>Let's now consider the case that we have used a library function for the iteration in <code>allCosts</code>, namely
the <code>map</code> function, which we replicate here.</p>
<pre><code class="language-scala">def map[S,T](c: List[S], f: S =&gt; T) : List[T] = c match {
  case Nil =&gt; Nil
  case x :: rest =&gt; f(x) :: map(rest, f)
}
</code></pre>
<p>Using <code>map</code>, we can rephrase <code>allCosts</code> as follows. </p>
<pre><code class="language-scala">def allCosts2(itemList: List[String]) : Int =
  map(itemList, (x: String) =&gt; inputNumber(&quot;Cost of item &quot; + x + &quot;:&quot;)).sum
</code></pre>
<p>What if we we want to use <code>map</code> in <code>allCosts_k</code>?</p>
<p>Just using <code>webread_k</code> in place of <code>inputNumber</code> will not work, since <code>webread_k</code> expects an additional parameter.
Obviously we must somehow modify the definition of <code>map</code>. But what can we pass as second parameter in the call
to <code>f</code>?</p>
<p><strong>Insight</strong>: We must perform the &quot;web transformation&quot; to <code>map</code> as well. We call the result <code>map_k</code>. Here is the code:</p>
<pre><code class="language-scala">def map_k[S,T](c: List[S], f: (S,T =&gt; Nothing) =&gt; Nothing, k: List[T] =&gt; Nothing) : Nothing = c match {
   case Nil =&gt; k(Nil)
   case x :: rest =&gt; f(x, t =&gt; map_k(rest, f, (tr: List[T]) =&gt; k(t :: tr)))
}

def allCosts2_k(itemList: List[String], k: Int =&gt; Nothing) : Nothing =
   map_k(itemList, (x: String, k2: Int =&gt; Nothing) =&gt; webread_k(&quot;Cost of item &quot; + x + &quot;:&quot;, k2), (l: List[Int]) =&gt; k(l.sum))
</code></pre>
<h2 id="implications-of-the-web-transformation"><a class="header" href="#implications-of-the-web-transformation">Implications of the &quot;web transformation&quot;:</a></h2>
<ol>
<li>
<p>We had to make decisions about the order of evaluation. That is, we had to choose whether
to evaluate the left or the right argument of addition first. This was an issue we had specified only
implicitly earlier; if our evaluator had chosen to evaluate arguments right-to-left, the web program at
the beginning of this document would have asked for the second argument before the first! We have
made this left-to-right order of evaluation explicit in our transformation.</p>
</li>
<li>
<p>The transformation we use is global, namely it (potentially) affects all the procedures in the program
by forcing them all to consume an extra continuation as an argument. We usually don't have a choice as
to whether or not to transform a procedure. Suppose <code>f</code> invokes <code>g</code> and <code>g</code> invokes <code>h</code>, and we transform
<code>f</code> to <code>f_k</code> but don't transform <code>g</code> or <code>h</code>. Now when <code>f_k</code> invokes <code>g</code> and <code>g</code> invokes <code>h</code>, suppose <code>h</code> consumes
input from the web. At this point the program terminates, but the last continuation procedure (necessary
to resume the computation when the user supplies an input) is the one given to <code>f_k</code>, with all record of
<code>g</code> and <code>h</code> lost.</p>
</li>
<li>
<p>This transformation sequentializes the program. Given a nested expression, it forces the programmer
to choose which sub-expression to evaluate first (a consequence of the first point above); further, every
subsequent operation lies in the continuation, which in turn picks the first expression to evaluate, pushing
all other operations into its continuation; and so forth. The net result is a program that looks an awful lot
like a traditional procedural program. This suggests that this series of transformations can be used to
compile a program in a language like Scheme into one in a language like C!</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="continuations-2"><a class="header" href="#continuations-2">Continuations 2</a></h1>
<p>The content of this chapter is available as a Scala file <a href="16-continuations-2/./continuations-2.scala">here.</a></p>
<p>Today's goal is to make the &quot;web&quot; (or rather, CPS) transformation which we applied informally
in the previous lecture formal.</p>
<p>In the previous lecture we have seen that we had to translate the following program:</p>
<pre><code class="language-scala">println(&quot;The sum is: &quot;+ (inputNumber(&quot;First number:&quot; ) + inputNumber(&quot;Second number&quot;)))
</code></pre>
<p>into this program:</p>
<pre><code class="language-scala">webread_k(&quot;First number&quot;, (n) =&gt;
  webread_k(&quot;Second number:&quot;, (m) =&gt; webdisplay(&quot;The sum is: &quot; + (n + m))))
</code></pre>
<p>This hand-translation is sufficient if this expression is the entire program.
If we wish to use it as a sub-expression in a larger program, this does not suffice,
because there may be a pending computation outside its own evaluation. For that
reason, the program has to send its result to a continuation instead of returning it:</p>
<pre><code class="language-scala">k =&gt; webread_k(&quot;First number&quot;, (n) =&gt;
       webread_k(&quot;Second number:&quot;, (m) =&gt; webdisplay(&quot;The sum is: &quot; + k(n + m))))
</code></pre>
<p>This version can be employed in the transformation of a larger program. In the special
case where this is the entire program we can apply the transformed term to the identity
function to get the same result as the previous manual transformation.</p>
<p>In general, every term, when converted to CPS, will be have the following properties
(see O. Danvy, Three Steps for the CPS Transformation, 1991):</p>
<ol>
<li>
<p>The values of all intermediate applications are given a name.</p>
</li>
<li>
<p>The evaluation of these applications is sequentialized based on a traversal of their
abstract syntax tree.</p>
</li>
<li>
<p>The results of the transformation are procedures that expect a continuation parameter -
a lambda abstraction whose application to intermediate values yields the final result
of the whole evaluation.</p>
</li>
</ol>
<p>Let us now look at the transformation of a function application. For instance, let us
consider the term</p>
<pre><code class="language-scala">f(a)(g(b))
</code></pre>
<p>The transformation of the function argument, <code>f(a)</code>, should be</p>
<pre><code class="language-scala">f_k(a, fval =&gt; ...)
</code></pre>
<p>Similarly, the transformation of the argument position would be:</p>
<pre><code class="language-scala">g_k(b, aval =&gt; ...)
</code></pre>
<p>Given these two values, <code>fval</code> and <code>aval</code>, we can now perform the application, like so:</p>
<pre><code class="language-scala">k(fval(aval))
</code></pre>
<p>However, this will not work, because if <code>fval</code> makes a web interaction itself, it will not return.
Instead, <code>k</code> must be given as an argument to the function, like so:</p>
<pre><code class="language-scala">k =&gt; f_k(a, fval =&gt; g_k(b, aval =&gt; fval(aval, k)))
</code></pre>
<p>Reading this sequentially, it says to evaluate the function expression, store its value in <code>fval</code>,
then evaluate the argument, store its value in <code>aval</code>, and finally invoke the function on the argument.
This function's continuation is the same as that of the function application itself.</p>
<p>What about variables and constants? Since every term in CPS must be a function that consumes a continuation,
the constant is simply sent to the continuation.
For instance, the CPS transformation of the number 3 is <code>k =&gt; k(3)</code>.</p>
<p>What about function definitions, such as <code>x =&gt; x</code>? Since every lambda expression is also a constant,
we might be tempted to use the same rule as above, i.e.,</p>
<pre><code class="language-scala">k =&gt; k(x =&gt; x)
</code></pre>
<p>However, the transformation is more subtle. A function application invokes the function on two arguments, whereas
the original function <code>x =&gt; x</code> consumes only one. What is the second argument?</p>
<p><strong>Answer</strong>: It is the <em>dynamic</em> continuation, i.e., the continuation at the time of the function <em>application</em>
(as opposed to its definition). We cannot ignore this continuation: It is the stack active at the point
of function invocation, so we want to preserve it. This is in contrast to what we did with environments,
and more in line with our treatment of the store.</p>
<p>The transformed version hence reads:</p>
<pre><code class="language-scala">k =&gt; k((x,dynk) =&gt; (k =&gt; k(x))(dynk))
</code></pre>
<p>which is equivalent (when the inner application finally happens) to:</p>
<pre><code class="language-scala">k =&gt; k((x,dynk) =&gt; dynk(x))
</code></pre>
<p>This is a function that accepts a value and a dynamic continuation and sends the value to that continuation.
We are now ready to write this transformation formally, as a source-to-source transformation. This transformation
could have the type <code>cps(e: Exp): Exp</code>, but we choose a different type for two reasons:</p>
<ol>
<li>
<p>In CPS we need function definitions and applications with two arguments instead of one. This could be addressed
by adding new syntax.</p>
</li>
<li>
<p>More importantly, we want the invariants of the CPS format to be clearly visible in the syntax definition of the
result, most importantly the fact that all function applications are tail calls.</p>
</li>
</ol>
<pre><code class="language-scala">enum Exp:
  case Num(n: Int)
  case Id(name: String)
  case Add(lhs: Exp, rhs: Exp)
  case Fun(param: String, body: Exp)
  case Ap(funExpr: Exp, argExpr: Exp)

object Exp:
  implicit def num2exp(n: Int): Exp = Num(n)
  implicit def id2exp(s: String): Exp = Id(s)
</code></pre>
<p>For CPS transformed terms, we define two different syntactic categories: Values (<code>CPSVal</code>) and Expressions (<code>CPSExp</code>).
By &quot;values&quot;, we mean terms that &quot;return&quot;, that is, terms that are different from applications of functions
or continuations (neither of which returns). Additions (<code>CPSAdd</code>) are also values in this regard: We assume addition
to be built-in and not requiring CPS-transformations.</p>
<p>The syntax makes clear that all arguments of a function application are values - hence no nesting of applications
can occur. Furthermore, the syntax differentiates between defining an ordinary function (<code>CPSFun</code>) which, when translated,
gets an additional continuation parameter, and Continuation Functions (<code>CPSCont</code>), which are the result of the CPS
transformation. Correspondingly, we have two different forms of applications, <code>CPSContAp</code> and <code>CPSFunAp</code>.</p>
<p>Here is the formal definition:</p>
<pre><code class="language-scala">sealed abstract class CPSExp
abstract class CPSVal extends CPSExp
case class CPSNum(n: Int) extends CPSVal
case class CPSAdd(l: CPSVar, r: CPSVar) extends CPSVal
case class CPSCont(v: String, body: CPSExp) extends CPSVal
case class CPSFun(x: String, k: String, body: CPSExp) extends CPSVal
case class CPSVar(x: String) extends CPSVal { override def toString = x.toString }
implicit def id2cpsexp(x: String): CPSVar = CPSVar(x)

case class CPSContAp(k: CPSVal, a: CPSVal) extends CPSExp
// the arguments are even CPSVar and not only CPSVal!
case class CPSFunAp(f: CPSVar, a: CPSVar, k: CPSVar) extends CPSExp
</code></pre>
<p>With these definitions, we are now ready to formalize the transformation described above.
There is one technical issue: We need to introduce new names for binders into our program, such as <code>&quot;k&quot;</code>.
We need to make sure that we do not accidentially capture existing names in the program.
For this reason we need our <code>freshName</code> machinery we introduced for
(FAE)[../07-higher-order-functions/higher-order-functions.html].</p>
<pre><code class="language-scala">def freeVars(e: Exp) : Set[String] =  e match {
   case Id(x) =&gt; Set(x)
   case Add(l, r) =&gt; freeVars(l) ++ freeVars(r)
   case Fun(x, body) =&gt; freeVars(body) - x
   case Ap(f, a) =&gt; freeVars(f) ++ freeVars(a)
   case Num(n) =&gt; Set.empty
}

def freshName(names: Set[String], default: String) : String = {
  var last : Int = 0
  var freshName = default
  while (names contains freshName) { freshName = default + last; last += 1; }
  freshName
}

def cps(e: Exp) : CPSCont = e match {
   case Add(e1,e2) =&gt; {
     val k = freshName(freeVars(e), &quot;k&quot;)
     val lv = freshName(freeVars(e2), &quot;lv&quot;)
     CPSCont(k, CPSContAp(cps(e1), CPSCont(lv, CPSContAp(cps(e2), CPSCont(&quot;rv&quot;, CPSContAp(k, CPSAdd(&quot;rv&quot;, lv)))))))
   }
   case Fun(a, body) =&gt; {
     val k = freshName(freeVars(e), &quot;k&quot;)
     val dynk = freshName(freeVars(e), &quot;dynk&quot;)
     CPSCont(k, CPSContAp(k, CPSFun(a, dynk, CPSContAp(cps(body), dynk))))
   }
   case Ap(f,a) =&gt; {
     val k = freshName(freeVars(e), &quot;k&quot;)
     val fval = freshName(freeVars(a), &quot;fval&quot;)
     CPSCont(k, CPSContAp(cps(f), CPSCont(fval, CPSContAp(cps(a), CPSCont(&quot;aval&quot;, CPSFunAp(fval, &quot;aval&quot;, k))))))
   }
   case Id(x) =&gt; {
     val k = freshName(freeVars(e), &quot;k&quot;)
     CPSCont(k, CPSContAp(k, CPSVar(x)))
   }
   case Num(n) =&gt; {
     val k = freshName(freeVars(e), &quot;k&quot;)
     CPSCont(k, CPSContAp(&quot;k&quot;, CPSNum(n)))
   }
}
</code></pre>
<p>This transformation is the so-called Fischer CPS transformation. There are many other CPS transformation algorithms.
The Fischer CPS transformation is nice because it is so simple and because it is defined as one simple structural
recursion over the AST. Its main disadvantage is the existence of so-called &quot;administrative redexes&quot;.</p>
<p>An administrative redex is a function application whose operator is a &quot;continuation lambda&quot; - a lambda produced during
CPS transformation that was not in the original program. Such function applications can be computed immediately because
the function which is called is known.</p>
<p>For instance, <code>cps(Add(2,3))</code> yields</p>
<pre><code class="language-scala">CPSCont(&quot;k&quot;,
        CPSContAp(
          CPSCont(&quot;k&quot;,
                  CPSContAp(&quot;k&quot;,2)),
          CPSCont(&quot;lv&quot;,
                  CPSContAp(
                    CPSCont(&quot;k&quot;,
                            CPSContAp(&quot;k&quot;,3)),
                    CPSCont(&quot;rv&quot;,
                            CPSContAp(&quot;k&quot;, CPSAdd(&quot;rv&quot;, &quot;lv&quot;)))))))
</code></pre>
<p>instead of</p>
<pre><code class="language-scala">CPSCont(&quot;k&quot;, CPSContAp(&quot;k&quot;, CPSAdd(2,3)))
</code></pre>
<p>Many more advanced CPS transformation algorithms try to avoid as many administrative redexes as possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-class-continuations"><a class="header" href="#first-class-continuations">First Class Continuations</a></h1>
<p>The content of this chapter is available as a Scala file <a href="17-first-class-continuations/./first-class-continuations.scala">here.</a></p>
<p>Today's goal is to formalize first-class continuations as illustrated by Scheme's let/cc construct. In the previous lecture we have
learned why first class continuations are a powerful language construct. Today we learn the semantics of first-class continuations by
extending our interpreter to support let/cc. Here is the abstract syntax of the language extended with <code>Letcc</code>:</p>
<pre><code class="language-scala">enum Exp:
  case Num(n: Int)
  case Id(name: String)
  case Add(lhs: Exp, rhs: Exp)
  case Fun(param: String, body: Exp)
  case Ap(funExpr: Exp, argExpr: Exp)
  /** The abstract syntax of Letcc is as follows */
  case Letcc(param: String, body: Exp)

object Exp:
  implicit def num2exp(n: Int): Exp = Num(n)
  implicit def id2exp(s: String): Exp = Id(s)
</code></pre>
<p>But how do we implement <code>Letcc</code>? How do we get hold of the rest of the computation of the object (=interpreted) program?
One idea would be to CPS-transform the object program. Then we would have the current continuation available and could
store it in environments etc.
However, we want to give a direct semantics to first-class continuations, without first  transforming the object program.</p>
<p><strong>Insight</strong>: If we CPS-transform the interpreter, the continuation of the interpreter also represents, in some way, the continuation
of the object program. The difference is that it represents what's left to do in the interpreter and not in the object program.
However, what is left in the interpreter <em>is</em> what is left in the object program.</p>
<p>Hence we are faced with two tasks:</p>
<ol>
<li>CPS-transform the interpreter</li>
<li>add a branch for <code>Letcc</code> to the interpreter.</li>
</ol>
<p>Let's start with the standard infrastructure of values and environments.</p>
<pre><code class="language-scala">sealed abstract class Value
type Env = Map[String, Value]
case class NumV(n: Int) extends Value
case class ClosureV(f: Fun, env: Env) extends Value
</code></pre>
<p>How do we represent values that represent continuations? Since we want to represent an object language continuation by a meta language
continuation, we need to be able to wrap a meta language continuation as an object language value. This continuation will always accept
some other object language value:</p>
<pre><code class="language-scala">case class ContV(f: Value =&gt; Nothing) extends Value
</code></pre>
<p>We also need a syntactic construct to apply continuations. One way to provide such a construct would be to add a new syntactic category
of continuation application. We will instead do what Scheme and other languages also do: We overload the normal function applicaton
construct and also use it for application of continuations.</p>
<p>This means that we will need a case distinction in our interpreter whether the function argument is a closure or a continuation.
Let's now study the interpreter for our new language. The branches for <code>Num</code>, <code>Id</code>, <code>Add</code>, and <code>Fun</code> are straightforward applications of the
CPS transformation technique we already know.</p>
<pre><code class="language-scala">def eval(e: Exp, env: Env, k: Value =&gt; Nothing) : Nothing = e match {
  case Num(n: Int) =&gt; k(NumV(n))
  case Id(x) =&gt; k(env(x))
  case Add(l,r) =&gt; {
    eval(l, env, lv =&gt;
        eval(r, env, rv =&gt;
          (lv, rv) match {
            case (NumV(v1), NumV(v2)) =&gt; k(NumV(v1 + v2))
            case _ =&gt; sys.error(&quot;can only add numbers&quot;)
          }))
  }
  case f@Fun(param,body) =&gt; k(ClosureV(f, env))

  /* In the application case we now need to distinguish whether the first argument
   * is a closure or a continuation. If it is a continuation, we ignore the
   * current continuation k and &quot;jump&quot; to the stored continuation by applying the
   * evaluated continuation argument to it. */
  case Ap(f,a) =&gt; eval(f, env, cl =&gt; cl match {
            case ClosureV(f,closureEnv) =&gt; eval(a, env, av =&gt; eval(f.body, closureEnv + (f.param -&gt; av), k))
            case ContV(f) =&gt; eval(a, env, av =&gt; f(av))
            case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  })
  /* Letcc is now surprisingly simple: We continue the evaluation in the body in an
   * extended environment in which param is bound to the current continuation k,
   * wrapped as a value using ContV. */
  case Letcc(param, body) =&gt; eval(body, env + (param -&gt; ContV(k)), k)
}
</code></pre>
<p>To make it easier to experiment with the interpreter this code provides the right initialization to <code>eval</code>. We have to give <code>eval</code> a
continuation which represents the rest of the computation after <code>eval</code> is done. A small technical problem arises due to our usage of
the return type <code>Nothing</code> for continuations, to emphasize that they do not return: The only way to implement a value that has this
type is a function that does indeed not return. We do so by letting this function throw an exception. To keep track of the returned
value we store it temporarily in a variable, catch the exception, and return the stored value.</p>
<pre><code class="language-scala">def starteval(e: Exp) : Value = {
  var res : Value = null
  val s : Value =&gt; Nothing = (v) =&gt; { res = v; sys.error(&quot;program terminated&quot;) }
  try { eval(e, Map.empty, s) } catch { case e: Throwable =&gt; () }
  res
}
</code></pre>
<p>Finally a small test of ~Letcc`.</p>
<pre><code class="language-scala">val testprog = Add(1, Letcc(&quot;k&quot;, Add(2, Ap(&quot;k&quot;, 3))))

assert(starteval(testprog) == NumV(4))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="letcc"><a class="header" href="#letcc">LetCC</a></h1>
<p>The content of this chapter is available as a Racket file <a href="18-letcc/./letcc.rkt">here.</a></p>
<pre><code class="language-racket">#lang racket
</code></pre>
<p>Racket is a language with so-called <em>first-class continuations</em>. It can reify the
current continuation automatically and on the fly. As you may imagine, creating a
continuation involves copying the stack, but there are less and more efficient ways of
obtaining the same effect.</p>
<p>Adding continuations to a language makes it easy to create a better web programming protocol,
as we shall see. But first-class continuations are much more general and give programmers
immense power in numerous contexts.</p>
<p>In Racket (and the related programming language Scheme), a continuation is created with
<code>let/cc</code>. It can be used to give the current continuation a name: <code>(let/cc k ... k ...)</code></p>
<p>Let's write some programs using continuations (try this in the Racket read-eval-print loop).</p>
<p><code>(let/cc k (k 3))</code> What is the continuation <code>k</code> here?</p>
<p><code>(+ 1 (let/cc k (k 3)))</code> What is the continuation <code>k</code> here?</p>
<p>Using <code>let/cc</code> for exception handling: <code>let/cc</code> acts as the &quot;try&quot;, invoking <code>k</code> as the &quot;throw&quot;.</p>
<pre><code class="language-racket">(define (f n) (+ 10 (* 5 (let/cc k (/ 1 (if (zero? n) (k 1) n))))))
</code></pre>
<p>Next we simulate a very simple kind of exception handling mechanism
with first-class continuations.</p>
<pre><code class="language-racket">(define exceptionhandler (lambda (msg) (display &quot;unhandled exception&quot;)))

(define (f n)
  (+ 5
     (if (zero? n) (exceptionhandler &quot;division by zero&quot;)
         (/ 8 n))))

(define (g n)
  (+ (f n) (f n)))

(define (h)
  (let/cc k
    (begin
      (set! exceptionhandler (lambda (msg) (begin
                                             (displayln msg)
                                             (k))))
      (displayln (g 1))
      (displayln (g 0))
      (displayln (g 2)))))
</code></pre>
<p>Try evaluating <code>(h)</code> in the read-eval-print-loop.</p>
<p>Now we encode a simple debugger with support for breakpoints.
The <code>breakpoint </code>variable stores the continuation at the current breakpoint</p>
<pre><code class="language-racket">(define breakpoint false) ; initalized with a dummy value
</code></pre>
<p>The <code>repl</code> variable stores the continuation that jumps to the read-eval-print loop</p>
<pre><code class="language-racket">(define repl false)       ; initialized with a dummy value
</code></pre>
<p>The <code>break</code> function captures the current continuation, stores it, and jumps to the REPL:</p>
<pre><code class="language-racket">(define (break) (let/cc k
                  (begin
                    (set! breakpoint k)
                    (repl))))
</code></pre>
<p>To continue, we jump to the previously stored continuation:</p>
<pre><code class="language-racket">(define (continue)
  (breakpoint))
</code></pre>
<p>Here is a simple test program of our &quot;debugger&quot;:</p>
<pre><code class="language-racket">(define (main)
  (display &quot;1&quot;)
  (break)
  (display &quot;2&quot;)
  (break)
  (display &quot;3&quot;))

; nothing to do after this, hence k is the REPL continuation
(let/cc k
  (set! repl k))
</code></pre>
<p>Let's now consider a more sophisticated usage of <code>let/cc</code>, namely to program a simple form
of cooperative multi-threading, often called <em>co-routines</em>. A co-routine designates points
in the routine where a switch to another routine should occur - a so-called yield point.</p>
<p>With <code>let/cc</code> we can program co-routines within the language, without having any dedicated
built-in support for it:</p>
<pre><code class="language-racket">(define queue empty)

(define (empty-queue?)
  (empty? queue))

(define (enqueue x)
  (set! queue (append queue (list x))))

(define (dequeue)
  (let ((x (first queue)))
    (set! queue (rest queue))
    x))

(define (fork)
  (let/cc k
    (begin
      (enqueue (lambda () (k 1))) ; enqueue thunk
      0)))

(define (join)
  (if (not (empty-queue?))
      ((dequeue))
      'alljoined))

(define (yield)
  (let/cc k
    (enqueue k)
    ((dequeue))))  ; invoke thunk

(define (fact n) (if (zero? n) 1 (* n (fact (- n 1)))))
(define (fib n) (if (&lt; n 2) 1 (+ (fib (- n 1)) (fib (- n 2)))))

(define (printfibs n)
  (if (zero? n)
      (begin (print &quot;Fertig mit fibs&quot;) (newline))
      (begin
        (print (format &quot;Fib(~A)=~A&quot; n (fib n)))
        (newline)
        (yield)
        (printfibs (- n 1)))))

(define (printfacts n)
  (if (zero? n)
      (begin (print &quot;Fertig mit facts&quot;) (newline))
      (begin
        (print (format &quot;Fact(~A)=~A&quot; n (fact n)))
        (newline)
        (yield)
        (printfacts (- n 1)))))


(define (test-forkjoin)
  (if (= (fork) 0)
      (printfibs 8)
      (printfacts 12))
  (join)
  (if (= (fork) 0)
    (printfibs 10)
    (printfacts 8))
  (join))

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delimited-continuations"><a class="header" href="#delimited-continuations">Delimited Continuations</a></h1>
<p>The content of this chapter is available as a Scala file <a href="19-shift-reset/./shift-reset.scala">here.</a></p>
<p>The continuations we have seen so far represent the whole call-stack. Invoking a continuation
was not like a function call because continuations never return a result. Invoking
a continuation is more similar to a disciplined version of GOTO.</p>
<p>However, the fact that continuations never return and represent the full call-stack often
makes their use cumbersome. In particular, such continuations cannot be composed. The
non-composability of continuations is visible in the fact that applications using
first-class continuations often need to make use of mutable state.</p>
<p>This is different with <em>delimited continuations</em>. Delimited continuations only represent
a segement of the call-stack. Delimited continuations
behave like functions, that is, they return a value and are hence composable.</p>
<p>Delimited continuations have many quite powerful applications, ranging from advanced exception handling
to backtracking algorithms and probabilistic programming as well as so-called algebraic effects.
Delimited continuations are available in Racket and many variants of Scheme, OCaML, Haskell and,
thanks to work in our research group, in Java.</p>
<p>There are many different variants of delimited continuations, many of them dating back to the late 1980s and
early 1990s. One of the most common forms of delimited continuations is in the form of <code>reset</code> and <code>shift</code>,
proposed by Olivier Danvy and Andrzej Filinski in 1990. The first of these primitives, <code>reset e</code>, marks the
current stack frame and continues with <code>e</code>. An invocation of the second primitive, <code>shift k e</code>, reifies the
stack segment between the current stack frame and the closest stack frame marked by a <code>reset</code> as a function,
binds this function to <code>k</code>, and evaluates <code>e</code> (which can then call <code>k</code> zero or more times). </p>
<p>Their meaning can be understood via a code transformation.</p>
<pre><code>reset (...A... shift k e ...B...) 
 ; --&gt; 
with k = lambda x. reset (...A... x ...B...) : 
  reset e 
  
reset e  ; no invocation of shift inside e 
 ; --&gt; 
e 
</code></pre>
<p>In class, we will look at a couple of examples of using <code>shift</code> and <code>reset</code>. <code>shift</code> and <code>reset</code> are available
in some variants of Scheme, including Racket, as an extension of Scala, as a library in OcaML, as well
as various usually partial, incomplete or buggy simulations in other languages.</p>
<p>A definitional interpreter for delimited continuations is pretty simple.</p>
<pre><code class="language-scala">enum Exp:
  case Num(n: Int)
  case Id(name: String)
  case Add(lhs: Exp, rhs: Exp)
  case Fun(param: String, body: Exp)
  case Ap(funExpr: Exp, argExpr: Exp)
  case Shift(param: String, body: Exp)
  case Reset(body: Exp)

object Exp:
  implicit def num2exp(n: Int): Exp = Num(n)
  implicit def id2exp(s: String): Exp = Id(s)
</code></pre>
<pre><code class="language-scala">sealed abstract class Value
type Env = Map[String, Value]
case class NumV(n: Int) extends Value
case class ClosureV(f: Fun, env: Env) extends Value
case class ContV(f: Value =&gt; Value) extends Value

def eval(e: Exp, env: Env, k: Value =&gt; Value) : Value = e match {
  case Num(n: Int) =&gt; k(NumV(n))
  case Id(x) =&gt; k(env(x))
  case Add(l,r) =&gt; {
    eval(l, env, lv =&gt;
        eval(r, env, rv =&gt;
          (lv, rv) match {
            case (NumV(v1), NumV(v2)) =&gt; k(NumV(v1 + v2))
            case _ =&gt; sys.error(&quot;can only add numbers&quot;)
          }))
  }
  case f@Fun(param,body) =&gt; k(ClosureV(f, env))

  case Ap(f,a) =&gt; eval(f, env, cl =&gt; cl match {
            case ClosureV(f, closureEnv) =&gt; eval(a, env, av =&gt; eval(f.body, closureEnv + (f.param -&gt; av), k))
            case ContV(k2) =&gt; eval(a, env, av =&gt; k(k2(av))) // compose continuations k2 and k
            case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  })
  case Reset(e) =&gt; k(eval(e, env, x =&gt; x)) // reset the continuation to the identity function
  case Shift(param,body) =&gt; eval(body, env + (param -&gt; ContV(k)), x =&gt; x)  // wrap current continuation and reset continuation
}
</code></pre>
<p>References:</p>
<ol>
<li>Olivier Danvy and Andre Filinski, “Abstracting Control,” LISP and Functional Programming, 1990.</li>
<li>O. Kiselyov, An argument against call/cc. http://okmij.org/ftp/continuations/against-callcc.html</li>
<li>O. Kiselyov, Introduction to programming with shift and reset. http://okmij.org/ftp/continuations/#tutorial</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-monads"><a class="header" href="#introduction-to-monads">Introduction to Monads</a></h1>
<p>The content of this chapter is available as a Scala file <a href="20-monads-intro/./monads-intro.scala">here.</a></p>
<p>We have seen various patterns of function composition:</p>
<ul>
<li>The environment passing style, in which an environment is passed down in recursive calls.</li>
<li>The store passing style, in which a store is threaded in and out of every computation.</li>
<li>The continuation passing style, in which every function call is a tail call.</li>
</ul>
<p>Monads are way to abstract over such patterns of function composition.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Using monads, we can write code which can be parameterized to be in
one of the styles above (or many others).
Here is another common pattern of function composition. Suppose we have the following API of (nonsensical) functions:</p>
<pre><code class="language-scala">def f(n: Int): String = &quot;x&quot;
def g(x: String): Boolean = x == &quot;x&quot;
def h(b: Boolean): Int = if (b) 27 else sys.error(&quot;error&quot;)

def clientCode = h(!g(f(27) + &quot;z&quot;))
</code></pre>
<p>Now suppose that these functions can possibly fail (say, because they involve remote communication). A common way to deal with such
failures is to use the <code>Option</code> datatype:</p>
<pre><code class="language-scala">def fOp(n: Int): Option[String] = if (n &lt; 100) Some(&quot;x&quot;) else None
def gOp(x: String): Option[Boolean] = Some(x == &quot;x&quot;)
def hOp(b: Boolean): Option[Int] = if (b) Some(27) else None
</code></pre>
<p>However, now the <code>clientCode</code> must be changed rather dramatically:</p>
<pre><code class="language-scala">def clientCodeOp =
  fOp(27) match {
    case Some(x) =&gt; gOp(x + &quot;z&quot;) match {
        case Some(y) =&gt; hOp(!y)
        case None =&gt; None
      }
    case None =&gt; None
  }
</code></pre>
<p>We see a kind of pattern in this code. We have a value of type <code>Option[A]</code>, but the next function we need to call requires an <code>A</code> and
produces an <code>Option[B]</code>. If the <code>Option[A]</code> value is <code>None</code>, then the whole computation produces <code>None</code>. If it is <code>Some(x)</code>
instead, we pass <code>x</code> to the function.</p>
<p>We can capture this pattern in the form of a function:</p>
<pre><code class="language-scala">def bindOption[A,B](a: Option[A], f: A =&gt; Option[B]): Option[B] = a match {
  case Some(x) =&gt; f(x)
  case None =&gt; None
}
</code></pre>
<p>Using <code>bindOption</code>, we can rewrite the code above as follows:</p>
<pre><code class="language-scala">def clientCodeOpBind =
  bindOption(fOp(27), (x: String) =&gt;
    bindOption(gOp(x + &quot;z&quot;), (y: Boolean) =&gt;
      hOp(!y)))
</code></pre>
<p>Now suppose that our original client code was not <code>h(!g(f(27) + &quot;z&quot;))</code>
but instead <code>!g(f(27) + &quot;z&quot;)</code>. How can we express this with <code>bindOption</code>? This
thing does not type check:</p>
<pre><code class="language-scala">def clientCode =
  bindOption(f(27), (x: String) =&gt;
    bindOption(g(x + &quot;z&quot;), (y: Boolean) =&gt;
      !y))
</code></pre>
<p>One way to fix the situation is to insert a call to <code>Some</code>, like so:</p>
<pre><code class="language-scala">def clientCode2Op =
  bindOption(fOp(27), (x: String) =&gt;
    bindOption(gOp(x + &quot;z&quot;), (y: Boolean) =&gt;
      Some(!y)))
</code></pre>
<p>While this works, it is incompatible with our original goal of abstracting over the function composition pattern, because the
<code>Some</code> constructor exposes what kind of pattern we are currently dealing with. Hence let's abstract over it by adding a second
function <code>unit</code> to our function composition interface:</p>
<pre><code class="language-scala">def unit[A](x: A): Option[A] = Some(x)

def clientCode2OpUnit =
  bindOption(fOp(27), (x: String) =&gt;
    bindOption(gOp(x + &quot;z&quot;), (y: Boolean) =&gt;
      unit(!y)))
</code></pre>
<p>This looks better, but the types of <code>unit</code> and <code>bindOption</code> (and also the name, but we can of course change that) still
reveal that we are dealing with the <code>Option</code> function composition pattern. Let's abstract over the <code>Option</code> type constructor
by turning the type constructor into a parameter. The resulting triple (type constructor, <code>unit</code> function, <code>bind</code> function) is
called a <em>monad</em>. Certain conditions (the &quot;monad laws&quot;) on <code>unit</code> and <code>bind</code> also need to hold to make it a true monad,
but we'll defer a discussion of these conditions until later.</p>
<h2 id="the-monad-interface"><a class="header" href="#the-monad-interface">The Monad Interface</a></h2>
<p>So here it is: The Monad interface.</p>
<pre><code class="language-scala">trait Monad[M[_]] {
  def unit[A](a: A): M[A]
  def bind[A,B](m: M[A], f: A =&gt; M[B]): M[B]
  // The &quot;monad laws&quot;:
  // 1) &quot;unit&quot; acts as a kind of neutral element of &quot;bind&quot;, that is:
  //    1a) bind(unit(x), f) == f(x) and
  //    1b) bind(x, y =&gt; unit(y)) == x
  // 2) Bind enjoys an associative property
  //     bind(bind(x, f), g) == bind(x, y =&gt; bind(f(y), g))
}
</code></pre>
<p>Using this interface, we can now make <code>clientCode</code> depend only on this interface, but no longer on the <code>Option</code> type:</p>
<pre><code class="language-scala">def clientCode2Op(m: Monad[Option]) =
  m.bind(fOp(27), (x: String) =&gt;
    m.bind(gOp(x + &quot;z&quot;), (y: Boolean) =&gt;
      m.unit(!y)))
</code></pre>
<p>If the API is parametric in the monad, we can make the client code fully parametric, too. We model the monad object as an
implicit parameter to save the work of passing on the monad in every call.</p>
<pre><code class="language-scala">def fM[M[_]](n: Int)(using m: Monad[M]): M[String] = sys.error(&quot;not implemented&quot;)
def gM[M[_]](x: String)(using m: Monad[M]): M[Boolean] = sys.error(&quot;not implemented&quot;)
def hM[M[_]](b: Boolean)(using m: Monad[M]): M[Int] = sys.error(&quot;not implemented&quot;)

def clientCode2[M[_]](using m: Monad[M]) =
  m.bind(fM(27), (x: String) =&gt;
    m.bind(gM(x + &quot;z&quot;), (y: Boolean) =&gt;
      m.unit(!y)))
</code></pre>
<h2 id="for-comprehension-syntax"><a class="header" href="#for-comprehension-syntax">For-Comprehension Syntax</a></h2>
<p>All these nested calls to <code>bind</code> can make the code hard to read. Luckily, there is a notation called &quot;monad-comprehension&quot; to make
monadic code look simpler. Monad-comprehensions are directly supported in Haskell and some other languages. In Scala, we can
piggy-back on the &quot;for-comprehension&quot; syntax instead.
A &quot;for-comprehension&quot; is usually used for lists and other collections. For instance:</p>
<pre><code class="language-scala">val l = List(List(1,2), List(3,4))
assert((for { x &lt;- l; y &lt;- x } yield y + 1) == List(2,3,4,5))
</code></pre>
<p>The Scala compiler desugars the for-comprehension above into calls of the standard <code>map</code> and <code>flatMap</code> functions. That is, the above
for-comprehension is equivalent to:</p>
<pre><code class="language-scala">assert(l.flatMap(x =&gt; x.map(y =&gt; y + 1)) == List(2,3,4,5))
</code></pre>
<p>We will make use of for-comprehension syntax by supporting both <code>flatMap</code> (which is like <code>bind</code>) and <code>map</code> (which is like <code>fmap</code>).
We support these functions by an implicit conversion to an object that supports these functions as follows:</p>
<pre><code class="language-scala">extension [A, M[_]](m: M[A])(using mm: Monad[M])
  def map[B](f: A =&gt; B): M[B] = mm.bind(m, (x: A) =&gt; mm.unit(f(x)))
  def flatMap[B](f: A =&gt; M[B]): M[B] = mm.bind(m, f)
</code></pre>
<p>Using the new support for for-comprehension syntax, we can rewrite our client code as follows: Given the API from above,</p>
<pre><code class="language-scala">def fOp(n: Int): Option[String] = if (n &lt; 100) Some(&quot;x&quot;) else None
def gOp(x: String): Option[Boolean] = Some(x == &quot;x&quot;)
def hOp(b: Boolean): Option[Int] = if (b) Some(27) else None
</code></pre>
<p>We can now rewrite this</p>
<pre><code class="language-scala">def clientCode2Op(m: Monad[Option]) =
  m.bind(fOp(27), (x: String) =&gt;
    m.bind(gOp(x + &quot;z&quot;), (y: Boolean) =&gt;
      m.unit(!y)))
</code></pre>
<p>to this:</p>
<pre><code class="language-scala">def clientCode2OpFor(using m: Monad[Option]) =
  for {
    x &lt;- fOp(27)
    y &lt;- gOp(x + &quot;z&quot;)
  } yield !y
</code></pre>
<h2 id="the-option-monad"><a class="header" href="#the-option-monad">The Option Monad</a></h2>
<p>Let's look at some concrete monads now. We have of course already seen one particular monad: The <code>Option</code> monad. This monad is also
sometimes called the <code>Maybe</code> monad.</p>
<pre><code class="language-scala">object OptionMonad extends Monad[Option] {
  override def bind[A,B](a: Option[A], f: A =&gt; Option[B]): Option[B] =
    a match {
      case Some(x) =&gt; f(x)
      case None =&gt; None
    }
  override def unit[A](a: A) = Some(a)
}
</code></pre>
<p>We can now parameterize <code>clientCode</code> with <code>OptionMonad</code>.</p>
<pre><code class="language-scala">def v: Option[Boolean] = clientCode2Op(OptionMonad)
</code></pre>
<p>There are many other sensible monads. Before we discuss those, let us discuss whether there are useful functions that are generic
enough to be useful for many different monads. Here are some of these functions:</p>
<p><code>fmap</code> turns every function between <code>A</code> and <code>B</code> into a function between <code>M[A]</code> and <code>M[B]</code>:</p>
<pre><code class="language-scala">def fmap[M[_],A,B](f: A =&gt; B)(using m: Monad[M]): M[A] =&gt; M[B] =
  a =&gt; m.bind(a, (x: A) =&gt; m.unit(f(x)))
</code></pre>
<p>In fancy category theory terms, we can say that every monad is a functor.</p>
<p><code>sequence</code> composes a list of monadic values into a single monadic value which is a list.</p>
<pre><code class="language-scala">def sequence[M[_],A](l: List[M[A]])(using m: Monad[M]): M[List[A]] = l match {
  case x :: xs =&gt; m.bind(x, (y: A) =&gt;
    m.bind(sequence(xs), (ys: List[A]) =&gt;
      m.unit(y :: ys)))
  case Nil =&gt; m.unit(List.empty)
}
</code></pre>
<p><code>mapM</code> composes <code>sequence</code> and the standard <code>map</code> function:</p>
<pre><code class="language-scala">def mapM[M[_],A,B](f: A =&gt; M[B], l: List[A])(using m: Monad[M]): M[List[B]] =
  sequence(l.map(f))
</code></pre>
<p><code>join</code> is another useful function to unwrap a layer of monads.
In category theory, monads are defined via <code>unit</code> (denoted by the greek letter η)
and <code>join</code> (denoted μ) instead of <code>unit</code> and <code>bind</code>. There are additional &quot;naturality&quot; and
&quot;coherence conditions&quot; that make the category theory definition equivalent to ours.</p>
<pre><code class="language-scala">def join[M[_],A](x: M[M[A]])(using m: Monad[M]): M[A] = m.bind(x, (y: M[A]) =&gt; y)
</code></pre>
<p>Here are some other common monads:</p>
<h2 id="the-identity-monad"><a class="header" href="#the-identity-monad">The Identity Monad</a></h2>
<p>The <em>identity monad</em> is the simplest monad which corresponds to ordinary function application. If we parameterize monadic code
with the identity monad, we get the behavior of the original non-monadic code.</p>
<pre><code class="language-scala">type Id[X] = X
object IdentityMonad extends Monad[Id] {
  def bind[A,B](x: A, f: A =&gt; B): B = f(x)
  def unit[A](a: A): A = a
}
</code></pre>
<h2 id="the-reader-monad"><a class="header" href="#the-reader-monad">The Reader Monad</a></h2>
<p>This is the <em>reader monad</em>, a.k.a. <em>environment monad</em>. It captures the essence of &quot;environment passing style&quot;.</p>
<p>The type parameter <code>[A] =&gt;&gt; R =&gt; A</code> may look a bit complicated, but
it is merely &quot;currying&quot; the function arrow type constructor.</p>
<p>The type constructor which is created here is <code>M[A] = R =&gt; A</code></p>
<pre><code class="language-scala">trait ReaderMonad[R] extends Monad[[A] =&gt;&gt; R =&gt; A] {
  // pass the &quot;environment&quot; r into both computations
  override def bind[A,B](x: R =&gt; A, f: A =&gt; R =&gt; B): R =&gt; B = r =&gt; f(x(r))(r)
  override def unit[A](a: A): R =&gt; A = (_) =&gt; a
}
</code></pre>
<p><strong>Example</strong>: Suppose that all functions in our API above depend on some kind of environment, say, the current configuration.
For simplicitly, let's assume  that the current configuration is just an <code>Int</code>, hence all functions have a return type of
the form <code>Int =&gt; A</code>:</p>
<pre><code class="language-scala">def fRead(n: Int): Int =&gt; String = sys.error(&quot;not implemented&quot;)
def gRead(x: String): Int =&gt; Boolean = sys.error(&quot;not implemented&quot;)
def hRead(b: Boolean): Int =&gt; Int = sys.error(&quot;not implemented&quot;)
</code></pre>
<p>Our original code,</p>
<pre><code class="language-scala">def clientCode = h(!g(f(27) + &quot;z&quot;))
</code></pre>
<p>becomes :</p>
<pre><code class="language-scala">def clientCodeRead(env: Int) = hRead(!gRead(fRead(27)(env) + &quot;z&quot;)(env))(env)
</code></pre>
<p>In monadic form, the explicit handling of the environment disappears again:</p>
<pre><code class="language-scala">def clientCode2Read(using m: ReaderMonad[Int]) =
  m.bind(fRead(27), (x: String) =&gt;
    m.bind(gRead(x + &quot;z&quot;), (y: Boolean) =&gt;
      m.unit(!y)))

/** this code does not work in older versions of Scala */
def clientCode2ReadFor(using m: ReaderMonad[Int]) =
  for {
    x &lt;- fRead(27)
    y &lt;- gRead(x + &quot;z&quot;)
  } yield !y
</code></pre>
<h2 id="the-state-monad"><a class="header" href="#the-state-monad">The State Monad</a></h2>
<p>The <em>state monad</em>, in which computations depend on a state <code>S</code>
which is threaded through the computations, is defind as follows:</p>
<pre><code class="language-scala">trait StateMonad[S] extends Monad[[A] =&gt;&gt; S =&gt; (A, S)] {
  override def bind[A,B](x: S =&gt; (A, S), f: A =&gt; S =&gt; (B, S)): S =&gt; (B, S) =
    // thread the state through the computations
    s =&gt; x(s) match { case (y, s2) =&gt; f(y)(s2) }
  override def unit[A](a: A): S =&gt; (A, S) = s =&gt; (a, s)
}
</code></pre>
<p>Example: Assume that our API maintains a state which (for simplicity) we assume to be a single integer. That is, it would look like this:</p>
<pre><code class="language-scala">def fState(n: Int): Int =&gt; (String, Int) = sys.error(&quot;not implemented&quot;)
def gState(x: String): Int =&gt; (Boolean, Int) = sys.error(&quot;not implemented&quot;)
def hState(b: Boolean): Int =&gt; (Int, Int) = sys.error(&quot;not implemented&quot;)
</code></pre>
<p>The original code,</p>
<pre><code class="language-scala">def clientCode = h(!g(f(27) + &quot;z&quot;))
</code></pre>
<p>becomes :</p>
<pre><code class="language-scala">def clientCodeState(s: Int) =
  fState(27)(s) match {
    case (x, s2) =&gt; gState(x + &quot;z&quot;)(s2) match {
      case (y, s3) =&gt; hState(!y)(s3) }}
</code></pre>
<p>In monadic style, however, the state handling disappears once more:</p>
<pre><code class="language-scala">def clientCode2State(using m: StateMonad[Int]) =
  m.bind(fState(27), (x: String) =&gt;
    m.bind(gState(x + &quot;z&quot;), (y: Boolean) =&gt;
      m.unit(!y)))
</code></pre>
<h2 id="the-list-monad"><a class="header" href="#the-list-monad">The List Monad</a></h2>
<p>In the <em>list monad</em>, computations produce lists of results. The <code>bind</code> operator combines all those results in a single list.</p>
<pre><code class="language-scala">object ListMonad extends Monad[List] {
  // apply f to each element, concatenate the resulting lists
  override def bind[A,B](x: List[A], f: A =&gt; List[B]): List[B] = x.flatMap(f)
  override def unit[A](a: A) = List(a)
}
</code></pre>
<p><strong>Example</strong>: Assume that our API functions return lists of results, and our client code must exercise the combination of all possible answers.</p>
<pre><code class="language-scala">def fList(n: Int): List[String] = sys.error(&quot;not implemented&quot;)
def gList(x: String): List[Boolean] = sys.error(&quot;not implemented&quot;)
def hList(b: Boolean): List[Int] = sys.error(&quot;not implemented&quot;)
</code></pre>
<p>The original code,</p>
<pre><code class="language-scala">def clientCode = h(!g(f(27)+&quot;z&quot;))
</code></pre>
<p>becomes :</p>
<pre><code class="language-scala">def clientCodeList =
  fList(27).map(x =&gt; gList(x + &quot;z&quot;)).flatten.map(y =&gt; hList(!y)).flatten
</code></pre>
<p>The monadic version of the client code stays the same, as expected:</p>
<pre><code class="language-scala">def clientCode2List = {
  given Monad[List] = ListMonad
  for {
    x &lt;- fList(27)
    y &lt;- gList(x + &quot;z&quot;)
  } yield !y
}
</code></pre>
<h2 id="the-continuation-monad"><a class="header" href="#the-continuation-monad">The Continuation Monad</a></h2>
<p>The last monad we are going to present is the continuation monad, which stands for computations that are continuations.</p>
<pre><code class="language-scala">trait ContinuationMonad[R] extends Monad[[A] =&gt;&gt; (A =&gt; R) =&gt; R] {
  type Cont[X] = (X =&gt; R) =&gt; R

  override def bind[A,B](x: Cont[A], f: A =&gt; Cont[B]): Cont[B] =
    // construct continuation for x that calls f with the result of x
    k =&gt; x(a =&gt; f(a)(k))
  override def unit[A](a: A): Cont[A] = k =&gt; k(a)

  // callcc is like letcc; the difference is that letcc binds a name,
  // whereas callcc expects a function as argument.
  // That means that letcc(k,...) is expressed as callcc(k =&gt; ...).
  def callcc[A,B](f: (A =&gt; Cont[B]) =&gt; Cont[A]): Cont[A] =
    k =&gt; f((a: A) =&gt; (_: B =&gt; R) =&gt; k(a))(k)
}
</code></pre>
<p><strong>Example</strong>: Suppose our API was CPS-transformed:</p>
<pre><code class="language-scala">def fCPS[R](n: Int): (String =&gt; R) =&gt; R = sys.error(&quot;not implemented&quot;)
def gCPS[R](x: String): (Boolean =&gt; R) =&gt; R = sys.error(&quot;not implemented&quot;)
def hCPS[R](b: Boolean): (Int =&gt; R) =&gt; R = sys.error(&quot;not implemented&quot;)
</code></pre>
<p>The original code,</p>
<pre><code class="language-scala">def clientCode = h(!g(f(27) + &quot;z&quot;))
</code></pre>
<p>becomes :</p>
<pre><code class="language-scala">def clientCodeCPS[R]: (Int =&gt; R) =&gt; R =
  k =&gt; fCPS(27)((x: String) =&gt; gCPS(x + &quot;z&quot;)((y: Boolean) =&gt;  hCPS(!y)(k)))
</code></pre>
<p>The monadic version hides the CPS transformation in the operations of the monad.</p>
<pre><code class="language-scala">def clientCode2CPS[R](using m: ContinuationMonad[R]) =
  m.bind(fCPS(27), (x: String) =&gt;
    m.bind(gCPS(x + &quot;z&quot;), (y: Boolean) =&gt;
      m.unit(!y)))
</code></pre>
<p>Let's implement <code>1 + (2 + 3)</code> in monadic style and implicitly CPS-transform using the continuation monad:</p>
<pre><code class="language-scala">// unfortunately we can, again, not use for-comprehension syntax
def ex123[R](using m: ContinuationMonad[R])  = {
  m.bind(
    m.bind(m.unit(2), (two: Int) =&gt;
      m.bind(m.unit(3), (three: Int) =&gt; m.unit(two + three))),
    (five: Int) =&gt; m.unit(1 + five))
}

def runEx123 = ex123(using new ContinuationMonad[Int]{})(x =&gt; x)
</code></pre>
<p>Let's implement the <code>(+ 1 (let/cc k (+ 2 (k 3))))</code> example using <code>callcc</code></p>
<pre><code class="language-scala">def excallcc[R](using m: ContinuationMonad[R])  = {
  m.bind(
    m.bind(m.unit(2), (two: Int) =&gt;
      m.callcc[Int,Int](k =&gt; m.bind(k(3), (three: Int) =&gt; m.unit(two + three)))),
    (five: Int) =&gt; m.unit(1 + five))
}

def runExcallcc = excallcc(using new ContinuationMonad[Int]{})(x =&gt; x)
</code></pre>
<p>Remember how we had to CPS-transform the <code>map</code> function in the &quot;allCosts&quot; example when we talked about continuations?
Now we can define a monadic version of <code>map</code> that works for any monad, including the continuation monad:</p>
<pre><code class="language-scala">def mapM[M[_],A,B](x: List[A], f: A =&gt; M[B])(using m: Monad[M]): M[List[B]] =
  sequence(x.map(f))
</code></pre>
<h2 id="monad-transformers"><a class="header" href="#monad-transformers">Monad Transformers</a></h2>
<p>The purpose of monad transformers is to compose monads.
For instance, what if we want to have both the list monad and the option monad
at the same time? Such situations arise very often in practical code.</p>
<p>One solution is to have a monad transformer version of each monad, which is
parameterized with another monad. We show this for the Option monad case.</p>
<pre><code class="language-scala">type OptionT[M[_]] = { type x[A] = M[Option[A]] }


class OptionTMonad[M[_]](val m: Monad[M]) extends Monad[OptionT[M]#x] {

  override def bind[A,B](x: M[Option[A]], f: A =&gt; M[Option[B]]): M[Option[B]] =
    m.bind(x, (z: Option[A]) =&gt; z match { case Some(y) =&gt; f(y)
                                          case None =&gt; m.unit(None) })

  override def unit[A](a: A) = m.unit(Some(a))

  def lift[A](x: M[A]): M[Option[A]] = m.bind(x, (a: A) =&gt; m.unit(Some(a)))
}
</code></pre>
<pre><code class="language-scala">val ListOptionM = new OptionTMonad(ListMonad)
</code></pre>
<pre><code class="language-scala">// in this case, for-comprehension syntax doesn't work because it clashes with the
// built-in support for for-comprehensions for lists :-(
def example = {
  val m = ListOptionM
  m.bind(List(Some(3), Some(4)), (x: Int) =&gt; m.unit(x + 1))
}

def example2 = {
  val m = ListOptionM
  m.bind(List(Some(3), Some(4)), (x: Int) =&gt; m.lift(List(1, 2, 3, x)))
}

def example3 = {
  val m = ListOptionM
  m.bind(List(Some(3), None, Some(4)), (x: Int) =&gt; m.unit(x + 1))
}

def example4 = {
  val m = ListOptionM
  m.bind(List(Some(3), Some(4)), (x: Int) =&gt; if (x &gt; 3) m.m.unit(None) else m.unit(x * 2))
}
</code></pre>
<p>Monad transformers are a standard way to compose monads, e.g., in Haskell and in Scala.
They have a number of well-known disadvantages. For instance, one needs additional transformer
versions of monads and the required lifting sometimes destroys modularity.
There are a number of alternative proposals to monad transformers, such as
<a href="https://hackage.haskell.org/package/extensible-effects">&quot;extensible effects&quot;</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-monad"><a class="header" href="#io-monad">IO Monad</a></h1>
<p>The content of this chapter is available as a Scala file <a href="21-io-monad/./io-monad.scala">here.</a></p>
<pre><code class="language-scala">trait IOMonad {
  type IO[_]
  def unit[A](a: A): IO[A]
  def bind[A,B](m: IO[A], f: A =&gt; IO[B]): IO[B]
  def printString(s: String): IO[Unit]
  def inputString: IO[String]

  def performIO[A](action: IO[A]): A
}
</code></pre>
<pre><code class="language-scala">val iomonad : IOMonad = new IOMonad {
  type World = String
  type IO[A] = World =&gt; (A, World)
  def unit[A](a: A): IO[A] = w =&gt; (a, w)
  def bind[A,B](m: IO[A], f: A =&gt; IO[B]): IO[B] = w =&gt; m(w) match { case (a, w2) =&gt; f(a)(w2) }
  def printString(s: String) : IO[Unit] = w =&gt; { println(s); ((), w + s + &quot; was printed and then ...\n&quot;) }
  def inputString: IO[String] = w =&gt; { val input = scala.io.StdIn.readLine(); (input, w + input + &quot; was entered and then ...\n&quot;) }

  def performIO[A](action: IO[A]) : A = action(&quot;The world in which nothing has happened yet, but then ...\n&quot;) match {
    case (a, w) =&gt; println(&quot;Peformed all actions. The world in which all this happened is: \n&quot; + w); a
  }
}
</code></pre>
<pre><code class="language-scala">def someIOActions(implicit m: IOMonad) : m.IO[Unit] =
  m.bind(m.printString(&quot;Enter your first name:&quot;), (_: Unit) =&gt;
  m.bind(m.inputString, (firstName: String) =&gt;
  m.bind(m.printString(&quot;Enter your last name:&quot;), (_: Unit) =&gt;
  m.bind(m.inputString, (lastName: String) =&gt;
  m.printString(&quot;Hello, &quot; + firstName + &quot; &quot; + lastName + &quot;!&quot;)))))

def test = iomonad.performIO(someIOActions(iomonad))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modular-interpreters"><a class="header" href="#modular-interpreters">Modular Interpreters</a></h1>
<p>The content of this chapter is available as a Scala file <a href="22-modular-interpreters/./modular-interpreters.scala">here.</a></p>
<h1 id="a-monad-library"><a class="header" href="#a-monad-library">A Monad Library</a></h1>
<p>A Monad library in Scala. Monad libraries like
in scalaz and cats (for Scala) or the Haskell
standard library look similar.</p>
<pre><code class="language-scala">trait Monad {
  type M[_] // this time we treat M as a type member and not as type parameter
            // because it leads to shorter type signatures
  def unit[A](a: A): M[A]
  def bind[A,B](m: M[A], f: A =&gt; M[B]): M[B]

  extension [A](m: M[A])
    def map[B](f: A =&gt; B): M[B] = bind(m, (x: A) =&gt; unit(f(x)))
    def flatMap[B](f: A =&gt; M[B]): M[B] = bind(m,f)
}
</code></pre>
<p>We formulate concrete monads in the form of abstract interfaces first.
The idea of those interfaces is that it should be possible to use
the monad only in terms of that interface, without knowing anything
about <code>M</code>. The advantage of this approach is that it enables us to
compose monads. <code>M</code> changes in every composition of monads. For instance,
when composing the list monad and the option monad, then
<code>M[X] = Option[List[X]]</code> or <code>M[X] = List[Option[X]]</code>.</p>
<p>By keeping <code>M</code> abstract and using it only via the interfaces, &quot;client code&quot;
does not need to depend on the particular composition of monads.</p>
<p>The Reader (or Environment) monad captures computations that depend
on an environment of type <code>R</code>.</p>
<p>The <code>ask</code> function yields the current environment, the <code>local</code> function
is used to transform the environment in a subcomputation a by an
environment transformer <code>f</code>.</p>
<pre><code class="language-scala">trait ReaderMonad extends Monad {
  type R
  def ask: M[R]
  def local[A](f: R =&gt; R, a: M[A]): M[A]
}
</code></pre>
<p>The standard implementation of the reader monad:</p>
<pre><code class="language-scala">trait ReaderMonadImp extends ReaderMonad {
  type M[X] = R =&gt; X
  def unit[A](a: A): M[A] = r =&gt; a
  def bind[A,B](m: M[A], f: A =&gt; M[B]): M[B] = r =&gt; f(m(r))(r)
  def ask: M[R] = identity
  def local[A](f: R =&gt; R, a: M[A]): M[A] = r =&gt; a(f(r))
}
</code></pre>
<p>An example of using the reader monad to propagate an environment
of type <code>Int</code> through a computation.</p>
<pre><code class="language-scala">object ReaderExample extends ReaderMonadImp {
  type R = Int
  def example: M[Int] = for { x &lt;- ask } yield (x+1)
  def example2: M[Int] = local(r =&gt; 99, example)
}
</code></pre>
<p>A more useful example where we use the reader monad
to propagate a mapping from identifiers to boolean values
in an interpreter for boolean formulas. note that the signature of
<code>eval</code> is identical to <code>def eval(e: Exp): Map[String, Boolean] =&gt; Boolean</code>,
that is, we curry <code>eval</code> to make it applicable to the reader monad.</p>
<pre><code class="language-scala">object ReaderExample2 extends ReaderMonadImp {
  enum Exp:
    case Id(x: String)
    case And(l: Exp, r: Exp)
    case Or(l: Exp, r: Exp)
  import Exp._
  type R = Map[String, Boolean]

  def eval(e: Exp): M[Boolean] = e match {
    case Id(x) =&gt; for {env &lt;- ask } yield env(x)
    case And(l, r) =&gt; for {
      x &lt;- eval(l)
      y &lt;- eval(r)
    } yield (x &amp;&amp; y)
    case Or(l, r) =&gt; for {
      x &lt;- eval(l)
      y &lt;- eval(r)
    } yield (x || y)
  }
}
</code></pre>
<p>The implementation of the <code>And</code> case is semantically equivalent to this code:</p>
<pre><code class="language-scala">case And(l,r) =&gt; env =&gt; {
  val x = eval(l)(env)
  val y = eval(r)(env)
  x &amp;&amp; y
}
</code></pre>
<p>However, the monadic code is more abstract (and hence
more reusable) because it is not coupled to the concrete <code>M</code>.</p>
<p>This is the interface and standard implementation for the state monad:</p>
<pre><code class="language-scala">trait StateMonad extends Monad {
  type S
  def getState: M[S]
  def putState(s: S): M[Unit]
}

trait StateMonadImp extends StateMonad {
  type M[A] = S =&gt; (A, S)
  def unit[A](a: A): M[A] = (s: S) =&gt; (a, s)
  def bind[A,B](m: M[A], f: A =&gt; M[B]): M[B] = (s: S) =&gt; {
    val (a, s2) = m(s)
    f(a)(s2)
  }
  def getState: M[S] = s =&gt; (s, s)
  def putState(s: S): M[Unit] = _ =&gt; ((), s)
}
</code></pre>
<p>And here is the interface for the continuation monad. The continuation monad provides
a method <code>callcc</code>, which reifies the current continuation <code>k: A =&gt; M[B]</code>.</p>
<pre><code class="language-scala">trait ContinuationMonad extends Monad {
  def callcc[A,B](f: (A =&gt; M[B]) =&gt; M[A]): M[A]
}
</code></pre>
<p><em>End of Monad Interfaces</em></p>
<p>Now we provide implementations of the monad interfaces.</p>
<p>The identity monad, which is the end of each transformer chain:</p>
<pre><code class="language-scala">trait IdentityMonad extends Monad {
  type M[A] = A
  def unit[A](a: A): M[A] = a
  def bind[A,B](m: M[A], f: A =&gt; M[B]) = f(m)
}

object IdentityMonad extends IdentityMonad
</code></pre>
<p>We organize most other monads as monad <em>transformers</em>.
A monad transformer is parameterized with another monad.
The monads are organized in a chain. Operations of &quot;inner&quot; monads must be lifted to top-level operations.</p>
<pre><code class="language-scala">trait MonadTransformer extends Monad {
  val m: Monad
}
</code></pre>
<p>The reader monad transformer. We provide some convenient
functions <code>lift</code>, <code>lift2</code> etc. to lift functions from the inner monad.
Note that <code>M[X] = R =&gt; m.M[X]</code> instead of <code>M[X] = R =&gt; X</code> (as for
the non-transformer version of the reader monad).
The correct implementation of the interface methods follows from
this type equation.</p>
<pre><code class="language-scala">trait ReaderT extends MonadTransformer with ReaderMonad {
  type R
  override type M[X] = R =&gt; m.M[X]
  override def unit[A](a: A): M[A] = r =&gt; m.unit(a)
  override def bind[A,B](x: M[A], f: A =&gt; M[B]): M[B] =
    r =&gt; m.bind(x(r), (n: A) =&gt; f(n)(r))
  override def ask: M[R] = r =&gt; m.unit(r)
  override def local[A](f: R =&gt; R, a: M[A]): M[A] = r =&gt; a(f(r))
  protected implicit def lift[A](x: m.M[A]): M[A] = r =&gt; x
  protected implicit def lift2[A,B](x: A =&gt; m.M[B]): A =&gt; M[B] = a =&gt; lift(x(a))
  protected implicit def lift3[A,B,C](x: (A =&gt; m.M[B]) =&gt; m.M[C]): (A =&gt; M[B]) =&gt; M[C] =
    f =&gt; r =&gt; x((a: A) =&gt; f(a)(r))
  protected implicit def lift4[A,B,C,D](x: ((A =&gt; m.M[B]) =&gt; m.M[C]) =&gt; m.M[D]): ((A =&gt; M[B]) =&gt; M[C]) =&gt; M[D] =
    f =&gt; r =&gt; x((a: A =&gt; m.M[B]) =&gt; f(lift2(a))(r))
}

// The original reader monad can be reconstructed by composing ReaderT with the identity monad.

trait ReaderMonadImpl extends ReaderT {
  val m: IdentityMonad = IdentityMonad
}
</code></pre>
<p>We do not need this because we have just synthesized it:</p>
<pre><code class="language-scala">trait ReaderMonadImpl extends ReaderMonad {
  type M[X] = R =&gt; X
  def unit[A](a: A): M[A] = r =&gt; a
  def bind[A,B](m: M[A], f: A =&gt; M[B]): M[B] = r =&gt; f(m(r))(r)
  def ask: M[R] = identity
  def local[A](f: R =&gt; R, a: M[A]): M[A] = (r) =&gt; a(f(r))
}
</code></pre>
<p>The design of <code>StateT</code> is similar to that of <code>ReaderT</code>:</p>
<pre><code class="language-scala">trait StateT extends MonadTransformer with StateMonad {
  type M[A] = S =&gt; m.M[(A, S)]
  override def unit[A](a: A): M[A] = (s: S) =&gt; m.unit(a, s)
  override def bind[A,B](x: M[A], f: A =&gt; M[B]): M[B] = (s: S) =&gt; {
     m.bind[(A, S),(B, S)](x(s), { case (a, s2) =&gt; f(a)(s2)})
  }
  override def getState: M[S] = s =&gt; m.unit((s, s))
  override def putState(s: S): M[Unit] = _ =&gt; m.unit(((), s))
}

// and again we can reconstruct the ordinary state monad.

trait StateMonadImpl extends StateT {
  val m: IdentityMonad = IdentityMonad
}
</code></pre>
<p>We do not need this because we have just synthesized it:</p>
<pre><code class="language-scala">trait StateMonadImpl extends StateMonad {
  type M[A] = S =&gt; (A, S)
  def unit[A](a: A): M[A] = (s: S) =&gt; (a, s)
  def bind[A,B](m: M[A], f: A =&gt; M[B]): M[B] = (s: S) =&gt; {
     val (a, s2) = m(s)
     f(a)(s2)
  }
  def getState: M[S] = s =&gt; (s, s)
  def putState(s: S): M[Unit] = _ =&gt; ((), s)
}
</code></pre>
<p>We could also synthesize <code>ContinuationMonadImpl</code> from a <code>ContT</code>
just as we did for <code>ReaderMonadImpl</code> and <code>StateMonadImpl</code>,
but for simplicity we only present the ordinary continuation monad here.</p>
<pre><code class="language-scala">trait ContinuationMonadImpl extends ContinuationMonad {
  type T
  type M[A] = (A =&gt; T) =&gt; T
  override def unit[A](a: A): M[A] = k =&gt; k(a)
  override def bind[A,B](m: M[A], f: A =&gt; M[B]): M[B] = k =&gt; m( a =&gt; f(a)(k))
  override def callcc[A,B](f: (A =&gt; M[B]) =&gt; M[A]): M[A] = k =&gt; f(a =&gt; _ =&gt; k(a))(k)
}
</code></pre>
<p>Let's compose some monads.</p>
<p>The composition of the reader monad and some continuation monad.</p>
<pre><code class="language-scala">trait ReaderContinuationMonadForwarder extends ReaderT with ContinuationMonad {
  val m: ContinuationMonad
  // call to lift4 inserted automatically
  override def callcc[A,B](f: (A =&gt; M[B]) =&gt; M[A]): M[A] = (m.callcc[A,B] _)(f)
}
</code></pre>
<p>The composition of the reader monad and the continuation monad implementation.</p>
<pre><code class="language-scala">trait ReaderContinuationMonadImpl extends ReaderContinuationMonadForwarder {
  type T
  val m: ContinuationMonadImpl { type T = ReaderContinuationMonadImpl.this.T } =
    new ContinuationMonadImpl { type T = ReaderContinuationMonadImpl.this.T }
}
</code></pre>
<p>Composition of reader monad with some state monad.</p>
<pre><code class="language-scala">trait ReaderStateMonadForwarder extends ReaderT with StateMonad {
  val m: StateMonad { type S = ReaderStateMonadForwarder.this.S }
  override def getState: M[S] = m.getState
  override def putState(s: S): M[Unit] = m.putState(s)
}
</code></pre>
<p>Composition of reader monad with StateMonadImpl.</p>
<pre><code class="language-scala">trait ReaderStateMonadImpl extends ReaderStateMonadForwarder {
  val m: StateMonadImpl { type S = ReaderStateMonadImpl.this.S } =
    new StateMonadImpl { type S = ReaderStateMonadImpl.this.S }
}
</code></pre>
<p>Now we use the monad library to modularize the interpreters of
the various language variants we have seen so far.</p>
<pre><code class="language-scala">trait Expressions extends Monad {
  abstract class Value
  abstract class Exp {
    def eval: M[Value]
  }
}

trait Numbers extends Expressions {
  case class NumV(n: Int) extends Value
}

trait Arithmetic extends Numbers {
  case class Num(n: Int) extends Exp {
    def eval = unit(NumV(n))
  }
  implicit def num2exp(n: Int): Exp = Num(n)

  case class Add(lhs: Exp, rhs: Exp) extends Exp {
    def eval = for {
                 l &lt;- lhs.eval
                 r &lt;- rhs.eval
               } yield (l, r) match {
                 case (NumV(v1), NumV(v2)) =&gt; NumV(v1 + v2)
                 case _ =&gt; sys.error(&quot;can only add numbers&quot;)
               }
  }
}

trait If0 extends Numbers {
  case class If0(cond: Exp, thenExp: Exp, elseExp: Exp) extends Exp {
    def eval = for {
                 c &lt;- cond.eval
                 res &lt;- c match {
                   case NumV(0) =&gt; thenExp.eval
                   case _ =&gt; elseExp.eval
                 }
               } yield res
  }
}

trait Functions extends Expressions with ReaderMonad {
  type Env = Map[String, Value]
  override type R = Env

  case class ClosureV(f: Fun, env: Env) extends Value
  case class Fun(param: String, body: Exp) extends Exp {
    def eval = for { env &lt;- ask } yield ClosureV(this, env)
  }
  case class Ap(f: Exp, a: Exp) extends Exp {
    def eval = for {
                 fv &lt;- f.eval
                 av &lt;- a.eval
                 res &lt;- fv match {
                   case ClosureV(fun, cenv) =&gt;
                     local(env =&gt; cenv + (fun.param -&gt; av), fun.body.eval)
                 }
               } yield res
  }
  case class Id(x: String) extends Exp {
    def eval = for {
                 env &lt;- ask
               } yield env(x)
  }
  implicit def id2exp(x: String): Exp = Id(x)
  def wth(x: String, xdef: Exp, body: Exp): Exp = Ap(Fun(x, body), xdef)
}


trait Boxes extends Expressions with StateMonad  {
  type Store = Map[Address, Value]
  override type S = Store

  type Address = Int
  var _nextAddress = 0

  def nextAddress: Address = {
    _nextAddress += 1
    _nextAddress
  }

  case class AddressV(a: Address) extends Value

  case class NewBox(e: Exp) extends Exp {
    def eval = {
      val a = nextAddress
      for {
        v &lt;- e.eval
        s &lt;- getState
        _ &lt;- putState(s + (a -&gt; v))
      } yield AddressV(a)
    }
  }
  case class SetBox(b: Exp, e: Exp) extends Exp {
    def eval =
      for {
         box &lt;- b.eval
         ev  &lt;- e.eval
         s   &lt;- getState
         _   &lt;- putState(box match { case AddressV(a) =&gt; s.updated(a, ev) })
      } yield ev
  }
  case class OpenBox(b: Exp) extends Exp {
    def eval = for {
                 bv &lt;- b.eval
                 s  &lt;- getState
               } yield (bv match { case AddressV(a) =&gt; s(a) })
  }
  case class Seq(e1: Exp, e2: Exp) extends Exp {
    def eval = bind(e1.eval, (_: Value) =&gt; e2.eval)
  }

}

trait Letcc extends Expressions with ContinuationMonad with ReaderMonad {
  override type R = Map[String, Value]

  // We introduce a new application form CAp instead of using Ap because we cannot extend Ap
  case class CAp(f: Exp, a: Exp) extends Exp {
    override def eval: M[Value] =
      for {
         fv &lt;- f.eval
         av &lt;- a.eval
         res &lt;- fv match { case ContV(f) =&gt; f(av) }
       } yield res
  }
  case class Letcc(param: String, body: Exp) extends Exp {
    override def eval: M[Value] =
      callcc[Value,Value](k =&gt; local(env =&gt; env + (param -&gt; ContV(k)), body.eval))
  }
  case class ContV(f: Value =&gt; M[Value]) extends Value
}
</code></pre>
<p>Let's compose together some languages!</p>
<pre><code class="language-scala">object AE extends Arithmetic with IdentityMonad {
  val aetest = Add(1, Add(2, 3))
}
assert(AE.aetest.eval == AE.NumV(6))

object FAELang extends Functions with Arithmetic with ReaderMonadImpl {
  val faetest = Ap(Fun(&quot;x&quot;, Add(&quot;x&quot;, 1)), Add(2, 3))
  assert(faetest.eval(Map.empty) == NumV(6))
}
object BCFAE extends Boxes with Arithmetic with Functions with If0 with ReaderStateMonadImpl {
  val test = wth(&quot;switch&quot;, NewBox(0),
                wth(&quot;toggle&quot;, Fun(&quot;dummy&quot;, If0(OpenBox(&quot;switch&quot;),
                                          Seq(SetBox(&quot;switch&quot;, 1), 1),
                                          Seq(SetBox(&quot;switch&quot;, 0), 0))),
                    Add(Ap(&quot;toggle&quot;, 42), Ap(&quot;toggle&quot;, 42))))
}

assert(BCFAE.test.eval(Map.empty)(Map.empty)._1 == BCFAE.NumV(1))

object FAEwLetcc extends Arithmetic with Functions with If0 with Letcc with ReaderContinuationMonadImpl {
  override type T = Value
  val testprog = Add(1, Letcc(&quot;k&quot;, Add(2, CAp(&quot;k&quot;, 3))))
}

assert(FAEwLetcc.testprog.eval(Map.empty)(identity) == FAEwLetcc.NumV(4))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monadic-reflection"><a class="header" href="#monadic-reflection">Monadic Reflection</a></h1>
<p>The content of this chapter is available as a Racket file <a href="23-monadic-reflection/./monadic-reflection.rkt">here.</a></p>
<pre><code class="language-racket">#lang racket

(require racket/control)
</code></pre>
<p>Monadic style can encode continuation-passing style:</p>
<p>Just use the continuation monad.</p>
<p>But the converse is also true in a certain sense that was
discovered by A. Filinski, who invented the notion of
&quot;monadic reflection&quot;. Here, we exemplify monadic reflection
in terms of the list monad, but it is straightforward
to abstract over the concrete monad and make this work
for every monad.</p>
<p>The list monad operations</p>
<pre><code class="language-racket">(define (return x) (list x))
(define (bind m f)
  (apply append (map f m)))
</code></pre>
<h2 id="monadic-reflection-filinski"><a class="header" href="#monadic-reflection-filinski">Monadic reflection (Filinski)</a></h2>
<pre><code class="language-racket">; List[A] -&gt; A (quasi-type)
(define (reflect m)
  (shift k (bind m k)))

; A -&gt; List[A] (quasi-type)
; this is a macro that transforms (reify e) into (reify-thunk (thunk e))
; its sole purpose is to prevent the evaluation of e and wrap it into a thunk
(define-syntaxes (reify)
     (syntax-rules ()
       [(_ e)
        (reify-thunk (thunk e))]))

(define (reify-thunk t)
  (reset (return (t))))
</code></pre>
<p>Now we can write direct-style programs (in this case: a direct-style + function), yet use monadic features.</p>
<pre><code class="language-racket">(reify (+ (reflect (list 1 2)) (reflect (list 3 4))))
</code></pre>
<p>More information in &quot;Representing Monads&quot; by A. Filinski:
https://doi.org/10.1145/174675.178047</p>
<p><strong>Example</strong>: Backtracking using monadic reflection: The <code>n</code>-queens problem.
If partial results are desired, lists should be replaced by streams.</p>
<pre><code class="language-racket">(define (fail) (reflect empty))

; Nat List[Nat] Nat -&gt; Bool
(define (safe x l n)
  (or (empty? l)
      (let ((c (first l)))
        (and (not (= x c))
             (not (= x (+ c n)))
             (not (= x (- c n)))
             (safe x (rest l) (+ n 1))))))

(define (queens n)
  (foldl (lambda (_ y)
           (let ((next (reflect (inclusive-range 1 n))))
             (if (safe next y 1)
                 (cons next y)
                 (fail))))
         empty
         (inclusive-range 1 n)))

(reify (queens 8))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defunctionalization"><a class="header" href="#defunctionalization">Defunctionalization</a></h1>
<p>The content of this chapter is available as a Scala file <a href="24-defunctionalization/./defunctionalization.scala">here.</a></p>
<p>The material in these notes is based on: John C. Reynolds: Definitional Interpreters for Higher-Order Programming Languages.
Higher-Order and Symbolic Computation 11(4): 363-397 (1998)</p>
<p>In the discussion of syntactic interpretation vs. meta interpretation we have learned that we only learn something about (and control)
a language feature if we choose syntactic interpretation.</p>
<p>Today we want to discuss techniques with which we can make our interpreter so syntactic that it corresponds to an abstract machine:
A machine with a (possibly infinite) set of states and a simple transition relation between the states. We already know the technique
with which we can take control over the call stack management: <em>CPS transformation</em>. After CPS-transforming the interpreter, we do not
rely on the order of evaluation and call stack management of the meta language anymore.  We replicate its definition here:</p>
<pre><code class="language-scala">enum Exp:
  case Num(n : Int)
  case Id(name : String)
  case Add(lhs : Exp, rhs : Exp)
  case Fun(param : String, body : Exp)
  case Ap (funExpr : Exp, argExpr : Exp)
import Exp._

implicit def num2exp(n: Int) : Exp = Num(n)
implicit def id2exp(s: String) : Exp = Id(s)

sealed abstract class Value
type Env = Map[String, Value]
case class NumV(n : Int) extends Value
case class ClosureV(f : Fun, env : Env) extends Value

object CPSTransformed {
  def eval[T](e : Exp, env : Env, k : Value =&gt; T) : T = e match {
    case Num(n : Int) =&gt; k(NumV(n))
    case Id(x) =&gt; k(env(x))
    case Add(l, r) =&gt;
      eval( l, env
          , lv =&gt; eval( r, env
                      , rv =&gt; (lv, rv) match {
                          case (NumV(v1), NumV(v2)) =&gt; k(NumV(v1 + v2))
                          case _ =&gt; sys.error(&quot;can only add numbers&quot;)
                        } ) )
    case f@Fun(param, body) =&gt; k(ClosureV(f, env))
    case Ap(f, a) =&gt;
      eval( f, env
          , cl =&gt; cl match {
              case ClosureV(f, closureEnv) =&gt;
                eval( a, env
                    , av =&gt; eval(f.body, closureEnv + (f.param -&gt; av), k) )
              case _ =&gt; sys.error(&quot;can only apply functions&quot;)
            } )
  }
}
</code></pre>
<p>However, the CPS-transformed interpreter still uses high-level features of the meta-language, most notably first-class functions.
We will now introduce one transformation that can be used to transform a function using higher-order functions into one using only
first-order functions.  It is general program transformation technique, not restricted only to interpreters.</p>
<h2 id="lambda-lifting"><a class="header" href="#lambda-lifting">Lambda Lifting</a></h2>
<p>The first of these techniques is <em>lambda lifting</em>. The goal of lambda lifting is to turn local functions into top-level functions.
That is, all &quot;lambdas&quot; only occur at the top-level. Variables in the local environment that are normally stored in the function's
closure are instead passed as parameters to the top-level function. Lambda lifting is accomplished by the following steps:</p>
<ol>
<li>Invent a new and unique name for each function that is not a top-level function.</li>
<li>Create a function with this name. Its body is the body of the former local function. Such a function will contain free variables.</li>
<li>Add a parameter to so-obtained top-level function for each free variable in its body.
Thus it becomes a higher-order function that returns a function when passed these arguments.</li>
<li>Replace the local function by a call to the new top-level function and pass the corresponding local context via the arguments
created in step 3.</li>
</ol>
<p><strong>Example</strong>: Let's lambda-lift the functions <code>y =&gt; y + n</code> and <code>y =&gt; y*n</code> in</p>
<pre><code class="language-scala">def map(f : Int =&gt; Int, xs : List[Int]) : List[Int] = xs match {
  case Nil =&gt; Nil
  case (x :: xs) =&gt; f(x) :: map(f, xs)
}

def addAndMultNToList(n : Int, xs : List[Int]) = map(y =&gt; y * n, map(y =&gt; y + n, xs))
</code></pre>
<p>We create two new top-level functions. Let's call them <code>f</code> and <code>g</code> Their bodies are respectively <code>y =&gt; y + n</code> and <code>y =&gt; y * n</code>.
We add a parameter for each free variable. In the example, the free variable is <code>n</code> in both cases:</p>
<pre><code class="language-scala">def fLam(n : Int) = (y : Int) =&gt; y + n
def gLam(n : Int) = (y : Int) =&gt; y * n
</code></pre>
<p>or shorter:</p>
<pre><code class="language-scala">def f(n : Int)(y : Int) = y + n
def g(n : Int)(y : Int) = y * n
</code></pre>
<p>The local function can now be replaced by a call to the new global function.</p>
<pre><code class="language-scala">def addAndMultNToListLifted(n : Int, xs : List[Int]) = map(g(n)(_), map(f(n)(_), xs))
</code></pre>
<p>Let's now perform the same technique to the CPS-transformed interpreter given above. It contains local functions in four places:
two in the <code>Add</code> branch and two in the <code>Ap</code> branch. We call the corresponding top-level functions, from left to right,
<code>addc1</code>, <code>addc2</code>, <code>ApC1</code> and <code>ApC2</code>.</p>
<p>An interesting novelty in the interpreter is that some local functions (corresponding to <code>addc1</code> and <code>ApC1</code>) create local
functions themselves. This means that <code>addc1</code> must call <code>addc2</code> and <code>ApC1</code> must call <code>ApC2</code>. The rest of the transformation
is a straightforward application of the transformation steps described above:</p>
<pre><code class="language-scala">object LambdaLifted {
  def addc1[T](r : Exp, env : Env, k : Value =&gt; T)(lv : Value) = eval(r, env, addc2(lv, k))

  def addc2[T](lv : Value, k : Value =&gt; T)(rv : Value) = (lv, rv) match {
    case (NumV(v1), NumV(v2)) =&gt; k(NumV(v1 + v2))
    case _ =&gt; sys.error(&quot;can only add numbers&quot;)
  }

  def ApC1[T](a : Exp, env : Env, k : Value =&gt; T)(cl : Value) = cl match {
    case ClosureV(f, closureEnv) =&gt; eval(a, env, ApC2(f, closureEnv, k))
    case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  }

  def ApC2[T](f : Fun, closureEnv : Env, k : Value =&gt; T)(av : Value) = eval(f.body, closureEnv + (f.param -&gt; av), k)

  def eval[T](e : Exp, env : Env, k : Value =&gt; T) : T = e match {
    case Num(n : Int) =&gt; k(NumV(n))
    case Id(x) =&gt; k(env(x))
    case Add(l, r) =&gt; eval(l, env, addc1(r, env, k))
    case f@Fun(param, body) =&gt; k(ClosureV(f, env))
    case Ap(f, a) =&gt; eval(f, env, ApC1(a, env, k))
  }
}
</code></pre>
<p>The lambda-lifted interpreter contains no local functions anymore, but it still contains higher-order functions, since <code>addc1</code> etc.
return functions that are passed as parameters to other functions.</p>
<h2 id="defunctionalization-1"><a class="header" href="#defunctionalization-1">Defunctionalization</a></h2>
<p><em>Defunctionalization</em> is a program transformation technique that turns higher-order programs that have already been lambda-lifted
into first-order programs that contain no higher-order functions anymore.  Any program contains only finitely many function definitions.
The idea of defunctionalization is to assign a unique identifier to each of these function definitions. The function <code>dispatch</code> then
happens in a function <code>apply</code>, which receives the identifier corresponding to a function definition and dispatches the identifier
to the right function body. Every function application within the program is then replaced by a call to the <code>apply</code> function with
the function identifier as the first argument.</p>
<p>In addition to the unique identifier, the <code>apply</code> function also needs bindings for the free variables in the function body.
Hence we need to store the values for these free variables along with the unique identifier. Finally, the <code>apply</code> function needs
to know about the argument to the function. These become additional parameters of the <code>apply</code> function.
Let's illustrate defunctionalization in the <code>addAndMultNToList</code> example from above.</p>
<pre><code class="language-scala">sealed abstract class FunctionValue
case class F(n : Int) extends FunctionValue
case class G(n : Int) extends FunctionValue

def apply(f : FunctionValue, y : Int) : Int = f match {
  case F(n) =&gt; y + n
  case G(n) =&gt; y * n
}

def map(f : FunctionValue, xs : List[Int]) : List[Int] = xs match {
  case Nil =&gt; Nil
  case (x :: xs) =&gt; apply(f, x) :: map(f, xs)
}

def addAndMultNToListDefun(n : Int, xs : List[Int]) = map(G(n), map(F(n), xs))
</code></pre>
<p>Let's now apply defunctionalization to our CPS-transformed interpreter:</p>
<pre><code class="language-scala">object Defunctionalized {

  sealed abstract class FunctionValue[T]
  case class AddC1[T](r : Exp, env : Env, k : FunctionValue[T]) extends FunctionValue[T]
  case class AddC2[T](lv : Value, k : FunctionValue[T]) extends FunctionValue[T]
  case class ApC1[T](a : Exp, env : Env, k : FunctionValue[T]) extends FunctionValue[T]
  case class ApC2[T](f : Fun, closureEnv : Env, k : FunctionValue[T]) extends FunctionValue[T]

  def apply[T](fv : FunctionValue[T], v : Value) : T  = fv match {
    case AddC1(r, env, k) =&gt; eval(r, env, AddC2(v, k))
    case AddC2(lv, k) =&gt; (lv, v) match {
      case (NumV(v1), NumV(v2)) =&gt; apply(k, NumV(v1 + v2))
      case _ =&gt; sys.error(&quot;can only add numbers&quot;)
    }
    case ApC1(a, env, k) =&gt; v match {
      case ClosureV(f, closureEnv) =&gt; eval(a, env, ApC2(f, closureEnv, k))
      case _ =&gt; sys.error(&quot;can only apply functions&quot;)
    }
    case ApC2(f, closureEnv, k) =&gt; eval(f.body, closureEnv + (f.param -&gt; v), k)
  }

  def eval[T](e : Exp, env : Env, k : FunctionValue[T]) : T = e match {
    case Num(n : Int) =&gt; apply(k, NumV(n))
    case Id(x) =&gt; apply(k, env(x))
    case Add(l, r) =&gt; eval(l, env, AddC1(r, env, k))
    case f@Fun(param, body) =&gt; apply(k, ClosureV(f, env))
    case Ap(f, a) =&gt; eval(f, env, ApC1(a, env, k))
  }
}
</code></pre>
<p>This interpreter can be seen as an abstract machine. The state space of the abstract machine is
(<code>Exp</code> x <code>Env</code> x <code>FunctionValue</code>) U (<code>FunctionValue</code> x <code>Value</code>), where &quot;x&quot; stands for cross product and &quot;U&quot; stands for set union.
Every case in the pattern matches in <code>apply</code> and <code>eval</code> can be read as a transition in this state space.</p>
<h2 id="from-interpreter-to-abstract-machine"><a class="header" href="#from-interpreter-to-abstract-machine">From Interpreter to Abstract Machine</a></h2>
<p>To see that we can read the above functions as transitions of an abstract machine, let's actually
construct that machine.
Its domain of States is the type <code>MachineState[T]</code>.
The final state of the machine is <code>Done(v)</code>, for some value <code>v</code>.
Its transition function is the function named <code>transition</code>.
We can see every intermediate state of the abstract machine.
Its state is fully described by the (first-order) state type. We are no
longer dependent on call-stack management or higher-order functions of
the meta language (Scala)</p>
<pre><code class="language-scala">object AbstractMachine {
  sealed abstract class FunctionValue[T]
  case class AddC1[T](r : Exp, env : Env, k : FunctionValue[T]) extends FunctionValue[T]
  case class AddC2[T](lv : Value, k : FunctionValue[T]) extends FunctionValue[T]
  case class ApC1[T](a : Exp, env : Env, k : FunctionValue[T]) extends FunctionValue[T]
  case class ApC2[T](f : Fun, closureEnv : Env, k : FunctionValue[T]) extends FunctionValue[T]
  case class IdentityFV() extends FunctionValue[Value]

  sealed abstract class MachineState[T]
  case class EvalState[T](e: Exp, env: Env, fv: FunctionValue[T]) extends MachineState[T]
  case class ApplyState[T](fv: FunctionValue[T], v: Value) extends MachineState[T]
  case class Done(v: Value) extends MachineState[Value]

  def transition[T](s: MachineState[T]) : MachineState[T] =  
    s match {
      case EvalState(e,env,k) =&gt; transitionEval(e,env,k)
      case ApplyState(fv,v) =&gt; transitionApply(fv,v)
      case Done(v) =&gt; sys.error(&quot;already done&quot;)
    }

  def transitionEval[T](e: Exp, env: Env, k: FunctionValue[T]) : MachineState[T] = e match {
    case Num(n: Int) =&gt; ApplyState(k, NumV(n))
    case Id(x) =&gt; ApplyState(k,env(x))
    case Add(l,r) =&gt;
      EvalState(l, env,AddC1(r,env,k))
    case f@Fun(param,body) =&gt; ApplyState(k,ClosureV(f,env))         
    case Ap(f,a) =&gt;  EvalState(f, env, ApC1(a,env,k))
   }

   def transitionApply[T](fv: FunctionValue[T], v: Value) : MachineState[T] = fv match {
    case IdentityFV() =&gt; Done(v)
    case AddC1(r,env,k) =&gt; EvalState(r,env,AddC2(v,k))
    case AddC2(lv,k) =&gt; (lv,v) match {
          case (NumV(v1),NumV(v2)) =&gt; ApplyState(k, NumV(v1+v2))
          case _ =&gt; sys.error(&quot;can only add numbers&quot;)
         }
    case ApC1(a,env,k) =&gt; v match {
        case ClosureV(f, closureEnv) =&gt; EvalState(a, env, ApC2(f,closureEnv,k))
        case _ =&gt; sys.error(&quot;can only apply functions&quot;)
    }
    case ApC2(f,closureEnv,k) =&gt; EvalState(f.body, closureEnv + (f.param -&gt; v),k)
  }
}
import AbstractMachine._
</code></pre>
<p>Now let's try this out with a concrete example and look at the tract of transitions</p>
<pre><code class="language-scala">val test = Ap(Fun(&quot;x&quot;,Add(&quot;x&quot;,1)),5)  
// test: Exp = Ap(
//   funExpr = Fun(param = &quot;x&quot;, body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))),
//   argExpr = Num(n = 5)
// )  
val initMS : MachineState[Value] = EvalState(test,Map.empty,IdentityFV())
// initMS: MachineState[Value] = EvalState(
//   e = Ap(
//     funExpr = Fun(
//       param = &quot;x&quot;,
//       body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))
//     ),
//     argExpr = Num(n = 5)
//   ),
//   env = Map(),
//   fv = IdentityFV()
// )
val s1 = transition(initMS)
// s1: MachineState[Value] = EvalState(
//   e = Fun(param = &quot;x&quot;, body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))),
//   env = Map(),
//   fv = ApC1(a = Num(n = 5), env = Map(), k = IdentityFV())
// )
val s2 = transition(s1)   
// s2: MachineState[Value] = ApplyState(
//   fv = ApC1(a = Num(n = 5), env = Map(), k = IdentityFV()),
//   v = ClosureV(
//     f = Fun(param = &quot;x&quot;, body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))),
//     env = Map()
//   )
// )   
val s3 = transition(s2)   
// s3: MachineState[Value] = EvalState(
//   e = Num(n = 5),
//   env = Map(),
//   fv = ApC2(
//     f = Fun(param = &quot;x&quot;, body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))),
//     closureEnv = Map(),
//     k = IdentityFV()
//   )
// )   
val s4 = transition(s3)   
// s4: MachineState[Value] = ApplyState(
//   fv = ApC2(
//     f = Fun(param = &quot;x&quot;, body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))),
//     closureEnv = Map(),
//     k = IdentityFV()
//   ),
//   v = NumV(n = 5)
// )   
val s5 = transition(s4)  
// s5: MachineState[Value] = EvalState(
//   e = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1)),
//   env = Map(&quot;x&quot; -&gt; NumV(n = 5)),
//   fv = IdentityFV()
// )  
val s6 = transition(s5)   
// s6: MachineState[Value] = EvalState(
//   e = Id(name = &quot;x&quot;),
//   env = Map(&quot;x&quot; -&gt; NumV(n = 5)),
//   fv = AddC1(r = Num(n = 1), env = Map(&quot;x&quot; -&gt; NumV(n = 5)), k = IdentityFV())
// )   
val s7 = transition(s6)   
// s7: MachineState[Value] = ApplyState(
//   fv = AddC1(r = Num(n = 1), env = Map(&quot;x&quot; -&gt; NumV(n = 5)), k = IdentityFV()),
//   v = NumV(n = 5)
// )   
val s8 = transition(s7)
// s8: MachineState[Value] = EvalState(
//   e = Num(n = 1),
//   env = Map(&quot;x&quot; -&gt; NumV(n = 5)),
//   fv = AddC2(lv = NumV(n = 5), k = IdentityFV())
// )
val s9 = transition(s8)  
// s9: MachineState[Value] = ApplyState(
//   fv = AddC2(lv = NumV(n = 5), k = IdentityFV()),
//   v = NumV(n = 1)
// )  
val s10 = transition(s9)  
// s10: MachineState[Value] = ApplyState(fv = IdentityFV(), v = NumV(n = 6))  
val s11 = transition(s10)
// s11: MachineState[Value] = Done(v = NumV(n = 6))
</code></pre>
<p>We can also automate this into a function that collects the list of all states.</p>
<pre><code class="language-scala">def evalMachine(e: Exp) : List[MachineState[Value]] =
{
  val initMS : MachineState[Value] = EvalState(e,Map.empty,IdentityFV())
  List.unfold(initMS)({ case Done(v) =&gt; None
                        case s =&gt; { val s2 = transition(s); Some((s,s2))}})
}

val q = evalMachine(test)
// q: List[MachineState[Value]] = List(
//   EvalState(
//     e = Ap(
//       funExpr = Fun(
//         param = &quot;x&quot;,
//         body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))
//       ),
//       argExpr = Num(n = 5)
//     ),
//     env = Map(),
//     fv = IdentityFV()
//   ),
//   EvalState(
//     e = Fun(param = &quot;x&quot;, body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))),
//     env = Map(),
//     fv = ApC1(a = Num(n = 5), env = Map(), k = IdentityFV())
//   ),
//   ApplyState(
//     fv = ApC1(a = Num(n = 5), env = Map(), k = IdentityFV()),
//     v = ClosureV(
//       f = Fun(param = &quot;x&quot;, body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))),
//       env = Map()
//     )
//   ),
//   EvalState(
//     e = Num(n = 5),
//     env = Map(),
//     fv = ApC2(
//       f = Fun(param = &quot;x&quot;, body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))),
//       closureEnv = Map(),
//       k = IdentityFV()
//     )
//   ),
//   ApplyState(
//     fv = ApC2(
//       f = Fun(param = &quot;x&quot;, body = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1))),
//       closureEnv = Map(),
//       k = IdentityFV()
//     ),
//     v = NumV(n = 5)
//   ),
//   EvalState(
//     e = Add(lhs = Id(name = &quot;x&quot;), rhs = Num(n = 1)),
//     env = Map(&quot;x&quot; -&gt; NumV(n = 5)),
//     fv = IdentityFV()
//   ),
//   EvalState(
//     e = Id(name = &quot;x&quot;),
//     env = Map(&quot;x&quot; -&gt; NumV(n = 5)),
// ...
</code></pre>
<h2 id="refunctionalization"><a class="header" href="#refunctionalization">Refunctionalization</a></h2>
<p>Can we also invert defunctionalization? That is, can we represent a
program such that a data type is replaced by a function type?</p>
<p>Let's look at an example.</p>
<pre><code class="language-scala">enum MyList[T]:
  case MyEmptyList[T]() extends MyList[T]
  case MyCons[T](x: T, xs: MyList[T]) extends MyList[T]

import MyList._

def nth[T](l: MyList[T], i: Int) : T = l match {
  case MyEmptyList() =&gt; sys.error(&quot;index out of range&quot;)
  case MyCons(x,xs) =&gt; if (i==0) then x  else nth(xs,i-1)
}
</code></pre>
<p>Refunctionalization works smoothly when there is just one pattern match on
a data type. In this case, we represent a list by &quot;its&quot; <code>nth</code> function:</p>
<pre><code class="language-scala">type MyListR[T] = Int =&gt; T

def myEmptyList[T] : MyListR[T] = _ =&gt; sys.error(&quot;index out of range&quot;)
def myCons[T](x: T,  xs: MyListR[T]) : MyListR[T] =
  i =&gt; if (i==0) then x  else xs(i-1)
</code></pre>
<p>The defunctionalized and the refunctionalized lists differ in their modular structure.
In the defunctionalized version, it is &quot;easy&quot; (only addition of code but no modification
of existing code necessary) to add new functions that pattern-match on lists, such
as a <code>length</code>function.</p>
<pre><code class="language-scala">def length[T](l: MyList[T]) : Int = l match {
  case MyEmptyList() =&gt; 0
  case MyCons(x,xs) =&gt; 1 + length(xs)
}
</code></pre>
<p>In the refunctionalized version, on the other hand, it is &quot;easy&quot; to add new ways to create lists.
For instance, here is a constructor for the infinite list of numbers</p>
<pre><code class="language-scala">def allNats : MyListR[Int] = i =&gt; i
</code></pre>
<p>The two versions hence corresponds to the two dimensions of the aforementioned &quot;expression problem&quot;.
These program  transformations are hence generally applicable program transformations in
a programmer's modularity toolbox.</p>
<p>But what about refunctionalization in the case that there is more than one pattern-match on the
data type? It turns out that we can refunctionalize if we generalize functions to objects, that is,
if we view functions as special kinds of objects with a single <code>apply</code> method.</p>
<p>For instance, in the case of lists with two pattern-matching functions, <code>nth</code> and <code>length</code>,
we can represent lists as <em>objects</em> with two methods, one for each pattern match.</p>
<pre><code class="language-scala">trait MyListRO[T] {
  def nth(i: Int) : T
  def length : Int  
}

def myEmptyListO[T] : MyListRO[T] = new MyListRO[T] {
  def nth(i: Int) : T = sys.error(&quot;index out of range&quot;)
  def length : Int = 0
}

def myConsO[T](x: T,  xs: MyListRO[T]) : MyListRO[T] = new MyListRO[T] {
  def nth(i: Int) : T = if (i==0) then x  else xs.nth(i-1)
  def length : Int =  1 + xs.length
}
</code></pre>
<p>With this generalization, we can defunctionalize any object type (the transformation
could then maybe be called &quot;deobjectionalization&quot;) and we can refunctionalize any
algebraic data type, and thereby completely invert the extensibility of the program.</p>
<p>Recall that both transformations are <em>global</em> and not compositional, that is, the full program must be
transformed at once.</p>
<p>We have glossed over some technical details that would need to be addressed to automate
these transformations and make them inverse to each other. For instance, we have not
addressed how to reverse the lambda lifting part.</p>
<p>Historical notes: Defunctionalization was proposed by John Reynolds in 1972 in his landmark
paper &quot;Definitional Interpreters for Higher-Order Programming Languages&quot;.
Similar to these lecture notes, Reynolds applied defunctionalization to a CPS-transformed interpreter.
The generalization of refunctionalization to use objects instead of functions was presented
in a 2015 paper by Rendel, Trieflinger, and Ostermann entitled &quot;Automatic Refunctionalization to a Language with Copattern Matching: With Applications to the Expression Problem&quot;. A fully formal account
of the transformations that also addresses invertible lambda lifting and proves that the
transformations are inverses of each other can be found in the 2020 paper &quot;Decomposition Diversity with Symmetric Data and Codata&quot; by Binder, Jabs, Skupin and Ostermann.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-systems"><a class="header" href="#type-systems">Type Systems</a></h1>
<p>The content of this chapter is available as a Scala file <a href="25-type-systems/./type-systems.scala">here.</a></p>
<h1 id="type-systems-1"><a class="header" href="#type-systems-1">Type Systems</a></h1>
<p>The aim of type systems is to prevent certain classes of errors to occur at runtime. Examples of such errors include the addition of
a number to a function, or the usage of a free variable. There can be many different type systems for the same programming language.
A sound type systems guarantees that the errors that the type system aims to prevent will not occur in <em>any</em> run of the program.
This is different from testing, in which only a single program run on some particular input data is considered.</p>
<p>Since - by Rice's theorem - all interesting properties of the runtime behavior of a program (in a Turing complete language) are undecidable,
type systems are necessarily imperfect. But they are usually designed in such a way that the errors are directed:</p>
<p>Each type system unfairly rejects some programs that could be executed without runtime errors. But programs that are accepted by the
type system will never produce one of the precluded runtime errors. The latter property is usually called <em>soundness</em>,
the former property <em>completeness</em>. Hence we can say that most type systems are sound but not complete. One also often says that
type systems are <em>conservative</em>. A conservative approximation of the behavior of a program is one that considers all possible program
runs but also some impossible program runs - an overapproximation.</p>
<p>Well-typedness is usually a context-sensitive property, hence it cannot be expressed in the (context-free) grammar of the language
but is defined as an additional filter which rules out some syntactically correct programs.
Let's look at a small toy language to illustrate type systems:</p>
<pre><code class="language-scala">enum Exp:
  case Num(n: Int)
  case Add(lhs: Exp, rhs: Exp)
  case Bool(x: Boolean)
  case If(cond: Exp, thenExp: Exp, els: Exp)

object Exp:
  implicit def num2exp(n: Int): Exp = Num(n)
  implicit def bool2exp(x: Boolean): Exp = Bool(x)

import Exp._

def eval(e: Exp) : Exp = e match {
  case Add(l,r) =&gt; (eval(l), eval(r)) match {
                     case (Num(x),Num(y)) =&gt; Num(x+y)
                     case _ =&gt; sys.error(&quot;can only add numbers&quot;)
                    }
  case If(cond,thenExp,els) =&gt;
    eval(cond) match {
      case Bool(true) =&gt; eval(thenExp)
      case Bool(false) =&gt; eval(els)
      case _ =&gt; sys.error(&quot;Condition must be boolean&quot;)
    }
  case _ =&gt; e
}
</code></pre>
<p>In this language, we can see that two different types of runtime errors can occur:
An addition where one of the operands is not a number, or an <code>if</code>-expression where the condition
does not evaluate to a boolean.</p>
<p>Here are a few syntactically correct programs. Only the first three execute correctly. The
other ones yield runtime errors.</p>
<pre><code class="language-scala">val ex1 = Add(3,5)
val ex2 = If(true, 7, 5)
val ex2b = If(true, 7, true)
val ex3 = If(Add(3,4), 7, true)
val ex4 = Add(true,3)
</code></pre>
<p>Let's now design a type system for this language. Most type systems entail a classification of the values into different types.
In this type system, we choose to define two types, one called BoolType and one called IntType.</p>
<pre><code class="language-scala">enum Type:
  case BoolType()
  case IntType()
import Type._
</code></pre>
<p>A type checker is a compositional assignment of types (or type errors) to expressions. Compositionality means that the type of a
composite expression is computed from the type of its subexpressions. Compositionality is quite important for reasoning about types.
In this case, the type checker is a rather straightforward structural recursion ( = compositionality) over expressions.</p>
<pre><code class="language-scala">def typeCheck(e: Exp) : Type = e match {
  case Num(n) =&gt; IntType()
  case Bool(x) =&gt; BoolType()
  case Add(a,b) =&gt; (typeCheck(a),typeCheck(b)) match {
    case (IntType(),IntType()) =&gt; IntType()
    case _ =&gt; sys.error(&quot;Type Error in addition&quot;)
  }
  case If(c,t,e) =&gt; (typeCheck(c), typeCheck(t), typeCheck(e)) match {
    case (BoolType(),t1,t2) =&gt; if (t1 == t2) t1 else sys.error(&quot;type error in if&quot;)
    case _ =&gt; sys.error(&quot;Type error in If&quot;)
  }
}
</code></pre>
<h2 id="type-soundness"><a class="header" href="#type-soundness">Type Soundness</a></h2>
<p>If we typecheck the examples from above with the algorithm, we can see that it rejects all programs that lead to runtime errors,
and it also (unfairly) rejects one program that can be executed without error. Hence the type system is conservative, as expected.
We can now say more precisely what we mean by soundness of the type checker, namely that it correctly predicts the kind of value that
the interpreter will produce:</p>
<p>If <code>e</code> is an expression and <code>typeCheck(e)</code> yields a type <code>t</code>, thenExp <code>eval(e)</code> yields a value <code>v</code> such that <code>typeCheck(v) == t</code>.
This statement of type soundness has to be changed a bit when we have a programming language with non-terminating programs.
Then it will have the following form:</p>
<p>If <code>e</code> is an expression and <code>typeCheck(e)</code> yields a type <code>t</code>, thenExp <code>eval(e)</code> either diverges, or it yields a value <code>v</code>
such that <code>typeCheck(v) == t</code>, but it does not terminate with a runtime error.
In the most general case, we also have runtime errors that are not captured by the type system. In this case we have to restrict
the last part of the sentence to those runtime errors that are captured by the type system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simply-typed-lambda-calculus"><a class="header" href="#simply-typed-lambda-calculus">Simply Typed Lambda Calculus</a></h1>
<p>The content of this chapter is available as a Scala file <a href="26-stlc/./stlc.scala">here.</a></p>
<h1 id="the-simply-typed-lambda-calculus"><a class="header" href="#the-simply-typed-lambda-calculus">The Simply-Typed Lambda Calculus</a></h1>
<p>We start with the untyped substitution-based lambda calculus augmented by the possibility to add type annotations to function definitions.
The type annotation is ignored by the interpreter.
Why are we using the substitution-based interpreter? Because it is simpler to state the type soundness
theorem. If we had values that are separate from expressions, we would need to define a type system for
these values. This is particularly tricky for closures with their embedded environments.</p>
<p>We also show a couple of standard extensions to the simply-typed lambda calculus:</p>
<ol>
<li>A unit type JunitType() with associated term JUnit()</li>
<li>Let-bindings (which don't need type annotations)</li>
<li>Type Ascription (corresponding to &quot;::&quot; in Scala, like &quot;5 + 3 :: Int&quot;)</li>
<li>Products (or Pairs, more specifically)</li>
<li>Sums (binary sums, more specifically)
To avoid the problem of &quot;guessing&quot; the &quot;from&quot; type in a function definition, we annotate
function definitions with the expected argument type.</li>
</ol>
<pre><code class="language-scala">sealed abstract class Type

enum Exp:
  case Num(n: Int)
  case Id(name: String)
  case Add(lhs: Exp, rhs: Exp)
  case Fun(param: String, t: Type, body: Exp)
  case Ap (funExpr: Exp, argExpr: Exp)
  case Junit()
  case Let(x: String, xdef: Exp, body: Exp)
  case TypeAscription(e: Exp, t: Type)

  case Product(e1: Exp, e2: Exp)
  case Fst(e: Exp)
  case Snd(e: Exp)

  case SumLeft(left: Exp, right: Type)
  case SumRight(left: Type, right: Exp)
  case EliminateSum(e: Exp, fl: Exp, fr: Exp)

object Exp:
  implicit def num2exp(n: Int): Exp = Num(n)
  implicit def id2exp(s: String): Exp = Id(s)

import Exp._

def freshName(names: Set[String], default: String) : String = {
  var last : Int = 0
  var freshName = default
  while (names contains freshName) { freshName = default+last.toString; last += 1; }
  freshName
}

def freeVars(e: Exp) : Set[String] =  e match {
   case Id(x) =&gt; Set(x)
   case Add(l,r) =&gt; freeVars(l) ++ freeVars(r)
   case Fun(x,_,body) =&gt; freeVars(body) - x
   case Ap(f,a) =&gt; freeVars(f) ++ freeVars(a)
   case Num(n) =&gt; Set.empty
   case Junit() =&gt; Set.empty
   case TypeAscription(e,t) =&gt; freeVars(e)
   case Let(x,xdef,body) =&gt; freeVars(xdef) ++ (freeVars(body) - x)
   case Product(e1,e2) =&gt; freeVars(e1) ++ freeVars(e2)
   case Fst(e) =&gt; freeVars(e)
   case Snd(e) =&gt; freeVars(e)
   case SumLeft(e,_) =&gt; freeVars(e)
   case SumRight(_,e) =&gt; freeVars(e)
   case EliminateSum(e,fl,fr) =&gt; freeVars(e) ++ freeVars(fl) ++ freeVars(fr)
}

def subst(e1 : Exp, x: String, e2: Exp) : Exp = e1 match {
  case Num(n) =&gt; e1
  case Junit() =&gt; e1
  case Add(l,r) =&gt; Add(subst(l,x,e2), subst(r,x,e2))
  case Id(y) =&gt; if (x == y) e2 else Id(y)
  case Ap(f,a) =&gt; Ap(subst(f,x,e2),subst(a,x,e2))
  case TypeAscription(e,t) =&gt; TypeAscription(subst(e,x,e2),t)
  case Fun(param,t,body) =&gt;
    if (param == x) e1 else {
      val fvs = freeVars(body) ++ freeVars(e2)
      val newvar = freshName(fvs, param)
      Fun(newvar, t,subst(subst(body, param, Id(newvar)), x, e2))
    }
  case Let(y,ydef,body) =&gt;
    if (x == y) Let(y,subst(ydef,x,e2),body) else {
      val fvs = freeVars(body) ++ freeVars(e2)
      val newvar = freshName(fvs,y)
      Let(newvar,subst(ydef,x,e2),subst(subst(body,y,Id(newvar)),x,e2))
    }
  case Product(a,b) =&gt; Product(subst(a,x,e2),subst(b,x,e2))
  case Fst(e) =&gt; Fst(subst(e,x,e2))
  case Snd(e) =&gt; Snd(subst(e,x,e2))
  case SumLeft(e,t) =&gt; SumLeft(subst(e,x,e2),t)
  case SumRight(t,e) =&gt; SumRight(t,subst(e,x,e2))
  case EliminateSum(e,fl,fr) =&gt; EliminateSum(subst(e,x,e2),subst(fl,x,e2),subst(fr,x,e2))
}

def eval(e: Exp) : Exp = e match {
  case Id(v) =&gt; sys.error(&quot;unbound identifier: &quot; + v)
  case Add(l,r) =&gt; (eval(l), eval(r)) match {
                     case (Num(x),Num(y)) =&gt; Num(x+y)
                     case _ =&gt; sys.error(&quot;can only add numbers&quot;)
                    }
  case Ap(f,a) =&gt; eval(f) match {
     case Fun(x,_,body) =&gt; eval( subst(body,x, eval(a)))  // call-by-value
     case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  }
  case TypeAscription(e,_) =&gt; eval(e)
  case Let(x,xdef,body) =&gt; eval(subst(body,x,eval(xdef)))
  case Product(a,b) =&gt; Product(eval(a),eval(b))
  case Fst(e) =&gt; eval(e) match {
    case Product(a,b) =&gt; a
    case _ =&gt; sys.error(&quot;can only apply Fst to products&quot;)
  }
  case Snd(e) =&gt; eval(e) match {
    case Product(a,b) =&gt; b
    case _ =&gt; sys.error(&quot;can only apply Snd to products&quot;)
  }
  case SumLeft(e,t) =&gt; SumLeft(eval(e),t)
  case SumRight(t,e) =&gt; SumRight(t,eval(e))
  case EliminateSum(e,fl,fr) =&gt; eval(e) match {
    case SumLeft(e2,_) =&gt; eval(Ap(fl,e2))
    case SumRight(_,e2) =&gt; eval(Ap(fr,e2))
    case _ =&gt; sys.error(&quot;can only eliminate sums&quot;)
  }
  case _ =&gt; e // numbers and functions evaluate to themselves
}
</code></pre>
<p>We classify values into three types: Booleans, integers, and function types. For function types, we need some abstraction for its input
and output; otherwise the type checker cannot be compositional. Luckily we do already have such an abstraction, namely types.
Hence <code>Funtype</code> becomes a recursive data type.</p>
<pre><code class="language-scala">case class NumType() extends Type
case class FunType(from: Type, to: Type) extends Type
case class JunitType() extends Type
case class ProductType(fst: Type, snd: Type) extends Type
case class SumType(left: Type, right: Type) extends Type
</code></pre>
<p>The type checker for the so-called <em>Simply-Typed Lambda Calculus</em>  (STLC). To deal with identifiers, we need an abstraction of environments.
A type environment has the form <code>Map[String,Type]</code>.</p>
<p>The type checker for the STLC is as follows:</p>
<pre><code class="language-scala">def typeCheck(e: Exp, gamma: Map[String,Type]) : Type = e match {
  case Num(n) =&gt; NumType()
  case Junit() =&gt; JunitType()
  case Id(x) =&gt; gamma.get(x) match {
    case Some(t) =&gt; t
    case _ =&gt; sys.error(&quot;free variable: &quot; ++ x.toString)
  }
  case Add(l,r) =&gt; (typeCheck(l,gamma),typeCheck(r,gamma)) match {
    case (NumType(),NumType()) =&gt; NumType()
    case _ =&gt; sys.error(&quot;Type error in Add&quot;)
  }
  case Fun(x,t,body) =&gt; FunType(t, typeCheck(body, gamma + (x -&gt; t)))
  case Ap(f,a) =&gt; {
    typeCheck(f,gamma) match {
      case FunType(from,to) =&gt; if (from == typeCheck(a,gamma)) to else sys.error(&quot;type error: arg does not match expected type&quot;)
      case _ =&gt; sys.error(&quot;first operand of app must be a function&quot;)
    }
  }
  case Let(x,xdef,body) =&gt; typeCheck(body, gamma + (x -&gt; typeCheck(xdef,gamma)))
  case TypeAscription(e,t) =&gt; if (typeCheck(e,gamma) == t) t else sys.error(&quot;type error in ascription&quot;)
  case Product(e1,e2) =&gt; ProductType(typeCheck(e1,gamma),typeCheck(e2,gamma))
  case Fst(e) =&gt; typeCheck(e,gamma) match {
    case ProductType(t1,t2) =&gt; t1
    case _ =&gt; sys.error(&quot;can only project Products&quot;)
  }
  case Snd(e) =&gt; typeCheck(e,gamma) match {
    case ProductType(t1,t2) =&gt; t2
    case _ =&gt; sys.error(&quot;can only project Products&quot;)
  }
  case SumLeft(e,t) =&gt; SumType(typeCheck(e,gamma), t)
  case SumRight(t,e) =&gt; SumType(t, typeCheck(e,gamma))
  case EliminateSum(e,fl,fr) =&gt; typeCheck(e,gamma) match {
    case SumType(left,right) =&gt; (typeCheck(fl,gamma), typeCheck(fr,gamma)) match {
      case (FunType(leftf,t1),FunType(rightf,t2)) if ((left == leftf) &amp;&amp; (right == rightf)) =&gt;
        if (t1 == t2) t1 else sys.error(&quot;type error: functions must have same return type&quot;)
      case _ =&gt; sys.error(&quot;type error in EliminateSum: second and third argument must be functions&quot;)
    }
    case _ =&gt; sys.error(&quot;type error: can only eliminate sums&quot;)
  }

}
</code></pre>
<p>Soundness of Simply-Typed Lambda Calculus (STLC) :
<code>If e : Exp und typeCheck(e,Map.empty) == t, then typeCheck(eval(e),Map.empty) == t</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h1>
<p>The content of this chapter is available as a Scala file <a href="27-type-inference/./type-inference.scala">here.</a></p>
<p>Hindley-Milner type inference with let-polymorphism:</p>
<pre><code class="language-scala">enum Type:
  case FunType(from: Type, to: Type)
  case NumType()
  case TypeVar(x: String)
import Type._

def freeTypeVars(t: Type) : Set[String] = t match {
  case FunType(f,t) =&gt; freeTypeVars(f) ++ freeTypeVars(t)
  case NumType() =&gt; Set.empty
  case TypeVar(x) =&gt; Set(x)
}

def substitution(x: String, s: Type) = new Function[Type,Type] {
  def apply(t: Type) = t match {
    case FunType(from,to) =&gt; FunType(this(from),this(to))
    case NumType() =&gt; NumType()
    case TypeVar(y) =&gt; if (x==y) s else TypeVar(y)
  }
}
</code></pre>
<p>Robinson unification algorithm:</p>
<pre><code class="language-scala">def unify(eq: List[(Type,Type)]) : Type =&gt; Type = eq match {
  case Nil =&gt; identity _
  case (NumType(),NumType()) :: rest =&gt; unify(rest)
  case (FunType(f1,t1),FunType(f2,t2)) :: rest =&gt; unify((f1,f2) :: (t1,t2) :: rest)
  case (TypeVar(x),TypeVar(y)) :: rest if x == y =&gt; unify(rest)
  case (TypeVar(x),t) :: rest =&gt; {
    if (freeTypeVars(t)(x)) sys.error(s&quot;Occurs check: $x occurs in $t&quot;)
    val s = substitution(x,t)
    s.andThen(unify(rest.map(p =&gt; (s(p._1),s(p._2)))))
  }
  case (t,TypeVar(x)) :: rest =&gt; unify((TypeVar(x),t) :: rest)
  case (t1,t2) :: rest =&gt; sys.error(s&quot;Cannot unify $t1 and $t2&quot;)
}


enum Exp:
  case Num(n: Int)
  case Id(name: String)
  case Add(lhs: Exp, rhs: Exp)
  case Fun(param: String, body: Exp) // No type annotation!
  case Ap (funExpr: Exp, argExpr: Exp)
  case Let(x: String, xdef: Exp, body: Exp)

object Exp:
  implicit def num2exp(n: Int): Exp = Num(n)
  implicit def id2exp(s: String): Exp = Id(s)

import Exp._

def freshName(names: Set[String], default: String) : String = {
  var last : Int = 0
  var freshName = default
  while (names contains freshName) { freshName = default+last.toString; last += 1; }
  freshName
}

def freeVars(e: Exp) : Set[String] =  e match {
   case Id(x) =&gt; Set(x)
   case Add(l,r) =&gt; freeVars(l) ++ freeVars(r)
   case Fun(x,body) =&gt; freeVars(body) - x
   case Ap(f,a) =&gt; freeVars(f) ++ freeVars(a)
   case Num(n) =&gt; Set.empty
   case Let(x,xdef,body) =&gt; freeVars(xdef) ++ (freeVars(body) - x)
}

def subst(e1 : Exp, x: String, e2: Exp) : Exp = e1 match {
  case Num(n) =&gt; e1
  case Add(l,r) =&gt; Add(subst(l,x,e2), subst(r,x,e2))
  case Id(y) =&gt; if (x == y) e2 else Id(y)
  case Ap(f,a) =&gt; Ap(subst(f,x,e2),subst(a,x,e2))
  case Fun(param,body) =&gt;
    if (param == x) e1 else {
      val fvs = freeVars(body) ++ freeVars(e2)
      val newvar = freshName(fvs, param)
      Fun(newvar,subst(subst(body, param, Id(newvar)), x, e2))
    }
  case Let(y,ydef,body) =&gt;
    if (x == y) Let(y,subst(ydef,x,e2),body) else {
      val fvs = freeVars(body) ++ freeVars(e2)
      val newvar = freshName(fvs,y)
      Let(newvar,subst(ydef,x,e2),subst(subst(body,y,Id(newvar)),x,e2))
    }
}

var tyvCount : Int = 0
// tyvCount: Int = 0
def freshTypeVar: TypeVar = {
  tyvCount += 1
  TypeVar(&quot;X&quot;+tyvCount.toString)
}

def typeCheck(e: Exp, gamma: Map[String,Type]) : (List[(Type,Type)],Type) = e match {
  case Num(n) =&gt; (List.empty, NumType())
  case Id(x) =&gt; gamma.get(x) match {
    case Some(t) =&gt; (List.empty, t)
    case _ =&gt; sys.error(&quot;free variable: &quot; ++ x.toString)
  }
  case Add(l,r) =&gt; (typeCheck(l,gamma),typeCheck(r,gamma)) match {
    case ((eq1,t1),(eq2,t2)) =&gt; ((t1,NumType()) :: (t2,NumType()) :: (eq1++eq2), NumType())
  }
  case Fun(x,body) =&gt; {
    val xtype = freshTypeVar
    val resbody = typeCheck(body, gamma + (x -&gt; xtype))
    (resbody._1,FunType(xtype,resbody._2))
  }
  case Ap(f,a) =&gt; {
    val toType = freshTypeVar
    (typeCheck(f,gamma),typeCheck(a,gamma)) match {
      case ((eqs1,ft),(eqs2,at)) =&gt; ((ft,FunType(at,toType)) :: (eqs1++eqs2),toType)
    }
  }
  case Let(x,xdef,body) =&gt; {
    val (constraints1, _) = typeCheck(xdef, gamma) // important if x is not used in body
    val (constraints2, typ) = typeCheck(subst(body, x, xdef), gamma) // Let-Polymorphism!
    (constraints1 ++ constraints2, typ)
  }

}

def doTypeCheck(e: Exp, gamma: Map[String,Type]) = {
  val (constraints, resType) = typeCheck(e, gamma)
  unify(constraints)(resType)
}

def eval(e: Exp) : Exp = e match {
  case Id(v) =&gt; sys.error(&quot;unbound identifier: &quot; + v)
  case Add(l,r) =&gt; (eval(l), eval(r)) match {
                     case (Num(x),Num(y)) =&gt; Num(x+y)
                     case _ =&gt; sys.error(&quot;can only add numbers&quot;)
                    }
  case Ap(f,a) =&gt; eval(f) match {
     case Fun(x,body) =&gt; eval( subst(body,x, eval(a)))  // call-by-value
     case _ =&gt; sys.error(&quot;can only apply functions&quot;)
  }
  case Let(x,xdef,body) =&gt; eval(subst(body,x,eval(xdef)))
  case _ =&gt; e // numbers and functions evaluate to themselves
}


assert(doTypeCheck(42,Map.empty) == NumType())
assert(doTypeCheck(Fun(&quot;x&quot;,Add(&quot;x&quot;,1)),Map.empty) == FunType(NumType(),NumType()))
</code></pre>
<p>Test <code>let-polymorphism</code>: The identity function is once applied to a function and once to a number:</p>
<pre><code class="language-scala">assert(doTypeCheck(Let(&quot;id&quot;, Fun(&quot;x&quot;,&quot;x&quot;), Ap(Ap(&quot;id&quot;,Fun(&quot;x&quot;,Add(&quot;x&quot;,1))),Ap(&quot;id&quot;,42))),Map.empty) == NumType())
</code></pre>
<p>This should trigger an occurs check error:
<code>doTypeCheck(Fun(&quot;x&quot;,Ap(&quot;x&quot;,&quot;x&quot;)),Map.empty)</code>
Hence omega cannot be type-checked in STLC.</p>
<p>Completeness of type inference:
If there exist type annotations that make a program type-check in the STLC type checker,
then the type inference will also be able to type-check the non-annotated version of the program.</p>
<p>Due to <code>let-polymorphism</code>, this program also type-checks some programs that would be ill-formed in STLC</p>
<p>The type system is still sound:
<code>If doTypeCheck(e,Map.empty) == t, then eval(e) == v and doTypeCheck(v) == t (modulo alpha-renaming of type variables)</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="questionnaire.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
