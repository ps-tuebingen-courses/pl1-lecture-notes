<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>First-Order Functions - Programming Languages I</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Lecture notes for the Programming Languages I lecture at the University of TÃ¼bingen">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded affix "><li class="part-title">Introduction</li><li class="chapter-item expanded "><a href="../01-intro/intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../02-scala-basics/scala-basics.html"><strong aria-hidden="true">2.</strong> Scala Basics</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic Language Features</li><li class="chapter-item expanded "><a href="../03-arithmetic-expressions/arithmetic-expressions.html"><strong aria-hidden="true">3.</strong> Arithmetic Expressions</a></li><li class="chapter-item expanded "><a href="../04-desugaring/desugaring.html"><strong aria-hidden="true">4.</strong> Desugaring</a></li><li class="chapter-item expanded "><a href="../05-name-binding/name-binding.html"><strong aria-hidden="true">5.</strong> Name Binding</a></li><li class="chapter-item expanded "><a href="../06-first-order-functions/first-order-functions.html" class="active"><strong aria-hidden="true">6.</strong> First-Order Functions</a></li><li class="chapter-item expanded "><a href="../07-higher-order-functions/higher-order-functions.html"><strong aria-hidden="true">7.</strong> Higher-Order Functions</a></li><li class="chapter-item expanded "><a href="../08-lazy-evaluation/lazy-evaluation.html"><strong aria-hidden="true">8.</strong> Lazy Evaluation</a></li><li class="chapter-item expanded "><a href="../09-recursive-functions/recursive-functions.html"><strong aria-hidden="true">9.</strong> Recursive Functions</a></li><li class="chapter-item expanded "><a href="../10-mutation/mutation.html"><strong aria-hidden="true">10.</strong> Mutation</a></li><li class="chapter-item expanded affix "><li class="part-title">Miscellaneous</li><li class="chapter-item expanded "><a href="../11-garbage-collection/garbage-collection.html"><strong aria-hidden="true">11.</strong> Garbage Collection</a></li><li class="chapter-item expanded "><a href="../12-meta-interpretation/meta-interpretation.html"><strong aria-hidden="true">12.</strong> Syntactic and Meta-Interpretation</a></li><li class="chapter-item expanded "><a href="../13-church-encoding/church-encoding.html"><strong aria-hidden="true">13.</strong> Church Encodings</a></li><li class="chapter-item expanded "><a href="../14-object-algebras/object-algebras.html"><strong aria-hidden="true">14.</strong> Object Algebras</a></li><li class="chapter-item expanded affix "><li class="part-title">Continuations</li><li class="chapter-item expanded "><a href="../15-continuations-1/continuations-1.html"><strong aria-hidden="true">15.</strong> Continuations: Motivation</a></li><li class="chapter-item expanded "><a href="../16-continuations-2/continuations-2.html"><strong aria-hidden="true">16.</strong> Continuations: Definition</a></li><li class="chapter-item expanded "><a href="../17-first-class-continuations/first-class-continuations.html"><strong aria-hidden="true">17.</strong> First-Class Continuations</a></li><li class="chapter-item expanded "><a href="../18-letcc/letcc.html"><strong aria-hidden="true">18.</strong> Call-with-current-continuation</a></li><li class="chapter-item expanded "><a href="../19-shift-reset/shift-reset.html"><strong aria-hidden="true">19.</strong> Delimited Continuations</a></li><li class="chapter-item expanded affix "><li class="part-title">Monads</li><li class="chapter-item expanded "><a href="../20-monads-intro/monads-intro.html"><strong aria-hidden="true">20.</strong> Monads Intro</a></li><li class="chapter-item expanded "><a href="../21-io-monad/io-monad.html"><strong aria-hidden="true">21.</strong> The IO Monad</a></li><li class="chapter-item expanded "><a href="../22-modular-interpreters/modular-interpreters.html"><strong aria-hidden="true">22.</strong> Modular Interpreters</a></li><li class="chapter-item expanded "><a href="../23-monadic-reflection/monadic-reflection.html"><strong aria-hidden="true">23.</strong> Monadic Reflection</a></li><li class="chapter-item expanded affix "><li class="part-title">Program Transformations</li><li class="chapter-item expanded "><a href="../24-defunctionalization/defunctionalization.html"><strong aria-hidden="true">24.</strong> Defunctionalization, Refunctionalization</a></li><li class="chapter-item expanded affix "><li class="part-title">Type Systems</li><li class="chapter-item expanded "><a href="../25-type-systems/type-systems.html"><strong aria-hidden="true">25.</strong> Type Systems</a></li><li class="chapter-item expanded "><a href="../26-stlc/stlc.html"><strong aria-hidden="true">26.</strong> Simply Typed Lambda Calculus (STLC)</a></li><li class="chapter-item expanded "><a href="../27-type-inference/type-inference.html"><strong aria-hidden="true">27.</strong> Type Inference</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programming Languages I</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes/blob/master/src/06-first-order-functions/first-order-functions.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="first-order-functions"><a class="header" href="#first-order-functions">First-Order Functions</a></h1>
<p>The content of this chapter is available as a Scala file <a href="./first-order-functions.scala">here.</a></p>
<h2 id="first-order-functions-1"><a class="header" href="#first-order-functions-1">First-Order Functions</a></h2>
<p>In the last lecture we have seen how we can give commonly occuring (sub)expressions a name via the <code>With</code> construct. Often, however,
we can identify <em>patterns</em> of expressions that occur in many places, such as <code>5*5/2</code>, <code>7*7/2</code> and <code>3*3/2</code>, the common pattern
being <code>x*x/2</code>. In this case, the abstraction capabilities of <code>With</code> are not sufficient.
One way to enable more powerful abstractions are <em>functions</em>. Depending on the context of use and the interaction with other language
features (such as imperative features or objects), functions are also sometimes called <em>procedures</em> or <em>methods</em>.
Here we consider so-called first-order functions, that - unlike higher-order functions - are not expressions and can hence not be passed
to or be returned from other functions. First-order functions are simply called by name.
To introduce first-order functions, we need two new things: The possibility to define functions, and the possibility to call functions.
A call to a function is an expression, whereas functions are defined separately. Functions can have an arbitrary number of arguments.
The following definitions are the language we have analyzed so far together with the new language constructs for first-order functions:</p>
<pre><code class="language-scala">object Syntax {
  enum Exp:
    case Num(n: Int) extends Exp
    case Add(lhs: Exp, rhs: Exp) extends Exp
    case Mul(lhs: Exp, rhs: Exp) extends Exp
    case Id(x: String) extends Exp
    case With(x: String, xdef: Exp, body: Exp) extends Exp

    /** The new language constructs for first-order functions: */
    case Call(f: String, args: List[Exp]) extends Exp // functions are called by name

  object Exp:
    /** The new language constructs for first-order functions: */
    case class FunDef(args: List[String], body: Exp)
    type Funs = Map[String, FunDef]

    /** We use implicits again to make example programs less verbose. */
    implicit def num2exp(n: Int): Exp = Num(n)
    implicit def string2exp(x: String): Exp = Id(x)
}
import Syntax._
import Exp._
</code></pre>
<p>A function has a number of formal args and a body. Note that a first-order function also
has a name. To make the invariant that there can only be one function for each
name explicit, we have stored functions in the form of a map from function names to
<code>FunDef</code>s above.</p>
<p>The substitution for the new language is a straightforward extension of the former one.</p>
<pre><code class="language-scala">def subst(e: Exp, i: String, v: Num): Exp =  e match {
    case Num(n) =&gt; e
    case Id(x) =&gt; if (x == i) v else e
    case Add(l, r) =&gt; Add(subst(l, i, v), subst(r, i, v))
    case Mul(l, r) =&gt; Mul(subst(l, i, v), subst(r, i, v))
    case With(x, xdef, body) =&gt; With(x,
                                     subst(xdef, i, v),
                                     if (x == i) body else subst(body, i, v))
    case Call(f, args) =&gt; Call(f, args.map(subst(_, i, v)))
}
</code></pre>
<p>We will first study a &quot;reference interpreter&quot; based on substitution.
We pass the map of functions as an additional parameter.</p>
<pre><code class="language-scala">def eval(funs: Funs, e: Exp): Int = e match {
  case Num(n) =&gt; n
  case Id(x) =&gt; sys.error(&quot;unbound identifier: &quot; + x)
  case Add(l, r) =&gt; eval(funs, l) + eval(funs, r)
  case Mul(l, r) =&gt; eval(funs, l) * eval(funs, r)
  case With(x, xdef, body) =&gt; eval(funs, subst(body, x, Num(eval(funs, xdef))))
  case Call(f, args) =&gt; {
     val fd = funs(f) // lookup function definition
     val vargs = args.map(eval(funs, _)) // evaluate function arguments
     if (fd.args.size != vargs.size)
       sys.error(&quot;number of parameters in call to &quot; + f + &quot; does not match&quot;)
     // We construct the function body to be evaluated by subsequently substituting
     // all formal arguments with their respective argument values.
     // If we have only a single argument &quot;fd.arg&quot; and a single argument value &quot;varg&quot;,
     // the next line of code is equivalent to:
     // val substbody = subst(fd.body, fd.arg, Num(varg))
     val substbody = fd.args.zip(vargs).foldLeft(fd.body)((b, av) =&gt; subst(b, av._1, Num(av._2)))
     eval(funs, substbody)
  }
}
</code></pre>
<p>Is the extension really so straightforward?  It can be seen in the last line of our
definition for <code>subst</code> that variable substitution deliberately ignores the function
name <code>f</code>. The substitution for <code>f</code> instead is handled separately inside <code>eval</code>.
We say in this case that function names and variable names live in different &quot;name spaces&quot;.
An alternative would be to have them share one namespace. As an exercise, think about how
to support a common namespace for function names and variable names.</p>
<p>A test case:</p>
<pre><code class="language-scala">val someFuns: Funs = Map(&quot;adder&quot; -&gt; FunDef(List(&quot;a&quot;, &quot;b&quot;), Add(&quot;a&quot;, &quot;b&quot;)),
                         &quot;doubleadder&quot; -&gt; FunDef(List(&quot;a&quot;, &quot;x&quot;),
                                                 Add(Call(&quot;adder&quot;, List(&quot;a&quot;, 5)),
                                                     Call(&quot;adder&quot;, List(&quot;x&quot;, 7)))))
</code></pre>
<pre><code class="language-scala">val callSomeFuns = eval(someFuns, Call(&quot;doubleadder&quot;, List(2, 3)))
// callSomeFuns: Int = 17
assert(callSomeFuns == 17)
</code></pre>
<h3 id="the-scope-of-function-definitions"><a class="header" href="#the-scope-of-function-definitions">The scope of function definitions:</a></h3>
<p>As can be seen in the example above, each function can &quot;see&quot; the other functions. We say that in this language functions have a <em>global scope</em>.
Exercise: Can a function also invoke itself? Is this useful?
We will now study an environment-based version of the interpreter. To motivate environments, consider the following sample program:</p>
<pre><code class="language-scala">val testProg = With(&quot;x&quot;, 1, With(&quot;y&quot;, 2, With(&quot;z&quot;, 3, Add(&quot;x&quot;, Add(&quot;y&quot;, &quot;z&quot;)))))
</code></pre>
<p>When considering the <code>With</code> case of the interpreter, the interpreter will subsequently produce and evaluate the following intermediate expressions:</p>
<pre><code class="language-scala">val testProgAfterOneStep     = With(&quot;y&quot;, 2, With(&quot;z&quot;, 3, Add(1, Add(&quot;y&quot;, &quot;z&quot;))))
val testProgAfterTwoSteps    = With(&quot;z&quot;, 3, Add(1, Add(2, &quot;z&quot;)))
val testProgAfterThreeSteps  = Add(1, Add(2, 3))
</code></pre>
<p>At this point only pure arithmetic is left. But we see that the interpreter had to apply subsitution three times. In general, if the
program size is n, then the interpreter may perform up to O(n) substitutions, each of which takes O(n) time. This quadratic complexity
seems rather wasteful. Can we do better?
We can avoid the redundancy by deferring the substitutions until they are really needed. Concretely, we define a repository of deferred
substitutions, called <em>environment</em>. It tells us which identifiers are supposed to be eventually substituted by which value. This idea
is captured in the following type definition:</p>
<pre><code class="language-scala">type Env = Map[String, Int]
</code></pre>
<p>Initially, we have no substitutions to perform, so the repository is empty. Every time we encounter a construct (a <code>With</code> or an application <code>Call</code>)
that requires substitution, we augment the repository with one more entry, recording the identifierâs name and the value (if eager) or
expression (if lazy) it should eventually be substituted with. We continue to evaluate without actually performing the substitution.
This strategy breaks a key invariant we had established earlier, which is that any identifier the interpreter could encounter must be
free, for had it been bound, it would have already been substituted.  Now that weâre no longer using the substitution-based model, we may
encounter bound identifiers during interpretation.  How do we handle them?  We must substitute them by consulting the repository.</p>
<pre><code class="language-scala">def evalWithEnv(funs: Funs, env: Env, e: Exp): Int = e match {
  case Num(n) =&gt; n
  case Id(x) =&gt; env(x) // look up in repository of deferred substitutions
  case Add(l, r) =&gt; evalWithEnv(funs, env, l) + evalWithEnv(funs, env, r)
  case Mul(l, r) =&gt; evalWithEnv(funs, env, l) * evalWithEnv(funs, env, r)
  case With(x, xdef, body) =&gt; evalWithEnv(funs, env + ((x, evalWithEnv(funs, env, xdef))), body)
  case Call(f, args) =&gt; {
     val fd = funs(f) // lookup function definition
     val vargs = args.map(evalWithEnv(funs, env, _)) // evaluate function arguments
     if (fd.args.size != vargs.size)
       sys.error(&quot;number of parameters in call to &quot; + f + &quot; does not match&quot;)
     // We construct the environment by associating each formal argument to its actual value
     val newenv = Map() ++ fd.args.zip(vargs)
     evalWithEnv(funs, newenv, fd.body)
  }
}

val evalEnvSomeFuns = evalWithEnv(someFuns, Map.empty, Call(&quot;doubleadder&quot;, List(2, 3)))
// evalEnvSomeFuns: Int = 17
assert(evalEnvSomeFuns == 17)
</code></pre>
<p>In the interpreter above, we have extended the empty environment when constructing <code>newenv</code>. A conceivable alternative is to
extend <code>env</code> instead, like so:</p>
<pre><code class="language-scala">def evalDynScope(funs: Funs, env: Env, e: Exp): Int = e match {
  case Num(n) =&gt; n
  case Id(x) =&gt; env(x)
  case Add(l, r) =&gt; evalDynScope(funs, env, l) + evalDynScope(funs, env, r)
  case Mul(l, r) =&gt; evalDynScope(funs, env, l) * evalDynScope(funs, env, r)
  case With(x, xdef, body) =&gt; evalDynScope(funs, env + ((x, evalDynScope(funs, env, xdef))), body)
  case Call(f, args) =&gt; {
     val fd = funs(f)
     val vargs = args.map(evalDynScope(funs, env, _))
     if (fd.args.size != vargs.size)
       sys.error(&quot;number of parameters in call to &quot; + f + &quot; does not match&quot;)
     val newenv = env ++ fd.args.zip(vargs) // extending env instead of Map() !!
     evalDynScope(funs, newenv, fd.body)
  }
}

val evalDynSomeFuns = evalDynScope(someFuns, Map.empty, Call(&quot;doubleadder&quot;, List(2, 3)))
// evalDynSomeFuns: Int = 17
assert(evalDynSomeFuns == 17)
</code></pre>
<p>Does this make a difference? Yes, it does. Here is an example:</p>
<pre><code class="language-scala">val funnyFun: Funs = Map(&quot;funny&quot; -&gt; FunDef(List(&quot;a&quot;), Add(&quot;a&quot;, &quot;b&quot;)))
</code></pre>
<pre><code class="language-scala">val evalDynFunnyFun = evalDynScope(funnyFun, Map.empty, With(&quot;b&quot;, 3, Call(&quot;funny&quot;, List(4))))
// evalDynFunnyFun: Int = 7
assert(evalDynFunnyFun == 7)
</code></pre>
<p>Obviously this interpreter is &quot;buggy&quot; in the sense that it does not agree with the substitution-based interpreter. But is this semantics reasonable?
Let's introduce some terminology to make the discussion simpler:</p>
<blockquote>
<p><strong>Definition (Static Scope)</strong>:
In a language with static scope, the scope of an identifierâs binding is a syntactically delimited region.
A typical region would be the body of a function or other binding construct.</p>
</blockquote>
<blockquote>
<p><strong>Definition (Dynamic Scope)</strong>: In a language with dynamic scope, the scope of an identifierâs binding is the entire remainder of the
execution during which that binding is in effect.</p>
</blockquote>
<p>We see that <code>eval</code> and <code>evalWithEnv</code> give our language static scoping, whereas <code>evalDynScope</code> gives our language dynamic scoping.
Armed with this terminology, we claim that dynamic scope is entirely unreasonable. The problem is that we simply cannot determine what
the value of a program will be without knowing everything about its execution history. If a function <code>f</code> were invoked by some
sequence of other functions that did not bind a value for some parameter of <code>f</code>, then that particular application of <code>f</code> would result in an error, even though a
previous application of <code>f</code> in the very same programâs execution may have completed successfully! In other words, simply by looking at the
source text of <code>f</code>, it would be impossible to determine one of the most rudimentary properties of a program: whether or not a given
identifier was bound. You can only imagine the mayhem this would cause in a large software system, especially with multiple developers
and complex ï¬ows of control. We will therefore regard dynamic scope as an error. That said, there are facets of dynamic binding
that are quite useful. For instance, exception handlers are typically dynamically scoped: A thrown exception is dispatched to the
most recently encountered active exception handler for that exception type.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../05-name-binding/name-binding.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../07-higher-order-functions/higher-order-functions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../05-name-binding/name-binding.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../07-higher-order-functions/higher-order-functions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../questionnaire.js"></script>
    </body>
</html>
