<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Garbage Collection - Programming Languages I</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Lecture notes for the Programming Languages I lecture at the University of TÃ¼bingen">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded affix "><li class="part-title">Introduction</li><li class="chapter-item expanded "><a href="../01-intro/intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../02-scala-basics/scala-basics.html"><strong aria-hidden="true">2.</strong> Scala Basics</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic Topics</li><li class="chapter-item expanded "><a href="../03-arithmetic-expressions/arithmetic-expressions.html"><strong aria-hidden="true">3.</strong> Arithmetic Expressions</a></li><li class="chapter-item expanded "><a href="../04-desugaring/desugaring.html"><strong aria-hidden="true">4.</strong> Desugaring</a></li><li class="chapter-item expanded "><a href="../05-name-binding/name-binding.html"><strong aria-hidden="true">5.</strong> Name Binding</a></li><li class="chapter-item expanded "><a href="../06-first-order-functions/first-order-functions.html"><strong aria-hidden="true">6.</strong> First Order Functions</a></li><li class="chapter-item expanded "><a href="../07-higher-order-functions/higher-order-functions.html"><strong aria-hidden="true">7.</strong> Higher Order Functions</a></li><li class="chapter-item expanded "><a href="../08-lazy-evaluation/lazy-evaluation.html"><strong aria-hidden="true">8.</strong> Lazy Evaluation</a></li><li class="chapter-item expanded "><a href="../09-recursive-functions/recursive-functions.html"><strong aria-hidden="true">9.</strong> Recursive Functions</a></li><li class="chapter-item expanded "><a href="../10-mutation/mutation.html"><strong aria-hidden="true">10.</strong> Mutation</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Topics 1</li><li class="chapter-item expanded "><a href="../11-garbage-collection/garbage-collection.html" class="active"><strong aria-hidden="true">11.</strong> Garbage Collection</a></li><li class="chapter-item expanded "><a href="../12-meta-interpretation/meta-interpretation.html"><strong aria-hidden="true">12.</strong> Syntactic and Meta Interpretation</a></li><li class="chapter-item expanded "><a href="../13-church-encoding/church-encoding.html"><strong aria-hidden="true">13.</strong> Church Encodings</a></li><li class="chapter-item expanded "><a href="../14-object-algebras/object-algebras.html"><strong aria-hidden="true">14.</strong> Object Algebras</a></li><li class="chapter-item expanded affix "><li class="part-title">Continuations</li><li class="chapter-item expanded "><a href="../15-continuations-1/continuations-1.html"><strong aria-hidden="true">15.</strong> Continuations: Motivation</a></li><li class="chapter-item expanded "><a href="../16-continuations-2/continuations-2.html"><strong aria-hidden="true">16.</strong> Continuations: Definition</a></li><li class="chapter-item expanded "><a href="../17-first-class-continuations/first-class-continuations.html"><strong aria-hidden="true">17.</strong> First Class Continuations</a></li><li class="chapter-item expanded "><a href="../18-letcc/letcc.html"><strong aria-hidden="true">18.</strong> Call-with-current-continuation</a></li><li class="chapter-item expanded "><a href="../19-shift-reset/shift-reset.html"><strong aria-hidden="true">19.</strong> Delimited Continuations</a></li><li class="chapter-item expanded affix "><li class="part-title">Monads</li><li class="chapter-item expanded "><a href="../20-monads-intro/monads-intro.html"><strong aria-hidden="true">20.</strong> Monads Intro</a></li><li class="chapter-item expanded "><a href="../21-io-monad/io-monad.html"><strong aria-hidden="true">21.</strong> The IO Monad</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Topics 2</li><li class="chapter-item expanded "><a href="../22-modular-interpreters/modular-interpreters.html"><strong aria-hidden="true">22.</strong> Modular Interpreters</a></li><li class="chapter-item expanded "><a href="../23-monadic-reflection/monadic-reflection.html"><strong aria-hidden="true">23.</strong> Monadic Reflection</a></li><li class="chapter-item expanded "><a href="../24-defunctionalization/defunctionalization.html"><strong aria-hidden="true">24.</strong> Defunctionalization</a></li><li class="chapter-item expanded affix "><li class="part-title">Type Systems</li><li class="chapter-item expanded "><a href="../25-type-systems/type-systems.html"><strong aria-hidden="true">25.</strong> Type Systems</a></li><li class="chapter-item expanded "><a href="../26-stlc/stlc.html"><strong aria-hidden="true">26.</strong> Simply Typed Lambda Calculus (STLC)</a></li><li class="chapter-item expanded "><a href="../27-type-inference/type-inference.html"><strong aria-hidden="true">27.</strong> Type Inference</a></li><li class="chapter-item expanded affix "><a href="../furtherreading.html">Further Reading</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programming Languages I</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes/blob/master/out/11-garbage-collection/garbage-collection.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="garbage-collection"><a class="header" href="#garbage-collection">Garbage Collection</a></h1>
<p>The content of this chapter is available as a Scala file <a href="./garbage-collection.scala">here.</a></p>
<p>Let us now consider a more accurate modeling of garbage collection (gc). This time, we will use a mutable store instead of
a functional store, because our purpose is not to explain mutation but to explain gc.</p>
<p>This is the well-known syntax of our language: FAE with boxes.</p>
<pre><code class="language-scala">enum Exp:
  case Num(n: Int)
  case Id(name: String)
  case Add(lhs: Exp, rhs: Exp)
  case Mul(lhs: Exp, rhs: Exp)
  case If0(cond: Exp, thenExp: Exp, elseExp: Exp)
  case Fun(param: String, body: Exp)
  case Ap (funExpr: Exp, argExpr: Exp)

  case NewBox(e: Exp)
  case SetBox(b: Exp, e: Exp)
  case OpenBox(b: Exp)
  case Seq(e1: Exp, e2: Exp)

object Exp:
  implicit def num2exp(n: Int): Exp = Num(n)
  implicit def id2exp(s: String): Exp = Id(s)
  def wth(x: String, xdef: Exp, body: Exp) : Exp = Ap(Fun(x,body),xdef)

import Exp._
</code></pre>
<p>We will equip our values with a mutable flag that is useful for mark-and-sweep garbage collection.
In real systems it is implemented as a bit flag, or, if the so-called &quot;tri-color algorithm&quot; is used, with two bit flags.</p>
<pre><code class="language-scala">abstract class Value {
  var marked : Boolean = false
}
</code></pre>
<p>We will also use a mutable map instead of a map for environments. This is not needed for mark-and-sweep,
but for copying garbage collectors such as Cheney&quot;s&quot; semi-space garbage collection algorithm.</p>
<pre><code class="language-scala">type Env = scala.collection.mutable.Map[String, Value]
case class NumV(n: Int) extends Value
case class ClosureV(f: Fun, env: Env) extends Value
case class AddressV(a: Int) extends Value
</code></pre>
<p>To be able to experiment with different store and gc designs, we create an interface for stores.
The stack parameter in <code>malloc</code> is needed during gc to determine the root nodes from which the algorithms can start.</p>
<pre><code class="language-scala">trait Store {
  def malloc(stack: List[Env], v: Value) : Int
  def update(index: Int, v: Value) : Unit
  def apply(index: Int) : Value
}
</code></pre>
<p>In our interpreter, the stack of environments is only implicitly available on the stack of the meta-language.
To reify the call-stack we need to make it explicit. We do so by constructing the stack explicitly and passing it as parameter.
The first element of the stack is the current environment; the rest is only needed for gc.</p>
<pre><code class="language-scala">def eval(e: Exp, stack: List[Env], store: Store) : Value = e match {

  case Num(n) =&gt; NumV(n)

  case Id(x) =&gt; stack.head(x)

  case f@Fun(_, _) =&gt; ClosureV(f, stack.head)

  /* With a mutable store, we do not have to thread it according to
   * the order of evaluation any more.
   */

  case If0(cond, thenExp, elseExp)
    =&gt; eval(cond, stack, store) match {
         case NumV(0) =&gt; eval(thenExp, stack, store)
         case _       =&gt; eval(elseExp, stack, store)
       }

  /* The mutable store allows us to take advantage of Scala's
   * evaluation order and perform two pattern matchings
   * simultaneously.
   */

  case Add(l, r)
    =&gt; (eval(l, stack, store), eval(r, stack, store)) match {
         case (NumV(v1), NumV(v2)) =&gt; NumV(v1 + v2)
         case _ =&gt; sys.error(&quot;can only add numbers&quot;)
       }

  case Mul(l, r)
    =&gt; (eval(l, stack, store), eval(r, stack, store)) match {
         case (NumV(v1), NumV(v2)) =&gt; NumV(v1 * v2)
         case _ =&gt; sys.error(&quot;can only multiply numbers&quot;)
       }

  /* A new environment should be pushed onto the stack only when
   * binding occurs. Where exactly in BCFAE do bindings happen?
   */

  case Ap(f, a)
    =&gt; eval(f, stack, store) match {
         case ClosureV(f, cEnv)
           =&gt; eval(
                f.body,
                (cEnv += (f.param -&gt; eval(a, stack, store))) :: stack,
                store
              )
         case _ =&gt; sys.error(&quot;can only apply functions&quot;)
       }

  /* The mutable store allows us to implement Seq-expression
   * in terms of sequencing in Scala itself.
   */

  case Seq(e1, e2)
    =&gt; eval(e1, stack, store); eval(e2, stack, store)

  case NewBox(e: Exp)
    =&gt; {
         val a = store.malloc(stack, eval(e, stack, store))
         AddressV(a)
       }

  case SetBox(b: Exp, e: Exp)
    =&gt; eval(b, stack, store) match {
         case AddressV(a)
           =&gt; {
                val ev = eval(e, stack, store)
                store.update(a, ev)
                ev
              }
         case _ =&gt; sys.error(&quot;can only set boxes&quot;)
       }

  case OpenBox(b: Exp)
    =&gt; eval(b, stack, store) match {
         case AddressV(a) =&gt; store(a)
         case _ =&gt; sys.error(&quot;can only open boxes&quot;)
       }
}
</code></pre>
<p>Here is one implementation of the Store interface that does not perform gc. It just runs out of memory once the store is full.</p>
<pre><code class="language-scala">class NoGCStore(size: Int) extends Store {

  val memory = new Array[Value](size)

  var nextFreeAddr : Int = 0

  def malloc(stack: List[Env], v: Value) : Int = {
    val x = nextFreeAddr
    if (x &gt;= size) sys.error(&quot;out of memory&quot;)
    nextFreeAddr += 1
    update(x, v)
    x
  }

  def update(index: Int, v: Value) : Unit = memory.update(index, v)

  def apply(index: Int) = memory(index)
}
</code></pre>
<p>Here is a mark-and-sweep garbage collector.</p>
<pre><code class="language-scala">class MarkAndSweepStore(size: Int) extends Store {

  val memory = new Array[Value](size)

  var free : Int = size

  var nextFreeAddr : Int = 0

  def malloc(stack: List[Env], v: Value) : Int = {
    if (free &lt;= 0) gc(stack)
    if (free &lt;= 0) sys.error(&quot;out of memory&quot;)

    /* Here we find the next available location in memory via a while-
     * loop. In order to avoid maintaining a list of available spaces
     * (because we are lazy), let us assume that no box created in
     * BCFAE can have an address pointing to a null memory cell (which
     * also is the case).
     *
     * If we ensure the invariant that the variable `free` has always
     * the number of free memory space, then the following loop will
     * always halt. The nontermination situation will generate an out-
     * of-memory error and the program will abort. */

    while (memory(nextFreeAddr) != null) {
      nextFreeAddr += 1
      if (nextFreeAddr == size) nextFreeAddr = 0
    }

    free -= 1
    update(nextFreeAddr, v)
    nextFreeAddr
  }

  def update(index: Int, v: Value) : Unit = memory.update(index, v)

  def apply(index: Int) = memory(index)

  def allAddrInVal(v: Value) : Set[Int] = v match {
    case AddressV(a)      =&gt; Set(a)
    case NumV(_)          =&gt; Set.empty
    case ClosureV(f, env) =&gt; allAddrInEnv(env)
  }

  def allAddrInEnv(env: Env) : Set[Int] =
    env.values.map(allAddrInVal _).fold(Set.empty)(_ union _)

  def mark(seed: Set[Int]) : Unit = {
    seed.foreach(memory(_).marked = true)
    val newAddresses = seed.flatMap(
                         ad =&gt; allAddrInVal(memory(ad))
                       ).filter(!memory(_).marked)
    if(newAddresses != Set.empty) {
      mark(newAddresses)
    }
  }

  /* What graph algorithm underlies the mark step as implemented here?
   * What potential problem could it cause in a &quot;real&quot; interpreter? */

  def sweep() : Unit = {
    memory.indices.foreach(
      index =&gt;   if (memory(index) == null) {
                   /* No work needed on an empty memory cell */
                 }
                 else if (memory(index).marked) {
                   /* Reset `marked` flag for the next gc */
                   memory(index).marked = false
                 }
                 else {
                   free += 1
                   memory(index) = null
                 }
    )
  }

  def gc(stack: List[Env]) : Unit = {
    println(&quot;\nSTARTING GC\nSTACK = &quot; + stack + &quot;\nSTORE = &quot; + memory)
    mark(stack.map(allAddrInEnv _).fold(Set.empty)(_ union _))
    sweep()
    println(&quot;GC COMPLETE\nSTORE = &quot; + memory +
            &quot;\nNUMBER OF FREE SLOTS = &quot; + free)
  }
}
</code></pre>
<pre><code class="language-scala">val test4 = wth(&quot;makedata&quot;, Fun(&quot;x&quot;, NewBox(NewBox(NewBox(&quot;x&quot;)))),
                Seq(Ap(&quot;makedata&quot;, 1),
                Seq(Ap(&quot;makedata&quot;, 2),
                Seq(wth(&quot;s&quot;, Ap(&quot;makedata&quot;, 3),
                            Ap(&quot;makedata&quot;, &quot;s&quot;)),
                    Ap(&quot;makedata&quot;, 4)))))
</code></pre>
<pre><code class="language-scala">def runTest4 = eval(
                 test4,
                 List(scala.collection.mutable.Map.empty),
                 new MarkAndSweepStore(5)
               )
</code></pre>
<p>This model of garbage collection does not illustrate the difficulty of memory management. In most languages, the size of
the allocated memory regions on the heap vary, and hence one needs an algorithm to find a free and large-enough spot on the heap.
There are various algorithms and heuristics (best-fit, worst-fit, first-fit, ...) for that purpose.</p>
<p>There are also various alternative gc designs. Mark-and-sweep is a non-moving algorithm, where reachable heap objects are never moved.
In contrast to that, copying gc algorithms move the reachable objects to a different portion of the heap. One of the oldest algorithms
is the semi-space garbage collector, in particular with the implementation purpose.</p>
<p>Topic for class discussion: What are the pros and cons of moving vs. non-moving gc?</p>
<p>It can be shown empirically that most unreachable objects become unreachable while they are still young. Generational gc algorithms
take this empirical fact into account and divide the objects into generations, whereby the (small) youngest generation of objects
is garbage-collected more frequently.</p>
<p>A typical problem of the simple gc algorithms we discussed is the stop-the-world phenomenon: All execution has to be stopped during
a gc cycle. This issue is addressed by incremental or concurrent garbage collectors. Incremental garbage collectors typically reduce
the total throughput but increase responsiveness and real-time behavior.</p>
<p>A completely different approach to memory management is <em>reference counting</em>. In reference counting, each object on the heap
(in our case, each box) maintains a counter which says how many pointers currently point to that object. The counter is adjusted
whenever a pointer variable is assigned to this object (incremented), or moved from this object to another object (decremented).
When the counter is 0, the object can be reclaimed.</p>
<p>The obvious disadvantage of reference counting is that it cannot detect cycles on the heap. Hence reference counting algorithm
must be augmented with some means to detect cycles.
Topic for class discussion: What are the pros and cons of reference counting vs. tracing garbage collectors such as mark-and-sweep
or semi-space?</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../10-mutation/mutation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../12-meta-interpretation/meta-interpretation.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../10-mutation/mutation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../12-meta-interpretation/meta-interpretation.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../questionnaire.js"></script>
    </body>
</html>
