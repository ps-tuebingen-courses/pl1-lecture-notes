<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Modular Interpreters - Programming Languages I</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Lecture notes for the Programming Languages I lecture at the University of TÃ¼bingen">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded affix "><li class="part-title">Introduction</li><li class="chapter-item expanded "><a href="../01-intro/intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../02-scala-basics/scala-basics.html"><strong aria-hidden="true">2.</strong> Scala Basics</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic Language Features</li><li class="chapter-item expanded "><a href="../03-arithmetic-expressions/arithmetic-expressions.html"><strong aria-hidden="true">3.</strong> Arithmetic Expressions</a></li><li class="chapter-item expanded "><a href="../04-desugaring/desugaring.html"><strong aria-hidden="true">4.</strong> Desugaring</a></li><li class="chapter-item expanded "><a href="../05-name-binding/name-binding.html"><strong aria-hidden="true">5.</strong> Name Binding</a></li><li class="chapter-item expanded "><a href="../06-first-order-functions/first-order-functions.html"><strong aria-hidden="true">6.</strong> First-Order Functions</a></li><li class="chapter-item expanded "><a href="../07-higher-order-functions/higher-order-functions.html"><strong aria-hidden="true">7.</strong> Higher-Order Functions</a></li><li class="chapter-item expanded "><a href="../08-lazy-evaluation/lazy-evaluation.html"><strong aria-hidden="true">8.</strong> Lazy Evaluation</a></li><li class="chapter-item expanded "><a href="../09-recursive-functions/recursive-functions.html"><strong aria-hidden="true">9.</strong> Recursive Functions</a></li><li class="chapter-item expanded "><a href="../10-mutation/mutation.html"><strong aria-hidden="true">10.</strong> Mutation</a></li><li class="chapter-item expanded affix "><li class="part-title">Miscellaneous</li><li class="chapter-item expanded "><a href="../11-garbage-collection/garbage-collection.html"><strong aria-hidden="true">11.</strong> Garbage Collection</a></li><li class="chapter-item expanded "><a href="../12-meta-interpretation/meta-interpretation.html"><strong aria-hidden="true">12.</strong> Syntactic and Meta-Interpretation</a></li><li class="chapter-item expanded "><a href="../13-church-encoding/church-encoding.html"><strong aria-hidden="true">13.</strong> Church Encodings</a></li><li class="chapter-item expanded "><a href="../14-object-algebras/object-algebras.html"><strong aria-hidden="true">14.</strong> Object Algebras</a></li><li class="chapter-item expanded affix "><li class="part-title">Continuations</li><li class="chapter-item expanded "><a href="../15-continuations-1/continuations-1.html"><strong aria-hidden="true">15.</strong> Continuations: Motivation</a></li><li class="chapter-item expanded "><a href="../16-continuations-2/continuations-2.html"><strong aria-hidden="true">16.</strong> Continuations: Definition</a></li><li class="chapter-item expanded "><a href="../17-first-class-continuations/first-class-continuations.html"><strong aria-hidden="true">17.</strong> First-Class Continuations</a></li><li class="chapter-item expanded "><a href="../18-letcc/letcc.html"><strong aria-hidden="true">18.</strong> Call-with-current-continuation</a></li><li class="chapter-item expanded "><a href="../19-shift-reset/shift-reset.html"><strong aria-hidden="true">19.</strong> Delimited Continuations</a></li><li class="chapter-item expanded affix "><li class="part-title">Monads</li><li class="chapter-item expanded "><a href="../20-monads-intro/monads-intro.html"><strong aria-hidden="true">20.</strong> Monads Intro</a></li><li class="chapter-item expanded "><a href="../21-io-monad/io-monad.html"><strong aria-hidden="true">21.</strong> The IO Monad</a></li><li class="chapter-item expanded "><a href="../22-modular-interpreters/modular-interpreters.html" class="active"><strong aria-hidden="true">22.</strong> Modular Interpreters</a></li><li class="chapter-item expanded "><a href="../23-monadic-reflection/monadic-reflection.html"><strong aria-hidden="true">23.</strong> Monadic Reflection</a></li><li class="chapter-item expanded affix "><li class="part-title">Program Transformations</li><li class="chapter-item expanded "><a href="../24-defunctionalization/defunctionalization.html"><strong aria-hidden="true">24.</strong> Defunctionalization, Refunctionalization</a></li><li class="chapter-item expanded affix "><li class="part-title">Type Systems</li><li class="chapter-item expanded "><a href="../25-type-systems/type-systems.html"><strong aria-hidden="true">25.</strong> Type Systems</a></li><li class="chapter-item expanded "><a href="../26-stlc/stlc.html"><strong aria-hidden="true">26.</strong> Simply Typed Lambda Calculus (STLC)</a></li><li class="chapter-item expanded "><a href="../27-type-inference/type-inference.html"><strong aria-hidden="true">27.</strong> Type Inference</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programming Languages I</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ps-tuebingen-courses/pl1-lecture-notes/blob/master/src/22-modular-interpreters/modular-interpreters.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="modular-interpreters"><a class="header" href="#modular-interpreters">Modular Interpreters</a></h1>
<p>The content of this chapter is available as a Scala file <a href="./modular-interpreters.scala">here.</a></p>
<h1 id="a-monad-library"><a class="header" href="#a-monad-library">A Monad Library</a></h1>
<p>We define a Monad library in Scala. Monad libraries like
in scalaz and cats (for Scala) or the Haskell standard library look similar.</p>
<pre><code class="language-scala">trait Monad {
  type M[_] // this time we treat M as a type member and not as type parameter
            // because it leads to shorter type signatures
  def unit[A](a: A): M[A]
  def bind[A, B](m: M[A], f: A =&gt; M[B]): M[B]

  extension [A](m: M[A])
    def map[B](f: A =&gt; B): M[B] = bind(m, (x: A) =&gt; unit(f(x)))
    def flatMap[B](f: A =&gt; M[B]): M[B] = bind(m, f)
}
</code></pre>
<p>We formulate concrete monads in the form of abstract interfaces first.
The idea of those interfaces is that it should be possible to use
the monad only in terms of that interface, without knowing anything
about <code>M</code>. The advantage of this approach is that it enables us to
compose monads. <code>M</code> changes in every composition of monads. For instance,
when composing the list monad and the option monad, then
<code>M[X] = Option[List[X]]</code> or <code>M[X] = List[Option[X]]</code>.</p>
<p>By keeping <code>M</code> abstract and using it only via the interfaces, &quot;client code&quot;
does not need to depend on the particular composition of monads.</p>
<h3 id="reader-monad"><a class="header" href="#reader-monad">Reader Monad</a></h3>
<p>The Reader (or Environment) monad captures computations that depend
on an environment of type <code>R</code>.</p>
<p>The <code>ask</code> function yields the current environment, the <code>local</code> function
is used to transform the environment in a subcomputation a by an
environment transformer <code>f</code>.</p>
<pre><code class="language-scala">trait ReaderMonad extends Monad {
  type R
  def ask: M[R]
  def local[A](f: R =&gt; R, a: M[A]): M[A]
}
</code></pre>
<p>The standard implementation of the Reader monad:</p>
<pre><code class="language-scala">trait ReaderMonadImp extends ReaderMonad {
  type M[X] = R =&gt; X
  def unit[A](a: A): M[A] = r =&gt; a
  def bind[A, B](m: M[A], f: A =&gt; M[B]): M[B] = r =&gt; f(m(r))(r)
  def ask: M[R] = identity
  def local[A](f: R =&gt; R, a: M[A]): M[A] = r =&gt; a(f(r))
}
</code></pre>
<p>An example of using the Reader monad to propagate an environment
of type <code>Int</code> through a computation.</p>
<pre><code class="language-scala">object ReaderExample extends ReaderMonadImp {
  type R = Int
  def example: M[Int] = for { x &lt;- ask } yield (x + 1)
  def example2: M[Int] = local(r =&gt; 99, example)
}
</code></pre>
<p>A more useful example where we use the Reader monad
to propagate a mapping from identifiers to boolean values
in an interpreter for boolean formulas. Note that the signature of
<code>eval</code> is identical to <code>def eval(e: Exp): Map[String, Boolean] =&gt; Boolean</code>,
that is, we curry <code>eval</code> to make it applicable to the Reader monad.</p>
<pre><code class="language-scala">object ReaderExample2 extends ReaderMonadImp {
  enum Exp:
    case Id(x: String)
    case And(l: Exp, r: Exp)
    case Or(l: Exp, r: Exp)
  import Exp._
  type R = Map[String, Boolean]

  def eval(e: Exp): M[Boolean] = e match {
    case Id(x) =&gt; for {env &lt;- ask } yield env(x)
    case And(l, r) =&gt; for {
      x &lt;- eval(l)
      y &lt;- eval(r)
    } yield (x &amp;&amp; y)
    case Or(l, r) =&gt; for {
      x &lt;- eval(l)
      y &lt;- eval(r)
    } yield (x || y)
  }
}
</code></pre>
<p>The implementation of the <code>And</code> case is semantically equivalent to this code:</p>
<pre><code class="language-scala">case And(l, r) =&gt; env =&gt; {
  val x = eval(l)(env)
  val y = eval(r)(env)
  x &amp;&amp; y
}
</code></pre>
<p>However, the monadic code is more abstract (and hence
more reusable) because it is not coupled to the concrete <code>M</code>.</p>
<h3 id="state-monad"><a class="header" href="#state-monad">State Monad</a></h3>
<p>This is the interface and standard implementation for the State monad:</p>
<pre><code class="language-scala">trait StateMonad extends Monad {
  type S
  def getState: M[S]
  def putState(s: S): M[Unit]
}

trait StateMonadImp extends StateMonad {
  type M[A] = S =&gt; (A, S)
  def unit[A](a: A): M[A] = (s: S) =&gt; (a, s)
  def bind[A, B](m: M[A], f: A =&gt; M[B]): M[B] = (s: S) =&gt; {
    val (a, s2) = m(s)
    f(a)(s2)
  }
  def getState: M[S] = s =&gt; (s, s)
  def putState(s: S): M[Unit] = _ =&gt; ((), s)
}
</code></pre>
<h3 id="continuation-monad"><a class="header" href="#continuation-monad">Continuation Monad</a></h3>
<p>And here is the interface for the Continuation monad. The Continuation monad provides
a method <code>callcc</code>, which reifies the current Continuation <code>k: A =&gt; M[B]</code>.</p>
<pre><code class="language-scala">trait ContinuationMonad extends Monad {
  def callcc[A, B](f: (A =&gt; M[B]) =&gt; M[A]): M[A]
}
</code></pre>
<h2 id="implementaions"><a class="header" href="#implementaions">Implementaions</a></h2>
<p>Now we provide implementations of the monad interfaces.</p>
<p>The identity monad, which is the end of each transformer chain reads:</p>
<pre><code class="language-scala">trait IdentityMonad extends Monad {
  type M[A] = A
  def unit[A](a: A): M[A] = a
  def bind[A, B](m: M[A], f: A =&gt; M[B]) = f(m)
}

object IdentityMonad extends IdentityMonad
</code></pre>
<p>We organize most other monads as monad <em>transformers</em>.
A monad transformer is parameterized with another monad.
The monads are organized in a chain. Operations of &quot;inner&quot; monads must be lifted to top-level operations.</p>
<pre><code class="language-scala">trait MonadTransformer extends Monad {
  val m: Monad
}
</code></pre>
<h3 id="reader-monad-transformer"><a class="header" href="#reader-monad-transformer">Reader Monad Transformer</a></h3>
<p>The Reader monad transformer. We provide some convenient
functions <code>lift</code>, <code>lift2</code> etc. to lift functions from the inner monad.
Note that <code>M[X] = R =&gt; m.M[X]</code> instead of <code>M[X] = R =&gt; X</code> (as for
the non-transformer version of the Reader monad).
The correct implementation of the interface methods follows from
this type equation.</p>
<pre><code class="language-scala">trait ReaderT extends MonadTransformer with ReaderMonad {
  type R
  override type M[X] = R =&gt; m.M[X]
  override def unit[A](a: A): M[A] = r =&gt; m.unit(a)
  override def bind[A, B](x: M[A], f: A =&gt; M[B]): M[B] =
    r =&gt; m.bind(x(r), (n: A) =&gt; f(n)(r))
  override def ask: M[R] = r =&gt; m.unit(r)
  override def local[A](f: R =&gt; R, a: M[A]): M[A] = r =&gt; a(f(r))
  protected implicit def lift[A](x: m.M[A]): M[A] = r =&gt; x
  protected implicit def lift2[A, B](x: A =&gt; m.M[B]): A =&gt; M[B] = a =&gt; lift(x(a))
  protected implicit def lift3[A, B, C](x: (A =&gt; m.M[B]) =&gt; m.M[C]): (A =&gt; M[B]) =&gt; M[C] =
    f =&gt; r =&gt; x((a: A) =&gt; f(a)(r))
  protected implicit def lift4[A, B, C, D](x: ((A =&gt; m.M[B]) =&gt; m.M[C]) =&gt; m.M[D]): ((A =&gt; M[B]) =&gt; M[C]) =&gt; M[D] =
    f =&gt; r =&gt; x((a: A =&gt; m.M[B]) =&gt; f(lift2(a))(r))
}

// The original Reader monad can be reconstructed by composing ReaderT with the identity monad.

trait ReaderMonadImpl extends ReaderT {
  val m: IdentityMonad = IdentityMonad
}
</code></pre>
<p>We do not need this because we have just synthesized it:</p>
<pre><code class="language-scala">trait ReaderMonadImpl extends ReaderMonad {
  type M[X] = R =&gt; X
  def unit[A](a: A): M[A] = r =&gt; a
  def bind[A, B](m: M[A], f: A =&gt; M[B]): M[B] = r =&gt; f(m(r))(r)
  def ask: M[R] = identity
  def local[A](f: R =&gt; R, a: M[A]): M[A] = (r) =&gt; a(f(r))
}
</code></pre>
<h3 id="state-monad-transformer"><a class="header" href="#state-monad-transformer">State Monad Transformer</a></h3>
<p>The design of <code>StateT</code> is similar to that of <code>ReaderT</code>:</p>
<pre><code class="language-scala">trait StateT extends MonadTransformer with StateMonad {
  type M[A] = S =&gt; m.M[(A, S)]
  override def unit[A](a: A): M[A] = (s: S) =&gt; m.unit(a, s)
  override def bind[A, B](x: M[A], f: A =&gt; M[B]): M[B] = (s: S) =&gt; {
     m.bind[(A, S), (B, S)](x(s), { case (a, s2) =&gt; f(a)(s2)})
  }
  override def getState: M[S] = s =&gt; m.unit((s, s))
  override def putState(s: S): M[Unit] = _ =&gt; m.unit(((), s))
}

// and again we can reconstruct the ordinary State monad.

trait StateMonadImpl extends StateT {
  val m: IdentityMonad = IdentityMonad
}
</code></pre>
<p>We do not need this because we have just synthesized it:</p>
<pre><code class="language-scala">trait StateMonadImpl extends StateMonad {
  type M[A] = S =&gt; (A, S)
  def unit[A](a: A): M[A] = (s: S) =&gt; (a, s)
  def bind[A, B](m: M[A], f: A =&gt; M[B]): M[B] = (s: S) =&gt; {
     val (a, s2) = m(s)
     f(a)(s2)
  }
  def getState: M[S] = s =&gt; (s, s)
  def putState(s: S): M[Unit] = _ =&gt; ((), s)
}
</code></pre>
<h3 id="continuation-monad-1"><a class="header" href="#continuation-monad-1">Continuation Monad</a></h3>
<p>We could also synthesize <code>ContinuationMonadImpl</code> from a <code>ContT</code>
just as we did for <code>ReaderMonadImpl</code> and <code>StateMonadImpl</code>,
but for simplicity we only present the ordinary Continuation monad here.</p>
<pre><code class="language-scala">trait ContinuationMonadImpl extends ContinuationMonad {
  type T
  type M[A] = (A =&gt; T) =&gt; T
  override def unit[A](a: A): M[A] = k =&gt; k(a)
  override def bind[A, B](m: M[A], f: A =&gt; M[B]): M[B] = k =&gt; m(a =&gt; f(a)(k))
  override def callcc[A, B](f: (A =&gt; M[B]) =&gt; M[A]): M[A] = k =&gt; f(a =&gt; _ =&gt; k(a))(k)
}
</code></pre>
<h2 id="compositions"><a class="header" href="#compositions">Compositions</a></h2>
<p>Let's compose some monads.</p>
<p>The composition of the Reader monad and some Continuation monad.</p>
<pre><code class="language-scala">trait ReaderContinuationMonadForwarder extends ReaderT with ContinuationMonad {
  val m: ContinuationMonad
  // call to lift4 inserted automatically
  override def callcc[A, B](f: (A =&gt; M[B]) =&gt; M[A]): M[A] = (m.callcc[A, B] _)(f)
}
</code></pre>
<p>For the implementation, we use the Continuation-monad implementation.</p>
<pre><code class="language-scala">trait ReaderContinuationMonadImpl extends ReaderContinuationMonadForwarder {
  type T
  val m: ContinuationMonadImpl { type T = ReaderContinuationMonadImpl.this.T } =
    new ContinuationMonadImpl { type T = ReaderContinuationMonadImpl.this.T }
}
</code></pre>
<p>Composition of the Reader monad with some State monad.</p>
<pre><code class="language-scala">trait ReaderStateMonadForwarder extends ReaderT with StateMonad {
  val m: StateMonad { type S = ReaderStateMonadForwarder.this.S }
  override def getState: M[S] = m.getState
  override def putState(s: S): M[Unit] = m.putState(s)
}
</code></pre>
<p>And the implementation with StateMonadImpl.</p>
<pre><code class="language-scala">trait ReaderStateMonadImpl extends ReaderStateMonadForwarder {
  val m: StateMonadImpl { type S = ReaderStateMonadImpl.this.S } =
    new StateMonadImpl { type S = ReaderStateMonadImpl.this.S }
}
</code></pre>
<h2 id="a-modular-interpreter"><a class="header" href="#a-modular-interpreter">A Modular Interpreter</a></h2>
<p>Now we use the monad library to modularize the interpreters of
the various language variants we have seen so far.</p>
<pre><code class="language-scala">trait Expressions extends Monad {
  abstract class Value
  abstract class Exp {
    def eval: M[Value]
  }
}

trait Numbers extends Expressions {
  case class NumV(n: Int) extends Value
}

trait Arithmetic extends Numbers {
  case class Num(n: Int) extends Exp {
    def eval = unit(NumV(n))
  }
  implicit def num2exp(n: Int): Exp = Num(n)

  case class Add(lhs: Exp, rhs: Exp) extends Exp {
    def eval = for {
                 l &lt;- lhs.eval
                 r &lt;- rhs.eval
               } yield (l, r) match {
                 case (NumV(v1), NumV(v2)) =&gt; NumV(v1 + v2)
                 case _ =&gt; sys.error(&quot;can only add numbers&quot;)
               }
  }
}

trait If0 extends Numbers {
  case class If0(cond: Exp, thenExp: Exp, elseExp: Exp) extends Exp {
    def eval = for {
                 c &lt;- cond.eval
                 res &lt;- c match {
                   case NumV(0) =&gt; thenExp.eval
                   case _ =&gt; elseExp.eval
                 }
               } yield res
  }
}

trait Functions extends Expressions with ReaderMonad {
  type Env = Map[String, Value]
  override type R = Env

  case class ClosureV(f: Fun, env: Env) extends Value
  case class Fun(param: String, body: Exp) extends Exp {
    def eval = for { env &lt;- ask } yield ClosureV(this, env)
  }
  case class Ap(f: Exp, a: Exp) extends Exp {
    def eval = for {
                 fv &lt;- f.eval
                 av &lt;- a.eval
                 res &lt;- fv match {
                   case ClosureV(fun, cenv) =&gt;
                     local(env =&gt; cenv + (fun.param -&gt; av), fun.body.eval)
                 }
               } yield res
  }
  case class Id(x: String) extends Exp {
    def eval = for {
                 env &lt;- ask
               } yield env(x)
  }
  implicit def id2exp(x: String): Exp = Id(x)
  def wth(x: String, xdef: Exp, body: Exp): Exp = Ap(Fun(x, body), xdef)
}


trait Boxes extends Expressions with StateMonad  {
  type Store = Map[Address, Value]
  override type S = Store

  type Address = Int
  var _nextAddress = 0

  def nextAddress: Address = {
    _nextAddress += 1
    _nextAddress
  }

  case class AddressV(a: Address) extends Value

  case class NewBox(e: Exp) extends Exp {
    def eval = {
      val a = nextAddress
      for {
        v &lt;- e.eval
        s &lt;- getState
        _ &lt;- putState(s + (a -&gt; v))
      } yield AddressV(a)
    }
  }
  case class SetBox(b: Exp, e: Exp) extends Exp {
    def eval =
      for {
         box &lt;- b.eval
         ev  &lt;- e.eval
         s   &lt;- getState
         _   &lt;- putState(box match { case AddressV(a) =&gt; s.updated(a, ev) })
      } yield ev
  }
  case class OpenBox(b: Exp) extends Exp {
    def eval = for {
                 bv &lt;- b.eval
                 s  &lt;- getState
               } yield (bv match { case AddressV(a) =&gt; s(a) })
  }
  case class Seq(e1: Exp, e2: Exp) extends Exp {
    def eval = bind(e1.eval, (_: Value) =&gt; e2.eval)
  }

}

trait Letcc extends Expressions with ContinuationMonad with ReaderMonad {
  override type R = Map[String, Value]

  // We introduce a new application form CAp instead of using Ap because we cannot extend Ap
  case class CAp(f: Exp, a: Exp) extends Exp {
    override def eval: M[Value] =
      for {
         fv &lt;- f.eval
         av &lt;- a.eval
         res &lt;- fv match { case ContV(f) =&gt; f(av) }
       } yield res
  }
  case class Letcc(param: String, body: Exp) extends Exp {
    override def eval: M[Value] =
      callcc[Value, Value](k =&gt; local(env =&gt; env + (param -&gt; ContV(k)), body.eval))
  }
  case class ContV(f: Value =&gt; M[Value]) extends Value
}
</code></pre>
<p>Let's compose together some languages!</p>
<pre><code class="language-scala">object AE extends Arithmetic with IdentityMonad {
  val aetest = Add(1, Add(2, 3))
}
assert(AE.aetest.eval == AE.NumV(6))

object FAELang extends Functions with Arithmetic with ReaderMonadImpl {
  val faetest = Ap(Fun(&quot;x&quot;, Add(&quot;x&quot;, 1)), Add(2, 3))
  assert(faetest.eval(Map.empty) == NumV(6))
}
object BCFAE extends Boxes with Arithmetic with Functions with If0 with ReaderStateMonadImpl {
  val test = wth(&quot;switch&quot;, NewBox(0),
                wth(&quot;toggle&quot;, Fun(&quot;dummy&quot;, If0(OpenBox(&quot;switch&quot;),
                                          Seq(SetBox(&quot;switch&quot;, 1), 1),
                                          Seq(SetBox(&quot;switch&quot;, 0), 0))),
                    Add(Ap(&quot;toggle&quot;, 42), Ap(&quot;toggle&quot;, 42))))
}

assert(BCFAE.test.eval(Map.empty)(Map.empty)._1 == BCFAE.NumV(1))

object FAEwLetcc extends Arithmetic with Functions with If0 with Letcc with ReaderContinuationMonadImpl {
  override type T = Value
  val testprog = Add(1, Letcc(&quot;k&quot;, Add(2, CAp(&quot;k&quot;, 3))))
}

assert(FAEwLetcc.testprog.eval(Map.empty)(identity) == FAEwLetcc.NumV(4))
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../21-io-monad/io-monad.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../23-monadic-reflection/monadic-reflection.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../21-io-monad/io-monad.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../23-monadic-reflection/monadic-reflection.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../questionnaire.js"></script>
    </body>
</html>
